<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY mdash "&#8212;">
  <!ENTITY Note "<x:h xmlns:x='http://purl.org/net/xml2rfc/ext'>Note:</x:h>">
  <!ENTITY architecture               "<xref target='RFC7230' x:rel='#architecture' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY conformance                "<xref target='RFC7230' x:rel='#conformance' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation                   "<xref target='RFC7230' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY abnf-extension             "<xref target='RFC7230' x:rel='#abnf.extension' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY acks                       "<xref target='RFC7230' x:rel='#acks' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY whitespace                 "<xref target='RFC7230' x:rel='#whitespace' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY field-components           "<xref target='RFC7230' x:rel='#field.components' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY messaging                  "<xref target='RFC7230' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY semantics                  "<xref target='RFC7231' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY http-date                  "<xref target='RFC7231' x:rel='#http.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY representation             "<xref target='RFC7231' x:rel='#representations' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY entity-tags                "<xref target='RFC7232' x:rel='#header.etag' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY weak-and-strong-validators "<xref target='RFC7232' x:rel='#weak.and.strong.validators' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY entity-tag-comparison      "<xref target='RFC7232' x:rel='#entity.tag.comparison' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY lastmod-comparison         "<xref target='RFC7232' x:rel='#lastmod.comparison' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY p6-heuristic               "<xref target='RFC7234' x:rel='#heuristic.freshness' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2616" category="std" x:maturity-level="proposed"
     ipr="pre5378Trust200902" number="7233" consensus="yes"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
<x:link rel="prev" basename="rfc7232"/>
<x:link rel="next" basename="rfc7234"/>
<!--<x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>-->
<front>

  <title abbrev="HTTP/1.1 Range Requests">Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
    <organization abbrev="W3C">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>W3C / ERCIM</street>
        <street>2004, rte des Lucioles</street>
        <city>Sophia-Antipolis</city>
        <region>AM</region>
        <code>06902</code>
        <country>France</country>
      </postal>
      <email>ylafon@w3.org</email>
      <uri>http://www.raubacapeu.net/people/yves/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="June" year="2014"/>

  <area>Applications</area>
  <workgroup>HTTPbis</workgroup>

  <keyword>Hypertext Transfer Protocol</keyword>
  <keyword>HTTP</keyword>
  <keyword>HTTP Range Requests</keyword>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for
   distributed, collaborative, hypertext information systems. This document
   defines range requests and the rules for constructing and combining
   responses to those requests.
</t>
</abstract>
</front>
<middle>
<section title="Introduction" anchor="introduction">
<t>
   Hypertext Transfer Protocol (HTTP) clients often encounter interrupted data
   transfers as a result of canceled requests or dropped connections. When a
   client has stored a partial representation, it is desirable to request the
   remainder of that representation in a subsequent request rather than
   transfer the entire representation. Likewise, devices with limited local
   storage might benefit from being able to request only a subset of a larger
   representation, such as a single page of a very large document, or the
   dimensions of an embedded image.
</t>
<t>
   This document defines HTTP/1.1 range requests, partial responses, and the
   multipart/byteranges media type. Range requests are an &OPTIONAL; feature
   of HTTP, designed so that recipients not implementing this feature (or not
   supporting it for the target resource) can respond as if it is a normal
   GET request without impacting interoperability. Partial responses are
   indicated by a distinct status code to not be mistaken for full responses
   by caches that might not implement the feature.
</t>
<t>
   Although the range request mechanism is designed to allow for
   extensible range types, this specification only defines requests for
   byte ranges.
</t>

<section title="Conformance and Error Handling" anchor="conformance">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   Conformance criteria and considerations regarding error handling
   are defined in &conformance;.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
<t>
   This specification uses the Augmented Backus-Naur Form (ABNF) notation of
   <xref target="RFC5234"/> with a list extension, defined in
   &abnf-extension;, that allows for compact definition of
   comma-separated lists using a '#' operator (similar to how the '*' operator
   indicates repetition).
   <xref target="imported.abnf"/> describes rules imported from
   other documents. 
   <xref target="collected.abnf"/> shows the collected grammar with all list
   operators expanded to standard ABNF notation.
</t>
</section>
</section>


<section title="Range Units" anchor="range.units">
  <x:anchor-alias value="range-unit"/>
  <x:anchor-alias value="range unit"/>
<t>
   A representation can be partitioned into subranges according to various
   structural units, depending on the structure inherent in the
   representation's media type. This "<x:dfn>range unit</x:dfn>" is used
   in the <x:ref>Accept-Ranges</x:ref> (<xref target="header.accept-ranges"/>)
   response header field to advertise support for range requests, the
   <x:ref>Range</x:ref> (<xref target="header.range"/>) request header field
   to delineate the parts of a representation that are requested, and the
   <x:ref>Content-Range</x:ref> (<xref target="header.content-range"/>)
   payload header field to describe which part of a representation is being
   transferred.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="range-unit"/><iref item="Grammar" subitem="bytes-unit"/><iref item="Grammar" subitem="other-range-unit"/>
  <x:ref>range-unit</x:ref>       = <x:ref>bytes-unit</x:ref> / <x:ref>other-range-unit</x:ref>
</artwork></figure>

<section title="Byte Ranges" anchor="byte.ranges">
  <x:anchor-alias value="bytes-unit"/>
<t>
   Since representation data is transferred in payloads as a sequence of
   octets, a byte range is a meaningful substructure for any representation
   transferable over HTTP (&representation;). The "bytes" range unit is
   defined for expressing subranges of the data's octet sequence.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="bytes-unit"/>
  <x:ref>bytes-unit</x:ref>       = "bytes"
</artwork></figure>
<t anchor="rule.ranges-specifier">
  <x:anchor-alias value="byte-range-set"/>
  <x:anchor-alias value="byte-range-spec"/>
  <x:anchor-alias value="byte-ranges-specifier"/>
  <x:anchor-alias value="first-byte-pos"/>
  <x:anchor-alias value="last-byte-pos"/>
  <x:anchor-alias value="ranges-specifier"/>
  <x:anchor-alias value="suffix-byte-range-spec"/>
  <x:anchor-alias value="suffix-length"/>
   A byte-range request can specify a single range of bytes or a set
   of ranges within a single representation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="ranges-specifier"/><iref primary="true" item="Grammar" subitem="byte-ranges-specifier"/><iref primary="true" item="Grammar" subitem="byte-range-set"/><iref primary="true" item="Grammar" subitem="byte-range-spec"/><iref primary="true" item="Grammar" subitem="first-byte-pos"/><iref primary="true" item="Grammar" subitem="last-byte-pos"/>
  <x:ref>byte-ranges-specifier</x:ref> = <x:ref>bytes-unit</x:ref> "=" <x:ref>byte-range-set</x:ref>
  <x:ref>byte-range-set</x:ref>  = 1#( <x:ref>byte-range-spec</x:ref> / <x:ref>suffix-byte-range-spec</x:ref> )
  <x:ref>byte-range-spec</x:ref> = <x:ref>first-byte-pos</x:ref> "-" [ <x:ref>last-byte-pos</x:ref> ]
  <x:ref>first-byte-pos</x:ref>  = 1*<x:ref>DIGIT</x:ref>
  <x:ref>last-byte-pos</x:ref>   = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   The <x:ref>first-byte-pos</x:ref> value in a <x:ref>byte-range-spec</x:ref>
   gives the byte-offset of the first byte in a range.
   The <x:ref>last-byte-pos</x:ref> value gives the byte-offset of the last
   byte in the range; that is, the byte positions specified are inclusive.
   Byte offsets start at zero.
</t>
<t>
   Examples of <x:ref>byte-ranges-specifier</x:ref> values:
  <list style="symbols">
     <t>The first 500 bytes (byte offsets 0-499, inclusive):
<figure><artwork type="example" x:indent-with="   ">
  bytes=0-499
</artwork></figure>
    </t>
     <t>The second 500 bytes (byte offsets 500-999, inclusive):
<figure><artwork type="example" x:indent-with="   ">
  bytes=500-999
</artwork></figure>
    </t>
  </list>
</t>
<t>
   A <x:ref>byte-range-spec</x:ref> is invalid if the
   <x:ref>last-byte-pos</x:ref> value is present and less than the
   <x:ref>first-byte-pos</x:ref>.
</t>
<t>
   A client can limit the number of bytes requested without knowing the size
   of the selected representation.
   If the <x:ref>last-byte-pos</x:ref> value is absent, or if the value is
   greater than or equal to the current length of the representation data, the
   byte range is interpreted as the remainder of the representation (i.e., the
   server replaces the value of <x:ref>last-byte-pos</x:ref> with a value that
   is one less than the current length of the selected representation).
</t>
<t>
   A client can request the last N bytes of the selected representation using
   a <x:ref>suffix-byte-range-spec</x:ref>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="suffix-byte-range-spec"/><iref primary="true" item="Grammar" subitem="suffix-length"/>
  <x:ref>suffix-byte-range-spec</x:ref> = "-" <x:ref>suffix-length</x:ref>
  <x:ref>suffix-length</x:ref> = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   If the selected representation is shorter than the specified
   <x:ref>suffix-length</x:ref>, the entire representation is used.
</t>
<t>   
   Additional examples, assuming a representation of length 10000:
  <list style="symbols">
     <t>The final 500 bytes (byte offsets 9500-9999, inclusive):
<figure><artwork type="example" x:indent-with="   ">
  bytes=-500
</artwork></figure>
    Or:
<figure><artwork type="example" x:indent-with="   ">
  bytes=9500-
</artwork></figure>
    </t>
     <t>The first and last bytes only (bytes 0 and 9999):
<figure><artwork type="example" x:indent-with="   ">
  bytes=0-0,-1
</artwork></figure>
     </t>
     <t>Other valid (but not canonical) specifications of the second 500
        bytes (byte offsets 500-999, inclusive):
<figure><artwork type="example" x:indent-with="   ">
  bytes=500-600,601-999
  bytes=500-700,601-999
</artwork></figure>
     </t>
  </list>
</t>
<t>
   If a valid <x:ref>byte-range-set</x:ref> includes at least one
   <x:ref>byte-range-spec</x:ref> with a <x:ref>first-byte-pos</x:ref> that is
   less than the current length of the representation, or at least one
   <x:ref>suffix-byte-range-spec</x:ref> with a non-zero
   <x:ref>suffix-length</x:ref>, then the <x:ref>byte-range-set</x:ref> is
   satisfiable. Otherwise, the <x:ref>byte-range-set</x:ref> is unsatisfiable.
</t>
<t>
   In the byte-range syntax, <x:ref>first-byte-pos</x:ref>,
   <x:ref>last-byte-pos</x:ref>, and <x:ref>suffix-length</x:ref> are
   expressed as decimal number of octets. Since there is no predefined limit
   to the length of a payload, recipients &MUST; anticipate potentially
   large decimal numerals and prevent parsing errors due to integer conversion
   overflows.
</t>
</section>

<section title="Other Range Units" anchor="range.units.other">
  <x:anchor-alias value="other-range-unit"/>
<t>
  Range units are intended to be extensible.  New range units ought to be
  registered with IANA, as defined in <xref target="range.unit.registry"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="other-range-unit"/>
  <x:ref>other-range-unit</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
</section>

<section title="Accept-Ranges" anchor="header.accept-ranges">
  <iref primary="true" item="Accept-Ranges header field" x:for-anchor=""/>
  <x:anchor-alias value="Accept-Ranges"/>
  <x:anchor-alias value="acceptable-ranges"/>
<t>
   The "Accept-Ranges" header field allows a server to indicate that it
   supports range requests for the target resource.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Ranges"/><iref primary="true" item="Grammar" subitem="acceptable-ranges"/>
  <x:ref>Accept-Ranges</x:ref>     = <x:ref>acceptable-ranges</x:ref>
  <x:ref>acceptable-ranges</x:ref> = 1#<x:ref>range-unit</x:ref> / "none"
</artwork></figure>
<t>
   An origin server that supports byte-range requests for a given target
   resource &MAY; send
</t>
<figure><artwork type="example">
  Accept-Ranges: bytes
</artwork></figure>
<t>
   to indicate what range units are supported. A client &MAY; generate range
   requests without having received this header field for the resource
   involved. Range units are defined in <xref target="range.units"/>.
</t>
<t>
   A server that does not support any kind of range request for the target
   resource &MAY; send
</t>
<figure><artwork type="example">
  Accept-Ranges: none
</artwork></figure>
<t>
   to advise the client not to attempt a range request.
</t>
</section>
</section>


<section title="Range Requests" anchor="range.requests">
<section title="Range" anchor="header.range">
  <iref primary="true" item="Range header field" x:for-anchor=""/>
  <x:anchor-alias value="Range"/>
  <x:anchor-alias value="other-ranges-specifier"/>
  <x:anchor-alias value="other-range-set"/>
<t>
   The "Range" header field on a GET request modifies the method semantics to
   request transfer of only one or more subranges of the selected
   representation data, rather than the entire selected representation data.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Range"/>
  <x:ref>Range</x:ref> = <x:ref>byte-ranges-specifier</x:ref> / <x:ref>other-ranges-specifier</x:ref>
  <x:ref>other-ranges-specifier</x:ref> = <x:ref>other-range-unit</x:ref> "=" <x:ref>other-range-set</x:ref>
  <x:ref>other-range-set</x:ref> = 1*<x:ref>VCHAR</x:ref>
</artwork></figure>
<t>
   A server &MAY; ignore the Range header field. However, origin servers and
   intermediate caches ought to support byte ranges when possible, since Range
   supports efficient recovery from partially failed transfers and partial
   retrieval of large representations. A server &MUST; ignore a Range header
   field received with a request method other than GET.
</t>
<t>
   An origin server &MUST; ignore a Range header field that contains a range
   unit it does not understand. A proxy &MAY; discard a Range header
   field that contains a range unit it does not understand.
</t>
<t>
   A server that supports range requests &MAY; ignore or reject a
   <x:ref>Range</x:ref> header field that consists of more than two
   overlapping ranges, or a set of many small ranges that are not listed
   in ascending order, since both are indications of either a broken client or
   a deliberate denial-of-service attack (<xref target="overlapping.ranges"/>).
   A client &SHOULD-NOT; request multiple ranges that are inherently less
   efficient to process and transfer than a single range that encompasses the
   same data.
</t>
<t>
   A client that is requesting multiple ranges &SHOULD; list those ranges in
   ascending order (the order in which they would typically be received in a
   complete representation) unless there is a specific need to request a later
   part earlier. For example, a user agent processing a large representation
   with an internal catalog of parts might need to request later parts first,
   particularly if the representation consists of pages stored in reverse
   order and the user agent wishes to transfer one page at a time.
</t>
<t>
   The Range header field is evaluated after evaluating the precondition header
   fields defined in <xref target="RFC7232"/>, and only if the result in absence
   of the Range header field would be a <x:ref>200 (OK)</x:ref> response. In
   other words, Range is ignored when a conditional GET would result in a
   <x:ref>304 (Not Modified)</x:ref> response.
</t>
<t>
   The If-Range header field (<xref target="header.if-range"/>) can be used as
   a precondition to applying the Range header field.
</t>
<t>
   If all of the preconditions are true, the server supports the Range header
   field for the target resource, and the specified range(s) are valid and
   satisfiable (as defined in <xref target="byte.ranges"/>), the
   server &SHOULD; send a <x:ref>206 (Partial Content)</x:ref> response with a
   payload containing one or more partial representations that correspond to
   the satisfiable ranges requested, as defined in
   <xref target="range.response"/>.
</t>
<t>
   If all of the preconditions are true, the server supports the Range header
   field for the target resource, and the specified range(s) are invalid or
   unsatisfiable, the server &SHOULD; send a
   <x:ref>416 (Range Not Satisfiable)</x:ref> response.
</t>
</section>

<section title="If-Range" anchor="header.if-range">
  <iref primary="true" item="If-Range header field" x:for-anchor=""/>
  <x:anchor-alias value="If-Range"/>
<t>
   If a client has a partial copy of a representation and wishes
   to have an up-to-date copy of the entire representation, it could use the
   <x:ref>Range</x:ref> header field with a conditional GET (using
   either or both of <x:ref>If-Unmodified-Since</x:ref> and
   <x:ref>If-Match</x:ref>.) However, if the precondition fails because the
   representation has been modified, the client would then have to make a
   second request to obtain the entire current representation.
</t>
<t>
   The "If-Range" header field allows a client to "short-circuit" the second
   request. Informally, its meaning is as follows: if the representation is unchanged,
   send me the part(s) that I am requesting in Range; otherwise, send me the
   entire representation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Range"/>
  <x:ref>If-Range</x:ref> = <x:ref>entity-tag</x:ref> / <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   A client &MUST-NOT; generate an If-Range header field in a request that
   does not contain a <x:ref>Range</x:ref> header field.
   A server &MUST; ignore an If-Range header field received in a request that
   does not contain a <x:ref>Range</x:ref> header field.
   An origin server &MUST; ignore an If-Range header field received in a
   request for a target resource that does not support Range requests.
</t>
<t>
   A client &MUST-NOT; generate an If-Range header field containing an
   entity-tag that is marked as weak.
   A client &MUST-NOT; generate an If-Range header field containing an
   <x:ref>HTTP-date</x:ref> unless the client has no entity-tag for
   the corresponding representation and the date is a strong validator
   in the sense defined by &lastmod-comparison;.
</t>
<t>
   A server that evaluates an If-Range precondition &MUST; use the strong
   comparison function when comparing entity-tags (&entity-tag-comparison;)
   and &MUST; evaluate the condition as false if an <x:ref>HTTP-date</x:ref>
   validator is provided that is not a strong validator in the sense defined
   by &lastmod-comparison;.
   A valid <x:ref>entity-tag</x:ref> can be distinguished from a valid
   <x:ref>HTTP-date</x:ref> by examining the first two characters for a
   DQUOTE.
</t>
<t>
   If the validator given in the If-Range header field matches the current
   validator for the selected representation of the target resource, then
   the server &SHOULD; process the <x:ref>Range</x:ref> header field as
   requested. If the validator does not match, the server &MUST; ignore the
   <x:ref>Range</x:ref> header field. Note that this comparison by exact
   match, including when the validator is an <x:ref>HTTP-date</x:ref>, differs
   from the "earlier than or equal to" comparison used when evaluating an
   <x:ref>If-Unmodified-Since</x:ref> conditional.
</t>
</section>
</section>


<section title="Responses to a Range Request" anchor="range.response">

<section title="206 Partial Content" anchor="status.206">
  <iref primary="true" item="206 Partial Content (status code)" x:for-anchor=""/>
  <x:anchor-alias value="206"/>
  <x:anchor-alias value="206 (Partial Content)"/>
<t>
   The <x:dfn>206 (Partial Content)</x:dfn> status code indicates that the
   server is successfully fulfilling a range request for the target resource
   by transferring one or more parts of the selected representation that
   correspond to the satisfiable ranges found in the request's
   <x:ref>Range</x:ref> header field (<xref target="header.range"/>).
</t>
<t>
   If a single part is being transferred, the server generating the 206
   response &MUST; generate a <x:ref>Content-Range</x:ref> header field,
   describing what range of the selected representation is enclosed, and a
   payload consisting of the range. For example:
</t>
<figure><artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

... 26012 bytes of partial image data ...
</artwork></figure>
<t>
   If multiple parts are being transferred, the server generating the 206
   response &MUST; generate a "multipart/byteranges" payload, as defined
   in <xref target="internet.media.type.multipart.byteranges"/>, and a
   <x:ref>Content-Type</x:ref> header field containing the
   multipart/byteranges media type and its required boundary parameter.
   To avoid confusion with single-part responses, a server &MUST-NOT; generate
   a <x:ref>Content-Range</x:ref> header field in the HTTP header section of a
   multiple part response (this field will be sent in each part instead).
</t>
<t>
   Within the header area of each body part in the multipart payload, the
   server &MUST; generate a <x:ref>Content-Range</x:ref> header field
   corresponding to the range being enclosed in that body part.
   If the selected representation would have had a <x:ref>Content-Type</x:ref>
   header field in a <x:ref>200 (OK)</x:ref> response, the server &SHOULD;
   generate that same <x:ref>Content-Type</x:ref> field in the header area of
   each body part. For example:
</t>
<figure><artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Length: 1741
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...the first range...
--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...the second range
--THIS_STRING_SEPARATES--
</artwork></figure>
<t>
   When multiple ranges are requested, a server &MAY; coalesce any of the
   ranges that overlap, or that are separated by a gap that is smaller than the
   overhead of sending multiple parts, regardless of the order in which the
   corresponding byte-range-spec appeared in the received <x:ref>Range</x:ref>
   header field. Since the typical overhead between parts of a
   multipart/byteranges payload is around 80 bytes, depending on the selected
   representation's media type and the chosen boundary parameter length, it
   can be less efficient to transfer many small disjoint parts than it is to
   transfer the entire selected representation.
</t>
<t>
   A server &MUST-NOT; generate a multipart response to a request for a single
   range, since a client that does not request multiple parts might not
   support multipart responses. However, a server &MAY; generate a
   multipart/byteranges payload with only a single body part if multiple
   ranges were requested and only one range was found to be satisfiable or
   only one range remained after coalescing.
   A client that cannot process a multipart/byteranges response &MUST-NOT; 
   generate a request that asks for multiple ranges.
</t>
<t>
   When a multipart response payload is generated, the server &SHOULD; send
   the parts in the same order that the corresponding byte-range-spec appeared
   in the received <x:ref>Range</x:ref> header field, excluding those ranges
   that were deemed unsatisfiable or that were coalesced into other ranges.
   A client that receives a multipart response &MUST; inspect the
   <x:ref>Content-Range</x:ref> header field present in each body part in
   order to determine which range is contained in that body part; a client
   cannot rely on receiving the same ranges that it requested, nor the same
   order that it requested.
</t>
<t>
   When a 206 response is generated, the server &MUST; generate the following
   header fields, in addition to those required above, if the field would
   have been sent in a <x:ref>200 (OK)</x:ref> response to the same request:
   <x:ref>Date</x:ref>, <x:ref>Cache-Control</x:ref>, <x:ref>ETag</x:ref>,
   <x:ref>Expires</x:ref>, <x:ref>Content-Location</x:ref>, and
   <x:ref>Vary</x:ref>.
</t>
<t>
   If a 206 is generated in response to a request with an <x:ref>If-Range</x:ref>
   header field, the sender &SHOULD-NOT; generate other representation header
   fields beyond those required above, because the client is understood to
   already have a prior response containing those header fields.
   Otherwise, the sender &MUST; generate all of the representation header
   fields that would have been sent in a <x:ref>200 (OK)</x:ref> response
   to the same request.
</t>
<t>
   A 206 response is cacheable by default; i.e., unless otherwise indicated by
   explicit cache controls (see &p6-heuristic;).
</t>
</section>

<section title="Content-Range" anchor="header.content-range">
  <iref primary="true" item="Content-Range header field" x:for-anchor=""/>
  <x:anchor-alias value="Content-Range"/>
  <x:anchor-alias value="byte-content-range"/>
  <x:anchor-alias value="byte-range-resp"/>
  <x:anchor-alias value="byte-range"/>
  <x:anchor-alias value="unsatisfied-range"/>
  <x:anchor-alias value="complete-length"/>
  <x:anchor-alias value="other-content-range"/>
  <x:anchor-alias value="other-range-resp"/>
<t>
   The "Content-Range" header field is sent in a single part
   <x:ref>206 (Partial Content)</x:ref> response to indicate the partial range
   of the selected representation enclosed as the message payload, sent in
   each part of a multipart 206 response to indicate the range enclosed within
   each body part, and sent in <x:ref>416 (Range Not Satisfiable)</x:ref>
   responses to provide information about the selected representation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Range"/><iref primary="true" item="Grammar" subitem="byte-content-range"/><iref primary="true" item="Grammar" subitem="byte-range-resp"/><iref primary="true" item="Grammar" subitem="byte-range"/><iref primary="true" item="Grammar" subitem="unsatisfied-range"/><iref primary="true" item="Grammar" subitem="other-content-range"/><iref primary="true" item="Grammar" subitem="other-range-resp"/><iref primary="true" item="Grammar" subitem="complete-length"/>
  <x:ref>Content-Range</x:ref>       = <x:ref>byte-content-range</x:ref>
                      / <x:ref>other-content-range</x:ref>
                          
  <x:ref>byte-content-range</x:ref>  = <x:ref>bytes-unit</x:ref> <x:ref>SP</x:ref>
                        ( <x:ref>byte-range-resp</x:ref> / <x:ref>unsatisfied-range</x:ref> )

  <x:ref>byte-range-resp</x:ref>     = <x:ref>byte-range</x:ref> "/" ( <x:ref>complete-length</x:ref> / "*" )
  <x:ref>byte-range</x:ref>          = <x:ref>first-byte-pos</x:ref> "-" <x:ref>last-byte-pos</x:ref>
  <x:ref>unsatisfied-range</x:ref>   = "*/" <x:ref>complete-length</x:ref>
                          
  <x:ref>complete-length</x:ref>     = 1*<x:ref>DIGIT</x:ref>
  
  <x:ref>other-content-range</x:ref> = <x:ref>other-range-unit</x:ref> <x:ref>SP</x:ref> <x:ref>other-range-resp</x:ref>
  <x:ref>other-range-resp</x:ref>    = *<x:ref>CHAR</x:ref>
</artwork></figure>
<t>   
   If a <x:ref>206 (Partial Content)</x:ref> response contains a
   <x:ref>Content-Range</x:ref> header field with a <x:ref>range unit</x:ref>
   (<xref target="range.units"/>) that the recipient does not understand, the
   recipient &MUST-NOT; attempt to recombine it with a stored representation.
   A proxy that receives such a message &SHOULD; forward it downstream.
</t>
<t>
   For byte ranges, a sender &SHOULD; indicate the complete length of the
   representation from which the range has been extracted, unless the complete
   length is unknown or difficult to determine. An asterisk character ("*") in
   place of the complete-length indicates that the representation length was
   unknown when the header field was generated.
</t>
<t>
   The following example illustrates when the complete length of the selected
   representation is known by the sender to be 1234 bytes:
</t>
<figure><artwork type="example">
  Content-Range: bytes 42-1233/1234
</artwork></figure>
<t>
   and this second example illustrates when the complete length is unknown:
</t>
<figure><artwork type="example">
  Content-Range: bytes 42-1233/*
</artwork></figure>
<t>
   A Content-Range field value is invalid if it contains a
   <x:ref>byte-range-resp</x:ref> that has a <x:ref>last-byte-pos</x:ref>
   value less than its <x:ref>first-byte-pos</x:ref> value, or a
   <x:ref>complete-length</x:ref> value less than or equal to its
   <x:ref>last-byte-pos</x:ref> value. The recipient of an invalid
   <x:ref>Content-Range</x:ref> &MUST-NOT; attempt to recombine the received
   content with a stored representation.
</t>
<t>
   A server generating a <x:ref>416 (Range Not Satisfiable)</x:ref> response
   to a byte-range request &SHOULD; send a Content-Range header field with an
   <x:ref>unsatisfied-range</x:ref> value, as in the following example:
</t>
<figure><artwork type="example">
  Content-Range: bytes */1234
</artwork></figure>
<t>
   The complete-length in a 416 response indicates the current length of the
   selected representation.
</t>
<t>
   The Content-Range header field has no meaning for status codes that do
   not explicitly describe its semantic. For this specification, only the
   <x:ref>206 (Partial Content)</x:ref> and
   <x:ref>416 (Range Not Satisfiable)</x:ref> status codes describe a meaning
   for Content-Range.
</t>
<t>
   The following are examples of Content-Range values in which the
   selected representation contains a total of 1234 bytes:
   <list style="symbols">
      <t>
        The first 500 bytes:
<figure><artwork type="example" x:indent-with="   ">
  Content-Range: bytes 0-499/1234
</artwork></figure>
      </t>    
      <t>
        The second 500 bytes:
<figure><artwork type="example" x:indent-with="   ">
  Content-Range: bytes 500-999/1234
</artwork></figure>
      </t>    
      <t>
        All except for the first 500 bytes:
<figure><artwork type="example" x:indent-with="   ">
  Content-Range: bytes 500-1233/1234
</artwork></figure>
      </t>    
      <t>
        The last 500 bytes:
<figure><artwork type="example" x:indent-with="   ">
  Content-Range: bytes 734-1233/1234
</artwork></figure>
      </t>    
   </list>
</t>
</section>

<section title="Combining Ranges" anchor="combining.byte.ranges">
<t>
   A response might transfer only a subrange of a representation if the
   connection closed prematurely or if the request used one or more Range
   specifications.  After several such transfers, a client might have
   received several ranges of the same representation.  These ranges can only
   be safely combined if they all have in common the same strong validator
   (&weak-and-strong-validators;).
</t>
<t>
   A client that has received multiple partial responses to GET requests on a
   target resource &MAY; combine those responses into a larger continuous
   range if they share the same strong validator.
</t>
<t>
   If the most recent response is an incomplete <x:ref>200 (OK)</x:ref>
   response, then the header fields of that response are used for any
   combined response and replace those of the matching stored responses.
</t>
<t>
   If the most recent response is a <x:ref>206 (Partial Content)</x:ref>
   response and at least one of the matching stored responses is a
   <x:ref>200 (OK)</x:ref>, then the combined response header fields consist
   of the most recent 200 response's header fields. If all of the matching
   stored responses are 206 responses, then the stored response with the most
   recent header fields is used as the source of header fields for the
   combined response, except that the client &MUST; use other header fields
   provided in the new response, aside from <x:ref>Content-Range</x:ref>, to
   replace all instances of the corresponding header fields in the stored
   response.
</t>
<t>
   The combined response message body consists of the union of partial
   content ranges in the new response and each of the selected responses.
   If the union consists of the entire range of the representation, then the
   client &MUST; process the combined response as if it were a complete
   <x:ref>200 (OK)</x:ref> response, including a <x:ref>Content-Length</x:ref>
   header field that reflects the complete length.
   Otherwise, the client &MUST; process the set of continuous ranges as one of
   the following:
   an incomplete <x:ref>200 (OK)</x:ref> response if the combined response is
   a prefix of the representation,
   a single <x:ref>206 (Partial Content)</x:ref> response containing a
   multipart/byteranges body, or
   multiple <x:ref>206 (Partial Content)</x:ref> responses, each with one
   continuous range that is indicated by a <x:ref>Content-Range</x:ref> header
   field.
</t>
</section>

<section title="416 Range Not Satisfiable" anchor="status.416">
  <iref primary="true" item="416 Range Not Satisfiable (status code)" x:for-anchor=""/>
  <x:anchor-alias value="416 (Range Not Satisfiable)"/>
<t>
   The <x:dfn>416 (Range Not Satisfiable)</x:dfn> status code indicates that
   none of the ranges in the request's <x:ref>Range</x:ref> header field
   (<xref target="header.range"/>) overlap the current extent of the selected
   resource or that the set of ranges requested has been rejected due to
   invalid ranges or an excessive request of small or overlapping ranges.
</t>
<t>
   For byte ranges, failing to overlap the current extent means that the
   <x:ref>first-byte-pos</x:ref> of all of the <x:ref>byte-range-spec</x:ref>
   values were greater than the current length of the selected representation.
   When this status code is generated in response to a byte-range request, the
   sender &SHOULD; generate a <x:ref>Content-Range</x:ref> header field
   specifying the current length of the selected representation
   (<xref target="header.content-range"/>).
</t>
<figure>
<preamble>For example:</preamble>
<artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 416 Range Not Satisfiable
Date: Fri, 20 Jan 2012 15:41:54 GMT
Content-Range: bytes */47022
</artwork></figure>
<x:note>
  <t>
    &Note; Because servers are free to ignore <x:ref>Range</x:ref>, many
    implementations will simply respond with the entire selected representation
    in a <x:ref>200 (OK)</x:ref> response. That is partly because
    most clients are prepared to receive a <x:ref>200 (OK)</x:ref> to
    complete the task (albeit less efficiently) and partly because clients
    might not stop making an invalid partial request until they have received
    a complete representation. Thus, clients cannot depend on receiving a
    <x:ref>416 (Range Not Satisfiable)</x:ref> response even when it is most
    appropriate.
  </t>
</x:note>
</section>
</section>

<section title="IANA Considerations" anchor="IANA.considerations">

<section title="Range Unit Registry" anchor="range.unit.registry">
<t>
   The "HTTP Range Unit Registry" defines the namespace for the range
   unit names and refers to their corresponding specifications.
   The registry has been created and is now maintained at
   <eref target="http://www.iana.org/assignments/http-parameters"/>.
</t>

<section title="Procedure" anchor="range.unit.registry.procedure">
<t>
   Registration of an HTTP Range Unit &MUST; include the following fields:
   <list style="symbols">
     <t>Name</t>
     <t>Description</t>
     <t>Pointer to specification text</t>
   </list>
</t>
<t>
  Values to be added to this namespace require IETF Review
  (see <xref target="RFC5226" x:fmt="," x:sec="4.1"/>).
</t>
</section>

<section title="Registrations" anchor="range.unit.registration">
<t>
   The initial range unit registry contains the registrations
   below:
</t>
<texttable align="left" suppress-title="true" anchor="iana.range.units.table">
   <ttcol>Range Unit Name</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>

   <c>bytes</c>
   <c>a range of octets</c>
   <c><xref target="byte.ranges"/></c>

   <c>none</c>
   <c>reserved as keyword, indicating no ranges are supported</c>
   <c><xref target="header.accept-ranges"/></c>
</texttable>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>
</section>

<section title="Status Code Registration" anchor="status.code.registration">
<t>
   The "Hypertext Transfer Protocol (HTTP) Status Code Registry" located at <eref target="http://www.iana.org/assignments/http-status-codes"/>
   has been updated to include the registrations below:
</t>
<?BEGININC p5-range.iana-status-codes ?>
<!--AUTOGENERATED FROM extract-status-code-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.status.code.registration.table">
   <ttcol>Value</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>206</c>
   <c>Partial Content</c>
   <c>
      <xref target="status.206"/>
   </c>
   <c>416</c>
   <c>Range Not Satisfiable</c>
   <c>
      <xref target="status.416"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p5-range.iana-status-codes ?>
</section>

<section title="Header Field Registration" anchor="header.field.registration">
<t>
   HTTP header fields are registered within the "Message Headers" registry
   maintained at
   <eref target="http://www.iana.org/assignments/message-headers/"/>.
</t>
<t>
   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the 
   permanent registrations below (see <xref target="BCP90"/>):
</t>
<?BEGININC p5-range.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Accept-Ranges</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.accept-ranges"/>
   </c>
   <c>Content-Range</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-range"/>
   </c>
   <c>If-Range</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-range"/>
   </c>
   <c>Range</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.range"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p5-range.iana-headers ?>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>

<section title="Internet Media Type Registration" anchor="internet.media.type.http">
<t>
   IANA maintains the registry of Internet media types <xref target="BCP13"/> at
   <eref target="http://www.iana.org/assignments/media-types"/>.
</t>
<t>
   This document serves as the specification for the Internet media type
   "multipart/byteranges". The following has been registered with
   IANA.
</t>
<section title="Internet Media Type multipart/byteranges" anchor="internet.media.type.multipart.byteranges.reg">
<iref item="Media Type" subitem="multipart/byteranges" primary="true"/>
<iref item="multipart/byteranges Media Type" primary="true"/>
<t>
  <list style="hanging" x:indent="12em">
    <t hangText="Type name:">
      multipart
    </t>
    <t hangText="Subtype name:">
      byteranges
    </t>
    <t hangText="Required parameters:">
      boundary
    </t>
    <t hangText="Optional parameters:">
      N/A
    </t>
    <t hangText="Encoding considerations:">
      only "7bit", "8bit", or "binary" are permitted
    </t>
    <t hangText="Security considerations:">
      see <xref target="security.considerations"/>
    </t>
    <t hangText="Interoperability considerations:">
      N/A
    </t>
    <t hangText="Published specification:">
      This specification (see <xref target="internet.media.type.multipart.byteranges"/>).
    </t>
    <t hangText="Applications that use this media type:">
      HTTP components supporting multiple ranges in a single request.
    </t>
    <t hangText="Fragment identifier considerations:">
      N/A
    </t>
    <t hangText="Additional information:">
      <list style="hanging">
        <t hangText="Deprecated alias names for this type:">N/A</t>
        <t hangText="Magic number(s):">N/A</t>
        <t hangText="File extension(s):">N/A</t>
        <t hangText="Macintosh file type code(s):">N/A</t>
      </list>
    </t>
    <t hangText="Person and email address to contact for further information:">
      See Authors' Addresses section.
    </t>
    <t hangText="Intended usage:">
      COMMON
    </t>
    <t hangText="Restrictions on usage:">
      N/A
    </t>
    <t hangText="Author:">
      See Authors' Addresses section.
    </t>
    <t hangText="Change controller:">
      IESG
    </t>
  </list>
</t>
</section>
</section>

</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   This section is meant to inform developers, information providers, and
   users of known security concerns specific to the HTTP range
   request mechanisms. More general security considerations are addressed
   in HTTP messaging &messaging; and semantics &semantics;.
</t>

<section title="Denial-of-Service Attacks Using Range" anchor="overlapping.ranges">
<t>
   Unconstrained multiple range requests are susceptible to denial-of-service
   attacks because the effort required to request many overlapping ranges of
   the same data is tiny compared to the time, memory, and bandwidth consumed
   by attempting to serve the requested data in many parts.
   Servers ought to ignore, coalesce, or reject egregious range requests, such
   as requests for more than two overlapping ranges or for many small ranges
   in a single set, particularly when the ranges are requested out of order
   for no apparent reason. Multipart range requests are not designed to
   support random access.
</t>
</section>
</section>

<section title="Acknowledgments" anchor="acks">
<t>
  See &acks;.
</t>
</section>
</middle>
<back>

<references title="Normative References">

<reference anchor="RFC7230">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7230"/>
  <x:source href="rfc7230.xml" basename="rfc7230">
    <x:defines>Content-Length</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7231">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7231"/>
  <x:source href="rfc7231.xml" basename="rfc7231">
    <x:defines>200 (OK)</x:defines>
    <x:defines>410 (Gone)</x:defines>
    <x:defines>Content-Location</x:defines>
    <x:defines>Content-Type</x:defines>
    <x:defines>Date</x:defines>
    <x:defines>Location</x:defines>
    <x:defines>Vary</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7232">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7232"/>
  <x:source href="rfc7232.xml" basename="rfc7232">
    <x:defines>304 (Not Modified)</x:defines>
    <x:defines>ETag</x:defines>
    <x:defines>If-Match</x:defines>
    <x:defines>If-Modified-Since</x:defines>
    <x:defines>If-None-Match</x:defines>
    <x:defines>If-Unmodified-Since</x:defines>
    <x:defines>Last-Modified</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7234">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
      <organization>Akamai</organization>
      <address><email>mnot@mnot.net</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7234"/>
  <x:source href="rfc7234.xml" basename="rfc7234">
    <x:defines>Cache-Control</x:defines>
    <x:defines>Expires</x:defines>
  </x:source>
</reference>

<reference anchor="RFC2046">
  <front>
    <title abbrev="Media Types">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2046"/>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
        <email>dcrocker@bbiw.net</email>
      </address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
        <email>paul.overell@thus.net</email>
      </address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

</references>

<references title="Informative References">

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor='BCP90'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

<reference anchor="BCP13">
  <front>
    <title>Media Type Specifications and Registration Procedures</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Oracle</organization>
      <address>
        <email>ned+ietf@mrochek.com</email>
      </address>
    </author>
    <author initials="J." surname="Klensin" fullname="John C. Klensin">
      <address>
        <email>john+ietf@jck.com</email>
      </address>
    </author>
    <author initials="T." surname="Hansen" fullname="Tony Hansen">
      <organization>AT&amp;T Laboratories</organization>
      <address>
        <email>tony+mtsuffix@maillennium.att.com</email>
      </address>
    </author>
    <date year="2013" month="January"/>
  </front>
  <seriesInfo name="BCP" value="13"/>
  <seriesInfo name="RFC" value="6838"/>
</reference>

<reference anchor='RFC5226'>
  <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author initials='T.' surname='Narten' fullname='T. Narten'>
      <organization>IBM</organization>
      <address><email>narten@us.ibm.com</email></address>
    </author>
    <author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
      <organization>Google</organization>
      <address><email>Harald@Alvestrand.no</email></address>
    </author>
    <date year='2008' month='May' />
  </front>
  <seriesInfo name='BCP' value='26' />
  <seriesInfo name='RFC' value='5226' />
</reference>

</references>

<section title="Internet Media Type multipart/byteranges" anchor="internet.media.type.multipart.byteranges">
<iref item="Media Type" subitem="multipart/byteranges" primary="true"/>
<iref item="multipart/byteranges Media Type" primary="true"/>
<t>
   When a <x:ref>206 (Partial Content)</x:ref> response message includes the
   content of multiple ranges, they are transmitted as body parts in a
   multipart message body (<xref target="RFC2046" x:fmt="," x:sec="5.1"/>)
   with the media type of "multipart/byteranges".
</t>
<t>
   The multipart/byteranges media type includes one or more body parts, each
   with its own <x:ref>Content-Type</x:ref> and <x:ref>Content-Range</x:ref>
   fields. The required boundary parameter specifies the boundary string used
   to separate each body part.
</t>
<t>
  Implementation Notes:
  <list style="numbers">
      <t>Additional CRLFs might precede the first boundary string in the body.</t>

      <t>Although <xref target="RFC2046"/> permits the boundary string to be
         quoted, some existing implementations handle a quoted boundary
         string incorrectly.</t>

      <t>A number of clients and servers were coded to an early draft
         of the byteranges specification that used a media type of
         multipart/x-byteranges<iref item="multipart/x-byteranges Media Type"/><iref item="Media Type" subitem="multipart/x-byteranges"/>,
         which is almost (but not quite) compatible with this type.</t>
  </list>
</t>
<t>
   Despite the name, the "multipart/byteranges" media type is not limited to
   byte ranges. The following example uses an "exampleunit" range unit:
</t>
<figure><artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 206 Partial Content
Date: Tue, 14 Nov 1995 06:25:24 GMT
Last-Modified: Tue, 14 July 04:58:08 GMT
Content-Length: 2331785
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 1.2-4.3/25

...the first range...
--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 11.2-14.3/25

...the second range
--THIS_STRING_SEPARATES--
</artwork>
</figure>
</section>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
  Servers are given more leeway in how they respond to a range request,
  in order to mitigate abuse by malicious (or just greedy) clients.
  (<xref target="header.range"/>)
</t>
<t>
  A weak validator cannot be used in a <x:ref>206</x:ref> response.
  (<xref target="status.206"/>)
</t>
<t>
  The Content-Range header field only has meaning when the status code
  explicitly defines its use.
  (<xref target="header.content-range" />)
</t>
<t>
  This specification introduces a Range Unit Registry.
  (<xref target="range.unit.registry"/>)
</t>
<t>
  multipart/byteranges can consist of a single part.
  (<xref target="internet.media.type.multipart.byteranges"/>)
</t>
</section>

<section title="Imported ABNF" anchor="imported.abnf">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CHAR"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="SP"/>
  <x:anchor-alias value="VCHAR"/>
  <x:anchor-alias value="token"/>
  <x:anchor-alias value="OWS"/>
  <x:anchor-alias value="HTTP-date"/>
  <x:anchor-alias value="entity-tag"/>
<t>
  The following core rules are included by
  reference, as defined in <xref target="RFC5234" x:fmt="of" x:sec="B.1"/>:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space), and
  VCHAR (any visible US-ASCII character).
</t>
<t>
  Note that all rules derived from <x:ref>token</x:ref> are to
  be compared case-insensitively, like <x:ref>range-unit</x:ref> and
  <x:ref>acceptable-ranges</x:ref>.
</t>
<t>
  The rules below are defined in <xref target="RFC7230"/>:
</t>
<figure><artwork type="abnf2616">
  <x:ref>OWS</x:ref>        = &lt;OWS, see &whitespace;&gt;
  <x:ref>token</x:ref>      = &lt;token, see &field-components;&gt;
</artwork></figure>
<t>
  The rules below are defined in other parts: 
</t>
<figure><artwork type="abnf2616">
  <x:ref>HTTP-date</x:ref>  = &lt;HTTP-date, see &http-date;&gt;
  <x:ref>entity-tag</x:ref> = &lt;entity-tag, see &entity-tags;&gt;
</artwork></figure>
</section> 

<?BEGININC p5-range.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<t>
  In the collected ABNF below, list rules are expanded as per <xref target="RFC7230" x:rel="#notation"/>.
</t><figure>
<artwork type="abnf" name="p5-range.parsed-abnf">
<x:ref>Accept-Ranges</x:ref> = acceptable-ranges

<x:ref>Content-Range</x:ref> = byte-content-range / other-content-range

<x:ref>HTTP-date</x:ref> = &lt;HTTP-date, see [RFC7231], Section 7.1.1.1&gt;

<x:ref>If-Range</x:ref> = entity-tag / HTTP-date

<x:ref>OWS</x:ref> = &lt;OWS, see [RFC7230], Section 3.2.3&gt;

<x:ref>Range</x:ref> = byte-ranges-specifier / other-ranges-specifier

<x:ref>acceptable-ranges</x:ref> = ( *( "," OWS ) range-unit *( OWS "," [ OWS
 range-unit ] ) ) / "none"

<x:ref>byte-content-range</x:ref> = bytes-unit SP ( byte-range-resp /
 unsatisfied-range )
<x:ref>byte-range</x:ref> = first-byte-pos "-" last-byte-pos
<x:ref>byte-range-resp</x:ref> = byte-range "/" ( complete-length / "*" )
<x:ref>byte-range-set</x:ref> = *( "," OWS ) ( byte-range-spec /
 suffix-byte-range-spec ) *( OWS "," [ OWS ( byte-range-spec /
 suffix-byte-range-spec ) ] )
<x:ref>byte-range-spec</x:ref> = first-byte-pos "-" [ last-byte-pos ]
<x:ref>byte-ranges-specifier</x:ref> = bytes-unit "=" byte-range-set
<x:ref>bytes-unit</x:ref> = "bytes"

<x:ref>complete-length</x:ref> = 1*DIGIT

<x:ref>entity-tag</x:ref> = &lt;entity-tag, see [RFC7232], Section 2.3&gt;

<x:ref>first-byte-pos</x:ref> = 1*DIGIT

<x:ref>last-byte-pos</x:ref> = 1*DIGIT

<x:ref>other-content-range</x:ref> = other-range-unit SP other-range-resp
<x:ref>other-range-resp</x:ref> = *CHAR
<x:ref>other-range-set</x:ref> = 1*VCHAR
<x:ref>other-range-unit</x:ref> = token
<x:ref>other-ranges-specifier</x:ref> = other-range-unit "=" other-range-set

<x:ref>range-unit</x:ref> = bytes-unit / other-range-unit

<x:ref>suffix-byte-range-spec</x:ref> = "-" suffix-length
<x:ref>suffix-length</x:ref> = 1*DIGIT

<x:ref>token</x:ref> = &lt;token, see [RFC7230], Section 3.2.6&gt;

<x:ref>unsatisfied-range</x:ref> = "*/" complete-length
</artwork>
</figure>
</section>
<?ENDINC p5-range.abnf-appendix ?>
</back>
</rfc>
