<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY mdash "&#8212;">
  <!ENTITY Note "<x:h xmlns:x='http://purl.org/net/xml2rfc/ext'>Note:</x:h>">
  <!ENTITY architecture               "<xref target='RFC7230' x:rel='#architecture' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY conformance                "<xref target='RFC7230' x:rel='#conformance' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation                   "<xref target='RFC7230' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY acks                       "<xref target='RFC7230' x:rel='#acks' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY messaging                  "<xref target='RFC7230' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY conditional                "<xref target='RFC7232' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY range                      "<xref target='RFC7233' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY caching                    "<xref target='RFC7234' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY auth                       "<xref target='RFC7235' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY content-negotiation        "<xref target='content.negotiation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY reactive-negotiation       "<xref target='reactive.negotiation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY abnf-extension             "<xref target='RFC7230' x:rel='#abnf.extension' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY whitespace                 "<xref target='RFC7230' x:rel='#whitespace' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY field-components           "<xref target='RFC7230' x:rel='#field.components' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY field-parsing              "<xref target='RFC7230' x:rel='#field.parsing' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY uri                        "<xref target='RFC7230' x:rel='#uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY effective-request-uri      "<xref target='RFC7230' x:rel='#effective.request.uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY intermediaries             "<xref target='RFC7230' x:rel='#intermediaries' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY transformations            "<xref target='RFC7230' x:rel='#message.transformations' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY chunked-encoding           "<xref target='RFC7230' x:rel='#chunked.encoding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY http-url                   "<xref target='RFC7230' x:rel='#http-url' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY http-version               "<xref target='RFC7230' x:rel='#http.version' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY request-target             "<xref target='RFC7230' x:rel='#request-target' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-accept              "<xref target='header.accept' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-accept-charset      "<xref target='header.accept-charset' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-accept-encoding     "<xref target='header.accept-encoding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-accept-language     "<xref target='header.accept-language' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-accept-ranges       "<xref target='RFC7233' x:rel='#header.accept-ranges' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-age                 "<xref target='RFC7234' x:rel='#header.age' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-authorization       "<xref target='RFC7235' x:rel='#header.authorization' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-cache-control       "<xref target='RFC7234' x:rel='#header.cache-control' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-connection          "<xref target='RFC7230' x:rel='#header.connection' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-length      "<xref target='RFC7230' x:rel='#header.content-length' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-location    "<xref target='header.content-location' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-range       "<xref target='RFC7233' x:rel='#header.content-range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-type        "<xref target='header.content-type' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-etag                "<xref target='RFC7232' x:rel='#header.etag' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-expires             "<xref target='RFC7234' x:rel='#header.expires' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-fields              "<xref target='RFC7230' x:rel='#header.fields' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-host                "<xref target='RFC7230' x:rel='#header.host' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-if-match            "<xref target='RFC7232' x:rel='#header.if-match' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-if-modified-since   "<xref target='RFC7232' x:rel='#header.if-modified-since' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-if-none-match       "<xref target='RFC7232' x:rel='#header.if-none-match' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-if-range            "<xref target='RFC7233' x:rel='#header.if-range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-if-unmodified-since "<xref target='RFC7232' x:rel='#header.if-unmodified-since' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-last-modified       "<xref target='RFC7232' x:rel='#header.last-modified' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-pragma              "<xref target='RFC7234' x:rel='#header.pragma' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-proxy-authenticate  "<xref target='RFC7235' x:rel='#header.proxy-authenticate' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-proxy-authorization "<xref target='RFC7235' x:rel='#header.proxy-authorization' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-range               "<xref target='RFC7233' x:rel='#header.range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-te                  "<xref target='RFC7230' x:rel='#header.te' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-trailer                  "<xref target='RFC7230' x:rel='#header.trailer' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-transfer-encoding   "<xref target='RFC7230' x:rel='#header.transfer-encoding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-upgrade             "<xref target='RFC7230' x:rel='#header.upgrade' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-user-agent          "<xref target='header.user-agent' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-via                 "<xref target='RFC7230' x:rel='#header.via' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-warning             "<xref target='RFC7234' x:rel='#header.warning' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-www-authenticate    "<xref target='RFC7235' x:rel='#header.www-authenticate' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY media-type                "<xref target='media.type' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY message-body               "<xref target='RFC7230' x:rel='#message.body' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY media-type-message-http    "<xref target='RFC7230' x:rel='#internet.media.type.message.http' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY persistent-tear-down       "<xref target='RFC7230' x:rel='#persistent.tear-down' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-206                 "<xref target='RFC7233' x:rel='#status.206' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-304                 "<xref target='RFC7232' x:rel='#status.304' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-401                 "<xref target='RFC7235' x:rel='#status.401' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-407                 "<xref target='RFC7235' x:rel='#status.407' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-412                 "<xref target='RFC7232' x:rel='#status.412' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-416                 "<xref target='RFC7233' x:rel='#status.416' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY p1-security-considerations "<xref target='RFC7230' x:rel='#security.considerations' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY p4-status-codes            "<xref target='RFC7232' x:rel='#status.code.definitions' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY p5-status-codes            "<xref target='RFC7233' x:rel='#range.response' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY p7-status-codes            "<xref target='RFC7235' x:rel='#status.code.definitions' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY p6-heuristic               "<xref target='RFC7234' x:rel='#heuristic.freshness' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY p6-explicit                "<xref target='RFC7234' x:rel='#calculating.freshness.lifetime' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY p6-invalid                 "<xref target='RFC7234' x:rel='#invalidation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY p6-head                    "<xref target='RFC7234' x:rel='#head.effects' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY qvalue                     "<xref target='quality.values'/>">
  <!ENTITY architecture               "<xref target='RFC7230' x:rel='#architecture' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation                   "<xref target='RFC7230' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY abnf-extension             "<xref target='RFC7230' x:rel='#abnf.extension' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY acks                       "<xref target='RFC7230' x:rel='#acks' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY whitespace                 "<xref target='RFC7230' x:rel='#whitespace' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY field-components           "<xref target='RFC7230' x:rel='#field.components' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY caching-neg-resp           "<xref target='RFC7234' x:rel='#caching.negotiated.responses' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY message-body               "<xref target='RFC7230' x:rel='#message.body' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY multipart-byteranges       "<xref target='RFC7233' x:rel='#internet.media.type.multipart.byteranges' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY evaluate-conditional       "<xref target='RFC7232' x:rel='#evaluation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY http-date                  "<xref target='http.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY uri                        "<xref target='RFC7230' x:rel='#uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY effective-request-uri      "<xref target='RFC7230' x:rel='#effective.request.uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY compression-codings        "<xref target='RFC7230' x:rel='#compression.codings' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY transfer-codings           "<xref target='RFC7230' x:rel='#transfer.codings' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY compress-coding            "<xref target='RFC7230' x:rel='#compress.coding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY deflate-coding             "<xref target='RFC7230' x:rel='#deflate.coding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY gzip-coding                "<xref target='RFC7230' x:rel='#gzip.coding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2616" updates="2817" category="std" x:maturity-level="proposed"
     ipr="pre5378Trust200902" number="7231" consensus="yes"
     xmlns:x='http://purl.org/net/xml2rfc/ext'
     xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>
<x:link rel="prev" basename="rfc7230"/>
<x:link rel="next" basename="rfc7232"/>
<!--<x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>-->
<front>

  <title abbrev="HTTP/1.1 Semantics and Content">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="June" year="2014"/>

  <area>Applications</area>
  <workgroup>HTTPbis</workgroup>

  <keyword>Hypertext Transfer Protocol</keyword>
  <keyword>HTTP</keyword>
  <keyword>HTTP semantics</keyword>
  <keyword>HTTP payload</keyword>
  <keyword>HTTP content</keyword>
  <keyword>HTTP method</keyword>
  <keyword>HTTP status code</keyword>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for
   distributed, collaborative, hypertext information systems. This document
   defines the semantics of HTTP/1.1 messages, as expressed by request
   methods, request header fields, response status codes, and response header
   fields, along with the payload of messages (metadata and body content) and
   mechanisms for content negotiation.
</t>
</abstract>
</front>

<middle>
<section title="Introduction" anchor="introduction">
<t>
   Each Hypertext Transfer Protocol (HTTP) message is either a request or a
   response. A server listens on a connection for a request, parses each
   message received, interprets the message semantics in relation to the
   identified request target, and responds to that request with one or more
   response messages. A client constructs request messages to communicate
   specific intentions, examines received responses to see if the
   intentions were carried out, and determines how to interpret the results.
   This document defines HTTP/1.1 request and response semantics in terms of
   the architecture defined in <xref target="RFC7230"/>.
</t>
<t>
   HTTP provides a uniform interface for interacting with a resource
   (<xref target="resources"/>), regardless of its type, nature, or
   implementation, via the manipulation and transfer of representations
   (<xref target="representations"/>).
</t>
<t>
   HTTP semantics include the intentions defined by each request method
   (<xref target="methods"/>), extensions to those semantics that might be
   described in request header fields (<xref target="request.header.fields"/>),
   the meaning of status codes to indicate a machine-readable response
   (<xref target="status.codes"/>), and the meaning of other control data
   and resource metadata that might be given in response header fields
   (<xref target="response.header.fields"/>).
</t>
<t><iref item="content negotiation"/>
   This document also defines representation metadata that describe how a
   payload is intended to be interpreted by a recipient, the request header
   fields that might influence content selection, and the various selection
   algorithms that are collectively referred to as
   "<x:dfn>content negotiation</x:dfn>" (<xref target="content.negotiation"/>).
</t>
<section title="Conformance and Error Handling" anchor="conformance">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   Conformance criteria and considerations regarding error handling
   are defined in &conformance;.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
<t>
   This specification uses the Augmented Backus-Naur Form (ABNF) notation of
   <xref target="RFC5234"/> with a list extension, defined in
   &abnf-extension;, that allows for compact definition of
   comma-separated lists using a '#' operator (similar to how the '*' operator
   indicates repetition).
   <xref target="imported.abnf"/> describes rules imported from
   other documents. 
   <xref target="collected.abnf"/> shows the collected grammar with all list
   operators expanded to standard ABNF notation.
</t>
<t>
   This specification uses the terms
   "character",
   "character encoding scheme",
   "charset", and
   "protocol element"
   as they are defined in <xref target="RFC6365"/>.
</t>
</section>
</section>

<section title="Resources" anchor="resources">
  <x:anchor-alias value="target resource"/>
<t>
   The target of an HTTP request is called a "<x:dfn>resource</x:dfn>". 
   HTTP does not limit the nature of a resource; it merely
   defines an interface that might be used to interact with resources.
   Each resource is identified by a Uniform Resource Identifier (URI), as
   described in &uri;.
</t>
<t>
   When a client constructs an HTTP/1.1 request message, it sends the
   <x:ref>target URI</x:ref> in one of various forms, as defined in
   (&request-target;). When a request is received, the server reconstructs
   an <x:ref>effective request URI</x:ref> for the target resource
   (&effective-request-uri;).
</t>
<t>
   One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method (<xref target="methods"/>) and a few
   request-modifying header fields (<xref target="request.header.fields"/>).
   If there is a conflict between the method semantics and any semantic
   implied by the URI itself, as described in <xref target="safe.methods"/>,
   the method semantics take precedence.
</t>
</section>

<section title="Representations" anchor="representations">
   <iref primary="true" item="representation"/>
   <iref primary="true" item="selected representation"/>
   <x:anchor-alias value="representation"/>
   <x:anchor-alias value="selected representation"/>
<t>
   Considering that a resource could be anything, and that the uniform
   interface provided by HTTP is similar to a window through which one can
   observe and act upon such a thing only through the communication of
   messages to some independent actor on the other side, an abstraction is
   needed to represent ("take the place of") the current or desired state of
   that thing in our communications. That abstraction is called a
   representation <xref target="REST"/>.
</t>
<t>
   For the purposes of HTTP, a "<x:dfn>representation</x:dfn>" is information
   that is intended to reflect a past, current, or desired state of a given
   resource, in a format that can be readily communicated via the protocol,
   and that consists of a set of representation metadata and a potentially
   unbounded stream of representation data.
</t>
<t>
   An origin server might be provided with, or be capable of generating, multiple
   representations that are each intended to reflect the current state of a
   <x:ref>target resource</x:ref>. In such cases, some algorithm is used by
   the origin server to select one of those representations as most applicable
   to a given request, usually based on <x:ref>content negotiation</x:ref>.
   This "<x:dfn>selected representation</x:dfn>" is used to provide the data
   and metadata for evaluating conditional requests <xref target="RFC7232"/> and
   constructing the payload for <x:ref>200 (OK)</x:ref> and
   <x:ref>304 (Not Modified)</x:ref> responses to GET (<xref target="GET"/>).
</t>

<section title="Representation Metadata" anchor="representation.metadata">
  <x:anchor-alias value="representation-header"/>
<t>
   Representation header fields provide metadata about the representation.
   When a message includes a payload body, the representation header fields
   describe how to interpret the representation data enclosed in the payload
   body.  In a response to a HEAD request, the representation header fields
   describe the representation data that would have been enclosed in the
   payload body if the same request had been a GET.
</t>
<t>
   The following header fields convey representation metadata:
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol>
  <ttcol>Defined in...</ttcol>

  <c>Content-Type</c> <c><xref target="header.content-type"/></c>
  <c>Content-Encoding</c> <c><xref target="header.content-encoding"/></c>
  <c>Content-Language</c> <c><xref target="header.content-language"/></c>
  <c>Content-Location</c> <c><xref target="header.content-location"/></c>
</texttable>

<section title="Processing Representation Data" anchor="data.type">

<section title="Media Type" anchor="media.type">
  <x:anchor-alias value="media-type"/>
  <x:anchor-alias value="type"/>
  <x:anchor-alias value="subtype"/>
<t>
   HTTP uses Internet media types <xref target="RFC2046"/> in the
   <x:ref>Content-Type</x:ref> (<xref target="header.content-type"/>)
   and <x:ref>Accept</x:ref> (<xref target="header.accept"/>) header fields in
   order to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with each context in which it
   is received.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="media-type"/><iref primary="true" item="Grammar" subitem="type"/><iref primary="true" item="Grammar" subitem="subtype"/>
  <x:ref>media-type</x:ref> = <x:ref>type</x:ref> "/" <x:ref>subtype</x:ref> *( <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> <x:ref>parameter</x:ref> )
  <x:ref>type</x:ref>       = <x:ref>token</x:ref>
  <x:ref>subtype</x:ref>    = <x:ref>token</x:ref>
</artwork></figure>
<t anchor="rule.parameter">
  <x:anchor-alias value="parameter"/>
   The type/subtype &MAY; be followed by parameters in the form of
   name=value pairs.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="parameter"/>
  <x:ref>parameter</x:ref>      = <x:ref>token</x:ref> "=" ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> )
</artwork></figure>
<t>
   The type, subtype, and parameter name tokens are case-insensitive.
   Parameter values might or might not be case-sensitive, depending on the
   semantics of the parameter name.  The presence or absence of a parameter might
   be significant to the processing of a media-type, depending on its
   definition within the media type registry.
</t>
<t>
   A parameter value that matches the <x:ref>token</x:ref> production can be
   transmitted either as a token or within a quoted-string. The quoted and
   unquoted values are equivalent. For example, the following examples are
   all equivalent, but the first is preferred for consistency:
</t>
<figure><artwork type="example">
  text/html;charset=utf-8
  text/html;charset=UTF-8
  Text/HTML;Charset="utf-8"
  text/html; charset="utf-8"
</artwork></figure>
<t>
   Internet media types ought to be registered with IANA according to the
   procedures defined in <xref target="BCP13"/>.
</t>
<x:note>
  <t>
    &Note; Unlike some similar constructs in other header fields, media type
    parameters do not allow whitespace (even "bad" whitespace) around the "="
    character.
  </t>
</x:note>
</section>

<section title="Charset" anchor="charset">
  <x:anchor-alias value="rule.charset"/>
<t>
   HTTP uses <x:dfn>charset</x:dfn> names to indicate or negotiate the
   character encoding scheme of a textual representation
   <xref target="RFC6365"/>.
   A charset is identified by a case-insensitive token.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="charset"/>
  <x:ref>charset</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
   Charset names ought to be registered in the IANA "Character Sets" registry
   (<eref target="http://www.iana.org/assignments/character-sets"/>)
   according to the procedures defined in <xref target="RFC2978"/>.
</t>
</section>

<section title="Canonicalization and Text Defaults" anchor="canonicalization.and.text.defaults">
<t>
   Internet media types are registered with a canonical form in order to be
   interoperable among systems with varying native encoding formats.
   Representations selected or transferred via HTTP ought to be in canonical
   form, for many of the same reasons described by the Multipurpose Internet
   Mail Extensions (MIME) <xref target="RFC2045"/>.
   However, the performance characteristics of email deployments (i.e., store
   and forward messages to peers) are significantly different from those
   common to HTTP and the Web (server-based information services).
   Furthermore, MIME's constraints for the sake of compatibility with older
   mail transfer protocols do not apply to HTTP
   (see <xref target="differences.between.http.and.mime"/>).
</t>
<t>
   MIME's canonical form requires that media subtypes of the "text"
   type use CRLF as the text line break. HTTP allows the
   transfer of text media with plain CR or LF alone representing a line
   break, when such line breaks are consistent for an entire representation.
   An HTTP sender &MAY; generate, and a recipient &MUST; be able to parse,
   line breaks in text media that consist of CRLF, bare CR, or bare LF.
   In addition, text media in HTTP is not limited to charsets that
   use octets 13 and 10 for CR and LF, respectively.
   This flexibility regarding line breaks applies only to text within a
   representation that has been assigned a "text" media type; it does not
   apply to "multipart" types or HTTP elements outside the payload body
   (e.g., header fields).
</t>
<t>
   If a representation is encoded with a content-coding, the underlying
   data ought to be in a form defined above prior to being encoded.
</t>
</section>

<section title="Multipart Types" anchor="multipart.types">
<t>
   MIME provides for a number of "multipart" types &mdash; encapsulations of
   one or more representations within a single message body. All multipart
   types share a common syntax, as defined in <xref target="RFC2046" x:sec="5.1.1" x:fmt="of"/>,
   and include a boundary parameter as part of the media type
   value. The message body is itself a protocol element; a sender &MUST;
   generate only CRLF to represent line breaks between body parts.
</t>
<t>
   HTTP message framing does not use the multipart boundary as an indicator
   of message body length, though it might be used by implementations that
   generate or process the payload. For example, the "multipart/form-data"
   type is often used for carrying form data in a request, as described in
   <xref target="RFC2388"/>, and the "multipart/byteranges" type is defined
   by this specification for use in some <x:ref>206 (Partial Content)</x:ref>
   responses <xref target="RFC7233"/>.
</t>
</section>

<section title="Content-Type" anchor="header.content-type">
  <iref primary="true" item="Content-Type header field" x:for-anchor=""/>
  <x:anchor-alias value="Content-Type"/>
<t>
   The "Content-Type" header field indicates the media type of the
   associated representation: either the representation enclosed in
   the message payload or the <x:ref>selected representation</x:ref>, as determined by the
   message semantics.  The indicated media type defines both the data format
   and how that data is intended to be processed by a recipient, within the
   scope of the received message semantics, after any content codings
   indicated by <x:ref>Content-Encoding</x:ref> are decoded.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Type"/>
  <x:ref>Content-Type</x:ref> = <x:ref>media-type</x:ref>
</artwork></figure>
<t>
   Media types are defined in <xref target="media.type"/>. An example of the
   field is
</t>
<figure><artwork type="example">
  Content-Type: text/html; charset=ISO-8859-4
</artwork></figure>
<t>
   A sender that generates a message containing a payload body &SHOULD;
   generate a Content-Type header field in that message unless the intended
   media type of the enclosed representation is unknown to the sender.
   If a Content-Type header field is not present, the recipient &MAY; either
   assume a media type of
   "application/octet-stream" (<xref target="RFC2046" x:fmt="," x:sec="4.5.1"/>)
   or examine the data to determine its type.
</t>
<t>
   In practice, resource owners do not always properly configure their origin
   server to provide the correct Content-Type for a given representation,
   with the result that some clients will examine a payload's content
   and override the specified type.
   Clients that do so risk drawing incorrect conclusions, which might expose
   additional security risks (e.g., "privilege escalation").  Furthermore,
   it is impossible to determine the sender's intent by examining the data
   format: many data formats match multiple media types that differ only in
   processing semantics.  Implementers are encouraged to provide a means of
   disabling such "content sniffing" when it is used.
</t>
</section>
</section>

<section title="Encoding for Compression or Integrity" anchor="data.encoding">

<section title="Content Codings" anchor="content.codings">
  <iref primary="true" item="content coding"/>
  <iref primary="true" item="compress (content coding)"/>
  <iref primary="true" item="x-compress (content coding)"/>
  <iref primary="true" item="deflate (content coding)"/>
  <iref primary="true" item="gzip (content coding)"/>
  <iref primary="true" item="x-gzip (content coding)"/>
  <x:anchor-alias value="content-coding"/>
<t>
   Content coding values indicate an encoding transformation that has
   been or can be applied to a representation. Content codings are primarily
   used to allow a representation to be compressed or otherwise usefully
   transformed without losing the identity of its underlying media type
   and without loss of information. Frequently, the representation is stored
   in coded form, transmitted directly, and only decoded by the final recipient.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="content-coding"/>
  <x:ref>content-coding</x:ref>   = <x:ref>token</x:ref>
</artwork></figure>
<t>
   All content-coding values are case-insensitive and ought to be registered
   within the "HTTP Content Coding Registry", as defined in
   <xref target="content.coding.registry"/>. They are used in the
   <x:ref>Accept-Encoding</x:ref> (<xref target="header.accept-encoding"/>)
   and <x:ref>Content-Encoding</x:ref> (<xref target="header.content-encoding"/>)
   header fields.
</t>
<t>
   The following content-coding values are defined by this specification:
   <list>
    <t>compress (and x-compress): See &compress-coding;.</t>
    <t>deflate: See &deflate-coding;.</t>
    <t>gzip (and x-gzip): See &gzip-coding;.</t>
   </list>
</t>
</section>

<section title="Content-Encoding" anchor="header.content-encoding">
  <iref primary="true" item="Content-Encoding header field" x:for-anchor=""/>
  <x:anchor-alias value="Content-Encoding"/>
<t>
   The "Content-Encoding" header field indicates what content codings 
   have been applied to the representation, beyond those inherent in the media
   type, and thus what decoding mechanisms have to be applied in order to
   obtain data in the media type referenced by the <x:ref>Content-Type</x:ref>
   header field.
   Content-Encoding is primarily used to allow a representation's data to be
   compressed without losing the identity of its underlying media type.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Encoding"/>
  <x:ref>Content-Encoding</x:ref> = 1#<x:ref>content-coding</x:ref>
</artwork></figure>
<t>
   An example of its use is
</t>
<figure><artwork type="example">
  Content-Encoding: gzip
</artwork></figure>
<t>
   If one or more encodings have been applied to a representation, the sender
   that applied the encodings &MUST; generate a Content-Encoding header field
   that lists the content codings in the order in which they were applied.
   Additional information about the encoding parameters can be provided
   by other header fields not defined by this specification.
</t>
<t>
   Unlike Transfer-Encoding (&header-transfer-encoding;), the codings listed
   in Content-Encoding are a characteristic of the representation; the
   representation is defined in terms of the coded form, and all other
   metadata about the representation is about the coded form unless otherwise
   noted in the metadata definition. Typically, the representation is only
   decoded just prior to rendering or analogous usage.
</t>
<t>
   If the media type includes an inherent encoding, such as a data format
   that is always compressed, then that encoding would not be restated in 
   Content-Encoding even if it happens to be the same algorithm as one
   of the content codings.  Such a content coding would only be listed if,
   for some bizarre reason, it is applied a second time to form the
   representation.  Likewise, an origin server might choose to publish the
   same data as multiple representations that differ only in whether
   the coding is defined as part of <x:ref>Content-Type</x:ref> or
   Content-Encoding, since some user agents will behave differently in their
   handling of each response (e.g., open a "Save as ..." dialog instead of
   automatic decompression and rendering of content).
</t>
<t>
   An origin server &MAY; respond with a status code of
   <x:ref>415 (Unsupported Media Type)</x:ref> if a representation in the
   request message has a content coding that is not acceptable.
</t>
</section>
</section>

<section title="Audience Language" anchor="audience.language">

<section title="Language Tags" anchor="language.tags">
  <x:anchor-alias value="language-tag"/>
<t>
   A language tag, as defined in <xref target="RFC5646"/>, identifies a
   natural language spoken, written, or otherwise conveyed by human beings for
   communication of information to other human beings. Computer languages are
   explicitly excluded.
</t>
<t>
   HTTP uses language tags within the <x:ref>Accept-Language</x:ref> and
   <x:ref>Content-Language</x:ref> header fields.
   <x:ref>Accept-Language</x:ref> uses the broader language-range production
   defined in <xref target="header.accept-language"/>, whereas
   <x:ref>Content-Language</x:ref> uses the language-tag production defined
   below.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="language-tag"/>
  <x:ref>language-tag</x:ref> = &lt;Language-Tag, see <xref target="RFC5646" x:sec="2.1"/>&gt;
</artwork></figure>
<t>
   A language tag is a sequence of one or more case-insensitive subtags, each
   separated by a hyphen character ("-", %x2D).  In most cases, a language tag
   consists of a primary language subtag that identifies a broad family of
   related languages (e.g., "en" = English), which is optionally followed by a
   series of subtags that refine or narrow that language's range (e.g.,
   "en-CA" = the variety of English as communicated in Canada).
   Whitespace is not allowed within a language tag.
   Example tags include:
</t>
<figure><artwork type="example">
  fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
</artwork></figure>
<t>
   See <xref target="RFC5646"/> for further information. 
</t>
</section>

<section title="Content-Language" anchor="header.content-language">
  <iref primary="true" item="Content-Language header field" x:for-anchor=""/>
  <x:anchor-alias value="Content-Language"/>
<t>
   The "Content-Language" header field describes the natural
   language(s) of the intended audience for the representation. Note that this might
   not be equivalent to all the languages used within the representation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Language"/>
  <x:ref>Content-Language</x:ref> = 1#<x:ref>language-tag</x:ref>
</artwork></figure>
<t>
   Language tags are defined in <xref target="language.tags"/>. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the users' own preferred language. Thus, if the
   content is intended only for a Danish-literate audience, the
   appropriate field is
</t>
<figure><artwork type="example">
  Content-Language: da
</artwork></figure>
<t>
   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.
</t>
<t>
   Multiple languages &MAY; be listed for content that is intended for
   multiple audiences. For example, a rendition of the "Treaty of
   Waitangi", presented simultaneously in the original Maori and English
   versions, would call for
</t>
<figure><artwork type="example">
  Content-Language: mi, en
</artwork></figure>
<t>
   However, just because multiple languages are present within a representation
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as "A First
   Lesson in Latin", which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include "en".
</t>
<t>
   Content-Language &MAY; be applied to any media type &mdash; it is not
   limited to textual documents.
</t>
</section>
</section>

<section title="Identification" anchor="identification">

<section title="Identifying a Representation" anchor="identifying.payload">
<t>
   When a complete or partial representation is transferred in a message
   payload, it is often desirable for the sender to supply, or the recipient
   to determine, an identifier for a resource corresponding to that
   representation.
</t>
<t>
   For a request message:
   <list style="symbols">
      <t>If the request has a <x:ref>Content-Location</x:ref> header field,
         then the sender asserts that the payload is a representation of the
         resource identified by the Content-Location field-value. However,
         such an assertion cannot be trusted unless it can be verified by
         other means (not defined by this specification). The information
         might still be useful for revision history links.</t>
      <t>Otherwise, the payload is unidentified.</t>
   </list>
</t>
<t>
   For a response message, the following rules are applied in order until a
   match is found:
   <list style="numbers">
      <t>If the request method is GET or HEAD and the response status code is
         <x:ref>200 (OK)</x:ref>, 
         <x:ref>204 (No Content)</x:ref>,
         <x:ref>206 (Partial Content)</x:ref>, or
         <x:ref>304 (Not Modified)</x:ref>,
         the payload is a representation of the resource identified by the
         effective request URI (&effective-request-uri;).</t>
      <t>If the request method is GET or HEAD and the response status code is
         <x:ref>203 (Non-Authoritative Information)</x:ref>, the payload is
         a potentially modified or enhanced representation of the
         <x:ref>target resource</x:ref> as provided by an intermediary.</t>
      <t>If the response has a <x:ref>Content-Location</x:ref> header field
         and its field-value is a reference to the same URI as the effective
         request URI, the payload is a representation of the resource
         identified by the effective request URI.</t>
      <t>If the response has a <x:ref>Content-Location</x:ref> header field
         and its field-value is a reference to a URI different from the
         effective request URI, then the sender asserts that the payload is a
         representation of the resource identified by the Content-Location
         field-value. However, such an assertion cannot be trusted unless
         it can be verified by other means (not defined by this specification).</t>
      <t>Otherwise, the payload is unidentified.</t>
   </list>
</t>
</section>

<section title="Content-Location" anchor="header.content-location">
  <iref primary="true" item="Content-Location header field" x:for-anchor=""/>
  <x:anchor-alias value="Content-Location"/>
<t>
   The "Content-Location" header field references a URI that can be used
   as an identifier for a specific resource corresponding to the
   representation in this message's payload.
   In other words, if one were to perform a GET request on this URI at the time
   of this message's generation, then a <x:ref>200 (OK)</x:ref> response would
   contain the same representation that is enclosed as payload in this message.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Location"/>
  <x:ref>Content-Location</x:ref> = <x:ref>absolute-URI</x:ref> / <x:ref>partial-URI</x:ref>
</artwork></figure>
<t>
   The Content-Location value is not a replacement for the effective
   Request URI (&effective-request-uri;).  It is representation metadata.
   It has the same syntax and semantics as the header field of the same name
   defined for MIME body parts in <xref target="RFC2557" x:fmt="of" x:sec="4"/>.
   However, its appearance in an HTTP message has some special implications
   for HTTP recipients.
</t>
<t>
   If Content-Location is included in a <x:ref>2xx (Successful)</x:ref>
   response message and its value refers (after conversion to absolute form)
   to a URI that is the same as the effective request URI, then
   the recipient &MAY; consider the payload to be a current representation of
   that resource at the time indicated by the message origination date.
   For a GET (<xref target="GET"/>) or HEAD (<xref target="HEAD"/>) request,
   this is the same as the default semantics when no Content-Location is
   provided by the server.
   For a state-changing request like PUT (<xref target="PUT"/>) or
   POST (<xref target="POST"/>), it implies that the server's response
   contains the new representation of that resource, thereby distinguishing it
   from representations that might only report about the action
   (e.g., "It worked!").
   This allows authoring applications to update their local copies without
   the need for a subsequent GET request.
</t>
<t>
   If Content-Location is included in a <x:ref>2xx (Successful)</x:ref>
   response message and its field-value refers to a URI that differs from the
   effective request URI, then the origin server claims that the URI
   is an identifier for a different resource corresponding to the enclosed
   representation. Such a claim can only be trusted if both identifiers share
   the same resource owner, which cannot be programmatically determined via
   HTTP.
   <list style="symbols">
    <t>For a response to a GET or HEAD request, this is an indication that the
       effective request URI refers to a resource that is subject to content
       negotiation and the Content-Location field-value is a more specific
       identifier for the <x:ref>selected representation</x:ref>.</t>
    <t>For a <x:ref>201 (Created)</x:ref> response to a state-changing method,
       a Content-Location field-value that is identical to the
       <x:ref>Location</x:ref> field-value indicates that this payload is a
       current representation of the newly created resource.</t>
    <t>Otherwise, such a Content-Location indicates that this payload is a
       representation reporting on the requested action's status and that the
       same report is available (for future access with GET) at the given URI.
       For example, a purchase transaction made via a POST request might
       include a receipt document as the payload of the <x:ref>200 (OK)</x:ref>
       response; the Content-Location field-value provides an identifier for
       retrieving a copy of that same receipt in the future.</t>
   </list>
</t>
<t>
   A user agent that sends Content-Location in a request message is stating
   that its value refers to where the user agent originally obtained the
   content of the enclosed representation (prior to any modifications made by
   that user agent).  In other words, the user agent is providing a back link
   to the source of the original representation.
</t>
<t>
   An origin server that receives a Content-Location field in a request
   message &MUST; treat the information as transitory request context rather
   than as metadata to be saved verbatim as part of the representation.
   An origin server &MAY; use that context to guide in processing the
   request or to save it for other uses, such as within source links or
   versioning metadata. However, an origin server &MUST-NOT; use such context
   information to alter the request semantics.
</t>
<t>
   For example, if a client makes a PUT request on a negotiated resource and
   the origin server accepts that PUT (without redirection), then the new
   state of that resource is expected to be consistent with the one
   representation supplied in that PUT; the Content-Location cannot be used as
   a form of reverse content selection identifier to update only one of the
   negotiated representations. If the user agent had wanted the latter
   semantics, it would have applied the PUT directly to the Content-Location
   URI.
</t>
</section>
</section>
</section>

<section title="Representation Data" anchor="representation.data">
  <x:anchor-alias value="representation-data"/>
<t>
   The representation data associated with an HTTP message is
   either provided as the payload body of the message or
   referred to by the message semantics and the effective request
   URI.  The representation data is in a format and encoding defined by
   the representation metadata header fields.
</t>
<t>
   The data type of the representation data is determined via the header fields
   <x:ref>Content-Type</x:ref> and <x:ref>Content-Encoding</x:ref>.
   These define a two-layer, ordered encoding model:
</t>
<figure><artwork type="example">
  representation-data := Content-Encoding( Content-Type( bits ) )
</artwork></figure>
</section>

<section title="Payload Semantics" anchor="payload">
<iref item="payload"/>
<t>
   Some HTTP messages transfer a complete or partial representation as the
   message "<x:dfn>payload</x:dfn>".  In some cases, a payload might contain
   only the associated representation's header fields (e.g., responses to
   HEAD) or only some part(s) of the representation data
   (e.g., the <x:ref>206 (Partial Content)</x:ref> status code).
</t>
<t>
   The purpose of a payload in a request is defined by the method semantics.
   For example, a representation in the payload of a PUT request
   (<xref target="PUT"/>) represents the desired state of the
   <x:ref>target resource</x:ref> if the request is successfully applied,
   whereas a representation in the payload of a POST request
   (<xref target="POST"/>) represents information to be processed by the
   target resource.
</t>
<t>
   In a response, the payload's purpose is defined by both the request method
   and the response status code.
   For example, the payload of a <x:ref>200 (OK)</x:ref> response to GET
   (<xref target="GET"/>) represents the current state of the
   <x:ref>target resource</x:ref>, as observed at the time of the message
   origination date (<xref target="header.date"/>), whereas the payload of
   the same status code in a response to POST might represent either the
   processing result or the new state of the target resource after applying
   the processing. Response messages with an error status code usually contain
   a payload that represents the error condition, such that it describes the
   error state and what next steps are suggested for resolving it.
</t>
<t>
   Header fields that specifically describe the payload, rather than the
   associated representation, are referred to as "payload header fields".
   Payload header fields are defined in other parts of this specification,
   due to their impact on message parsing.
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol>
  <ttcol>Defined in...</ttcol>

  <c>Content-Length</c> <c>&header-content-length;</c>
  <c>Content-Range</c> <c>&header-content-range;</c>
  <c>Trailer</c> <c>&header-trailer;</c>
  <c>Transfer-Encoding</c> <c>&header-transfer-encoding;</c>
</texttable>
</section>

<section title="Content Negotiation" anchor="content.negotiation">
  <x:anchor-alias value="content negotiation"/>
<t>
   When responses convey payload information, whether indicating a success or
   an error, the origin server often has different ways of representing that
   information; for example, in different formats, languages, or encodings.
   Likewise, different users or user agents might have differing capabilities,
   characteristics, or preferences that could influence which representation,
   among those available, would be best to deliver. For this reason, HTTP
   provides mechanisms for <x:ref>content negotiation</x:ref>.
</t>
<t>
   This specification defines two patterns of content negotiation that can
   be made visible within the protocol:
   "proactive", where the server selects the representation based
   upon the user agent's stated preferences, and "reactive" negotiation,
   where the server provides a list of representations for the user agent to
   choose from. Other patterns of content negotiation include
   "conditional content", where the representation consists of multiple
   parts that are selectively rendered based on user agent parameters, 
   "active content", where the representation contains a script that
   makes additional (more specific) requests based on the user agent
   characteristics, and "Transparent Content Negotiation"
   (<xref target="RFC2295"/>), where content selection is performed by
   an intermediary. These patterns are not mutually exclusive, and each has
   trade-offs in applicability and practicality.
</t>
<t>
   Note that, in all cases, HTTP is not aware of the resource semantics.
   The consistency with which an origin server responds to requests, over time
   and over the varying dimensions of content negotiation, and thus the
   "sameness" of a resource's observed representations over time, is
   determined entirely by whatever entity or algorithm selects or generates
   those responses. HTTP pays no attention to the man behind the curtain.
</t>

<section title="Proactive Negotiation" anchor="proactive.negotiation">
  <x:anchor-alias value="proactive negotiation"/>
  <x:anchor-alias value="server-driven negotiation"/>
<t>
   When content negotiation preferences are sent by the user agent in a
   request to encourage an algorithm located at the server to
   select the preferred representation, it is called
   <x:dfn>proactive negotiation</x:dfn>
   (a.k.a., <x:dfn>server-driven negotiation</x:dfn>). Selection is based on
   the available representations for a response (the dimensions over which it
   might vary, such as language, content-coding, etc.) compared to various
   information supplied in the request, including both the explicit
   negotiation fields of <xref target="request.conneg"/> and implicit
   characteristics, such as the client's network address or parts of the
   <x:ref>User-Agent</x:ref> field.
</t>
<t>
   Proactive negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to a user agent, or when the server desires to send its
   "best guess" to the user agent along with the first response (hoping to
   avoid the round trip delay of a subsequent request if the "best
   guess" is good enough for the user). In order to improve the server's
   guess, a user agent &MAY; send request header fields that describe
   its preferences.
</t>
<t>
   Proactive negotiation has serious disadvantages:
  <list style="symbols">
    <t>
         It is impossible for the server to accurately determine what
         might be "best" for any given user, since that would require
         complete knowledge of both the capabilities of the user agent
         and the intended use for the response (e.g., does the user want
         to view it on screen or print it on paper?);
    </t>
    <t>
         Having the user agent describe its capabilities in every
         request can be both very inefficient (given that only a small
         percentage of responses have multiple representations) and a
         potential risk to the user's privacy;
    </t>
    <t>
         It complicates the implementation of an origin server and the
         algorithms for generating responses to a request; and,
    </t>
    <t>
         It limits the reusability of responses for shared caching.
    </t>
  </list>
</t>
<t>
   A user agent cannot rely on proactive negotiation preferences being
   consistently honored, since the origin server might not implement proactive
   negotiation for the requested resource or might decide that sending a
   response that doesn't conform to the user agent's preferences is better
   than sending a <x:ref>406 (Not Acceptable)</x:ref> response.
</t>
<t>
   A <x:ref>Vary</x:ref> header field (<xref target="header.vary"/>) is
   often sent in a response subject to proactive negotiation to indicate what
   parts of the request information were used in the selection algorithm.
</t>
</section>

<section title="Reactive Negotiation" anchor="reactive.negotiation">
  <x:anchor-alias value="reactive negotiation"/>
  <x:anchor-alias value="agent-driven negotiation"/>
<t>
   With <x:dfn>reactive negotiation</x:dfn>
   (a.k.a., <x:dfn>agent-driven negotiation</x:dfn>), selection of the best
   response representation (regardless of the status code) is performed by the
   user agent after receiving an initial response from the origin server that
   contains a list of resources for alternative representations.
   If the user agent is not satisfied by the initial response representation,
   it can perform a GET request on one or more of the alternative resources,
   selected based on metadata included in the list, to obtain a different form
   of representation for that response. Selection of alternatives might be
   performed automatically by the user agent or manually by the user selecting
   from a generated (possibly hypertext) menu.
</t>
<t>
   Note that the above refers to representations of the response, in general,
   not representations of the resource. The alternative representations are
   only considered representations of the target resource if the response in
   which those alternatives are provided has the semantics of being a
   representation of the target resource (e.g., a <x:ref>200 (OK)</x:ref>
   response to a GET request) or has the semantics of providing links to
   alternative representations for the target resource
   (e.g., a <x:ref>300 (Multiple Choices)</x:ref> response to a GET request).
</t>
<t>
   A server might choose not to send an initial representation, other than
   the list of alternatives, and thereby indicate that reactive
   negotiation by the user agent is preferred. For example, the alternatives
   listed in responses with the <x:ref>300 (Multiple Choices)</x:ref> and
   <x:ref>406 (Not Acceptable)</x:ref> status codes include information about
   the available representations so that the user or user agent can react by
   making a selection.
</t>
<t>
   Reactive negotiation is advantageous when the response would vary
   over commonly used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage.
</t>
<t>
   Reactive negotiation suffers from the disadvantages of transmitting
   a list of alternatives to the user agent, which degrades user-perceived
   latency if transmitted in the header section, and needing a second request
   to obtain an alternate representation. Furthermore, this specification
   does not define a mechanism for supporting automatic selection, though it
   does not prevent such a mechanism from being developed as an extension.
</t>
</section>
</section>
</section>

<section title="Request Methods" anchor="methods">

<section title="Overview" anchor="method.overview">
  <x:anchor-alias value="method"/>
<t>
   The request method token is the primary source of request semantics;
   it indicates the purpose for which the client has made this request
   and what is expected by the client as a successful result.
</t>
<t>
   The request method's semantics might be further specialized by the
   semantics of some header fields when present in a request
   (<xref target="request.header.fields"/>) if those additional semantics do
   not conflict with the method.
   For example, a client can send conditional request header fields
   (<xref target="request.conditionals"/>) to make the requested
   action conditional on the current state of the target resource
   (<xref target="RFC7232"/>).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="method"/>
  <x:ref>method</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
   HTTP was originally designed to be usable as an interface to distributed
   object systems.  The request method was envisioned as applying
   semantics to a <x:ref>target resource</x:ref> in much the same way as invoking a defined
   method on an identified object would apply semantics. The method token
   is case-sensitive because it might be used as a gateway to object-based
   systems with case-sensitive method names.
</t>
<t>
   Unlike distributed objects, the standardized request methods in HTTP are
   not resource-specific, since uniform interfaces provide for better
   visibility and reuse in network-based systems <xref target="REST"/>.
   Once defined, a standardized method ought to have the same semantics when
   applied to any resource, though each resource determines for itself
   whether those semantics are implemented or allowed.
</t>
<t>
   This specification defines a number of standardized methods that are
   commonly used in HTTP, as outlined by the following table. By convention,
   standardized methods are defined in all-uppercase US-ASCII letters.
</t>
<texttable align="left" suppress-title="true" anchor="table.of.methods">
   <ttcol>Method</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Sec.</ttcol>
   <c>GET</c>
   <c>Transfer a current representation of the target resource.</c>
   <c><xref target="GET" format="counter"/></c>
   <c>HEAD</c>
   <c>Same as GET, but only transfer the status line and header section.</c>
   <c><xref target="HEAD" format="counter"/></c>
   <c>POST</c>
   <c>Perform resource-specific processing on the request payload.</c>
   <c><xref target="POST" format="counter"/></c>
   <c>PUT</c>
   <c>Replace all current representations of the target resource with
      the request payload.</c>
   <c><xref target="PUT" format="counter"/></c>
   <c>DELETE</c>
   <c>Remove all current representations of the target resource.</c>
   <c><xref target="DELETE" format="counter"/></c>
   <c>CONNECT</c>
   <c>Establish a tunnel to the server identified by the target resource.</c>
   <c><xref target="CONNECT" format="counter"/></c>
   <c>OPTIONS</c>
   <c>Describe the communication options for the target resource.</c>
   <c><xref target="OPTIONS" format="counter"/></c>
   <c>TRACE</c>
   <c>Perform a message loop-back test along the path to the target resource.</c>
   <c><xref target="TRACE" format="counter"/></c>
</texttable>
<t>
   All general-purpose servers &MUST; support the methods GET and HEAD.
   All other methods are &OPTIONAL;.
</t>
<t>
   Additional methods, outside the scope of this specification, have been
   standardized for use in HTTP.  All such methods ought to be registered
   within the "Hypertext Transfer Protocol (HTTP) Method Registry" maintained by IANA, as defined in
   <xref target="method.registry"/>.
</t>
<t>
   The set of methods allowed by a target resource can be listed in an
   <x:ref>Allow</x:ref> header field (<xref target="header.allow"/>).
   However, the set of allowed methods can change dynamically.
   When a request method is received that is unrecognized or not implemented
   by an origin server, the origin server &SHOULD; respond with the
   <x:ref>501 (Not Implemented)</x:ref> status code.
   When a request method is received that is known by an origin server but
   not allowed for the target resource, the origin server &SHOULD; respond
   with the <x:ref>405 (Method Not Allowed)</x:ref> status code.
</t>
</section>

<section title="Common Method Properties" anchor="method.properties">

<section title="Safe Methods" anchor="safe.methods">
  <iref item="safe" primary="true"/>
  <x:anchor-alias value="safe"/>
<t>
   Request methods are considered "<x:dfn>safe</x:dfn>" if
   their defined semantics are essentially read-only; i.e., the client does
   not request, and does not expect, any state change on the origin server
   as a result of applying a safe method to a target resource.  Likewise,
   reasonable use of a safe method is not expected to cause any harm,
   loss of property, or unusual burden on the origin server.
</t>
<t>
   This definition of safe methods does not prevent an implementation from
   including behavior that is potentially harmful, that is not entirely read-only,
   or that causes side effects while invoking a safe method.  What is
   important, however, is that the client did not request that additional
   behavior and cannot be held accountable for it.  For example,
   most servers append request information to access log files at the
   completion of every response, regardless of the method, and that is
   considered safe even though the log storage might become full and crash
   the server.  Likewise, a safe request initiated by selecting an
   advertisement on the Web will often have the side effect of charging an
   advertising account.
</t>
<t>
   Of the request methods defined by this specification, the
   GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.
</t>
<t>
   The purpose of distinguishing between safe and unsafe methods is to
   allow automated retrieval processes (spiders) and cache performance
   optimization (pre-fetching) to work without fear of causing harm.
   In addition, it allows a user agent to apply appropriate constraints
   on the automated use of unsafe methods when processing potentially
   untrusted content.
</t>
<t>
   A user agent &SHOULD; distinguish between safe and unsafe methods when
   presenting potential actions to a user, such that the user can be made
   aware of an unsafe action before it is requested.
</t>
<t>
   When a resource is constructed such that parameters within the effective
   request URI have the effect of selecting an action, it is the resource
   owner's responsibility to ensure that the action is consistent with the
   request method semantics.
   For example, it is common for Web-based content editing software
   to use actions within query parameters, such as "page?do=delete".
   If the purpose of such a resource is to perform an unsafe action, then
   the resource owner &MUST; disable or disallow that action when it is
   accessed using a safe request method. Failure to do so will result in
   unfortunate side effects when automated processes perform a GET on
   every URI reference for the sake of link maintenance, pre-fetching,
   building a search index, etc.
</t>
</section>

<section title="Idempotent Methods" anchor="idempotent.methods">
<iref item="idempotent" primary="true"/>
<t>
   A request method is considered
   "<x:dfn anchor="idempotent">idempotent</x:dfn>"
   if the intended effect on the server of multiple identical requests with
   that method is the same as the effect for a single such request.
   Of the request methods defined by this
   specification, PUT, DELETE, and safe request methods are idempotent.
</t>
<t>
   Like the definition of safe, the idempotent property only applies to
   what has been requested by the user; a server is free to log each request
   separately, retain a revision control history, or implement other
   non-idempotent side effects for each idempotent request.
</t>
<t>
   Idempotent methods are distinguished because the request can be repeated
   automatically if a communication failure occurs before the client is
   able to read the server's response.  For example, if a client sends a PUT
   request and the underlying connection is closed before any response is
   received, then the client can establish a new connection and retry the
   idempotent request. It knows that repeating the request will have
   the same intended effect, even if the original request succeeded, though
   the response might differ.
</t>
</section>

<section title="Cacheable Methods" anchor="cacheable.methods">
<iref item="cacheable" primary="true"/>
<t>
   Request methods can be defined as "<x:dfn
   anchor="cacheable">cacheable</x:dfn>" to indicate that responses to them are
   allowed to be stored for future reuse; for specific requirements see
   &caching;. In general, safe methods that do not depend on a current or
   authoritative response are defined as cacheable; this specification defines
   GET, HEAD, and POST as cacheable, although the overwhelming majority of 
   cache implementations only support GET and HEAD.
</t>
</section>
</section>

<section title="Method Definitions" anchor="method.definitions">

<section title="GET" anchor="GET">
  <rdf:Description>
    <safe xmlns="urn:ietf:id:draft-ietf-httpbis-p2-semantics#">yes</safe>
    <idempotent xmlns="urn:ietf:id:draft-ietf-httpbis-p2-semantics#">yes</idempotent>
  </rdf:Description>
  <iref primary="true" item="GET method" x:for-anchor=""/>
<t>
   The GET method requests transfer of a current selected representation for
   the <x:ref>target resource</x:ref>. GET is the primary mechanism of
   information retrieval and the focus of almost all performance
   optimizations. Hence, when people speak of retrieving some identifiable
   information via HTTP, they are generally referring to making a GET request.
</t>
<t>
   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of such
   files. In fact, that is how many resources are implemented (see
   <xref target="attack.pathname"/> for related security considerations).
   However, there are no such limitations in practice. The HTTP interface for
   a resource is just as likely to be implemented as a tree of content
   objects, a programmatic view on various database records, or a gateway to
   other information systems. Even when the URI mapping mechanism is tied to a
   file system, an origin server might be configured to execute the files with
   the request as input and send the output as the representation rather than
   transfer the files directly. Regardless, only the origin server needs to
   know how each of its resource identifiers corresponds to an implementation
   and how each implementation manages to select and send a current
   representation of the target resource in a response to GET.
</t>
<t>
   A client can alter the semantics of GET to be a "range request", requesting
   transfer of only some part(s) of the selected representation, by sending a
   <x:ref>Range</x:ref> header field in the request (<xref target="RFC7233"/>).
</t>
<t>
   A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.
</t>
<t>
   The response to a GET request is cacheable; a cache &MAY; use it to satisfy
   subsequent GET and HEAD requests unless otherwise indicated by the
   Cache-Control header field (&header-cache-control;).
</t>
</section>

<section title="HEAD" anchor="HEAD">
  <rdf:Description>
    <safe xmlns="urn:ietf:id:draft-ietf-httpbis-p2-semantics#">yes</safe>
    <idempotent xmlns="urn:ietf:id:draft-ietf-httpbis-p2-semantics#">yes</idempotent>
  </rdf:Description>
  <iref primary="true" item="HEAD method" x:for-anchor=""/>
<t>
   The HEAD method is identical to GET except that the server &MUST-NOT;
   send a message body in the response (i.e., the response terminates at the
   end of the header section). The server &SHOULD; send the same header fields
   in response to a HEAD request as it would have sent if the request had been
   a GET, except that the payload header fields (<xref target="payload"/>)
   &MAY; be omitted. This method can be used for obtaining metadata about the
   selected representation without transferring the representation data and is
   often used for testing hypertext links for validity, accessibility, and
   recent modification.
</t>
<t>
   A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.
</t>
<t>
   The response to a HEAD request is cacheable; a cache &MAY; use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (&header-cache-control;). A HEAD response might
   also have an effect on previously cached responses to GET; see &p6-head;.
</t>
</section>

<section title="POST" anchor="POST">
  <iref primary="true" item="POST method" x:for-anchor=""/>
<t>
   The POST method requests that the <x:ref>target resource</x:ref> process
   the representation enclosed in the request according to the resource's own
   specific semantics. For example, POST is used for the following functions
   (among others):
  <list style="symbols">
    <t>Providing a block of data, such as the fields entered into an HTML
       form, to a data-handling process;</t>
    <t>Posting a message to a bulletin board, newsgroup, mailing list, blog,
       or similar group of articles;</t>
    <t>Creating a new resource that has yet to be identified by the origin
       server; and</t>
    <t>Appending data to a resource's existing representation(s).</t>
  </list>
</t>
<t>
   An origin server indicates response semantics by choosing an appropriate
   status code depending on the result of processing the POST request;
   almost all of the status codes defined by this specification might be
   received in a response to POST (the exceptions being <x:ref>206 (Partial Content)</x:ref>,
   <x:ref>304 (Not Modified)</x:ref>, and <x:ref>416 (Range Not Satisfiable)</x:ref>).
</t>
<t>
   If one or more resources has been created on the origin server as a result
   of successfully processing a POST request, the origin server &SHOULD; send
   a <x:ref>201 (Created)</x:ref> response containing a <x:ref>Location</x:ref>
   header field that provides an identifier for the primary resource created
   (<xref target="header.location"/>) and a representation that describes the
   status of the request while referring to the new resource(s).
</t>
<t>
   Responses to POST requests are only cacheable when they include explicit
   freshness information (see &p6-explicit;). However, POST caching is not
   widely implemented. For cases where an origin server wishes the client to
   be able to cache the result of a POST in a way that can be reused by a
   later GET, the origin server &MAY; send a <x:ref>200 (OK)</x:ref> response
   containing the result and a <x:ref>Content-Location</x:ref> header field
   that has the same value as the POST's effective request URI
   (&header-content-location;).
</t>
<t>
   If the result of processing a POST would be equivalent to a representation
   of an existing resource, an origin server &MAY; redirect the user agent to
   that resource by sending a <x:ref>303 (See Other)</x:ref> response with the
   existing resource's identifier in the <x:ref>Location</x:ref> field.
   This has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to shared
   caching, though at the cost of an extra request if the user agent does not
   already have the representation cached.
</t>
</section>

<section title="PUT" anchor="PUT">
  <rdf:Description>
    <idempotent xmlns="urn:ietf:id:draft-ietf-httpbis-p2-semantics#">yes</idempotent>
  </rdf:Description>
  <iref primary="true" item="PUT method" x:for-anchor=""/>
<t>
   The PUT method requests that the state of the <x:ref>target resource</x:ref>
   be created or replaced with the state defined by the representation
   enclosed in the request message payload.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same target
   resource will result in an equivalent representation being sent in
   a <x:ref>200 (OK)</x:ref> response.  However, there is no guarantee that
   such a state change will be observable, since the target resource might be
   acted upon by other user agents in parallel, or might be subject to dynamic
   processing by the origin server, before any subsequent GET is received.
   A successful response only implies that the user agent's intent was
   achieved at the time of its processing by the origin server.
</t>
<t>   
   If the target resource does not have a current representation and
   the PUT successfully creates one, then the origin server &MUST; inform
   the user agent by sending a <x:ref>201 (Created)</x:ref> response.  If the
   target resource does have a current representation and that representation is
   successfully modified in accordance with the state of the enclosed
   representation, then the origin server &MUST; send either a
   <x:ref>200 (OK)</x:ref> or a <x:ref>204 (No Content)</x:ref> response to
   indicate successful completion of the request.
</t>
<t>
   An origin server &SHOULD; ignore unrecognized header fields received in a
   PUT request (i.e., do not save them as part of the resource state).
</t>
<t>
   An origin server &SHOULD; verify that the PUT representation is
   consistent with any constraints the server has for the target
   resource that cannot or will not be changed by the PUT.  This is
   particularly important when the origin server uses internal
   configuration information related to the URI in order to set the
   values for representation metadata on GET responses.  When a PUT
   representation is inconsistent with the target resource, the origin
   server &SHOULD; either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The
   <x:ref>409 (Conflict)</x:ref> or <x:ref>415 (Unsupported Media Type)</x:ref>
   status codes are suggested, with the latter being specific to constraints on
   <x:ref>Content-Type</x:ref> values.
</t>
<t>
   For example, if the target resource is configured to always have a
   <x:ref>Content-Type</x:ref> of "text/html" and the representation being PUT
   has a Content-Type of "image/jpeg", the origin server ought to do one of:
   <list style="letters">
      <t>reconfigure the target resource to reflect the new media type;</t>
      <t>transform the PUT representation to a format consistent with that
         of the resource before saving it as the new resource state; or,</t>
      <t>reject the request with a <x:ref>415 (Unsupported Media Type)</x:ref>
         response indicating that the target resource is limited to "text/html",
         perhaps including a link to a different resource that would be a
         suitable target for the new representation.</t>
   </list>
</t>
<t>
   HTTP does not define exactly how a PUT method affects the state
   of an origin server beyond what can be expressed by the intent of
   the user agent request and the semantics of the origin server response.
   It does not define what a resource might be, in any sense of that
   word, beyond the interface provided via HTTP.  It does not define
   how resource state is "stored", nor how such storage might change
   as a result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.
</t>
<t>
   An origin server &MUST-NOT; send a validator header field
   (<xref target="response.validator"/>), such as an <x:ref>ETag</x:ref> or
   <x:ref>Last-Modified</x:ref> field, in a successful response to PUT unless
   the request's representation data was saved without any transformation
   applied to the body (i.e., the resource's new representation data is
   identical to the representation data received in the PUT request) and the
   validator field value reflects the new representation.
   This requirement allows a user agent to know when the representation body
   it has in memory remains current as a result of the PUT, thus not in need
   of being retrieved again from the origin server, and that the new validator(s)
   received in the response can be used for future conditional requests in
   order to prevent accidental overwrites (<xref target="request.conditionals"/>).
</t>
<t>
   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource. Hence, the intent of PUT is
   idempotent and visible to intermediaries, even though the exact effect is
   only known by the origin server.
</t>
<t>
   Proper interpretation of a PUT request presumes that the user agent knows
   which target resource is desired. A service that selects a proper URI on
   behalf of the client, after receiving a state-changing request, &SHOULD; be
   implemented using the POST method rather than PUT. If the origin server
   will not make the requested PUT state change to the target resource and
   instead wishes to have it applied to a different resource, such as when the
   resource has been moved to a different URI, then the origin server &MUST;
   send an appropriate <x:ref>3xx (Redirection)</x:ref> response; the
   user agent &MAY; then make its own decision regarding whether or not to
   redirect the request.
</t>
<t>
   A PUT request applied to the target resource can have side effects
   on other resources.  For example, an article might have a URI for
   identifying "the current version" (a resource) that is separate
   from the URIs identifying each particular version (different
   resources that at one point shared the same state as the current version
   resource).  A successful PUT request on "the current version" URI might
   therefore create a new version resource in addition to changing the
   state of the target resource, and might also cause links to be added
   between the related resources.
</t>
<t>
   An origin server that allows PUT on a given target resource &MUST; send a
   <x:ref>400 (Bad Request)</x:ref> response to a PUT request that contains a
   <x:ref>Content-Range</x:ref> header field (&header-content-range;), since
   the payload is likely to be partial content that has been mistakenly PUT as
   a full representation.
   Partial content updates are possible by targeting a separately identified
   resource with state that overlaps a portion of the larger resource, or by
   using a different method that has been specifically defined for partial
   updates (for example, the PATCH method defined in
   <xref target="RFC5789"/>).
</t>
<t>
   Responses to the PUT method are not cacheable. If a successful PUT request
   passes through a cache that has one or more stored responses for the
   effective request URI, those stored responses will be invalidated
   (see &p6-invalid;).
</t>
</section>

<section title="DELETE" anchor="DELETE">
  <rdf:Description>
    <idempotent xmlns="urn:ietf:id:draft-ietf-httpbis-p2-semantics#">yes</idempotent>
  </rdf:Description>
  <iref primary="true" item="DELETE method" x:for-anchor=""/>
<t>
   The DELETE method requests that the origin server remove the association
   between the <x:ref>target resource</x:ref> and its current functionality.
   In effect, this method is similar to the rm command in UNIX: it expresses a
   deletion operation on the URI mapping of the origin server rather than an
   expectation that the previously associated information be deleted.
</t>
<t>
   If the target resource has one or more current representations, they might
   or might not be destroyed by the origin server, and the associated storage
   might or might not be reclaimed, depending entirely on the nature of the
   resource and its implementation by the origin server (which are beyond the
   scope of this specification). Likewise, other implementation aspects of a
   resource might need to be deactivated or archived as a result of a DELETE,
   such as database or gateway connections. In general, it is assumed that the
   origin server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.
</t>
<t>
   Relatively few resources allow the DELETE method &mdash; its primary use
   is for remote authoring environments, where the user has some direction
   regarding its effect. For example, a resource that was previously created
   using a PUT request, or identified via the Location header field after a
   <x:ref>201 (Created)</x:ref> response to a POST request, might allow a
   corresponding DELETE request to undo those actions.  Similarly, custom
   user agent implementations that implement an authoring function, such as
   revision control clients using HTTP for remote operations, might use
   DELETE based on an assumption that the server's URI space has been crafted
   to correspond to a version repository.
</t>
<t>
   If a DELETE method is successfully applied, the origin server &SHOULD; send
   a <x:ref>202 (Accepted)</x:ref> status code if the action will likely succeed but
   has not yet been enacted,
   a <x:ref>204 (No Content)</x:ref> status code if the action has been
   enacted and no further information is to be supplied, or
   a <x:ref>200 (OK)</x:ref> status code if the action has been enacted and
   the response message includes a representation describing the status.
</t>
<t>
   A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.
</t>
<t>
   Responses to the DELETE method are not cacheable. If a DELETE request 
   passes through a cache that has one or more stored responses for the 
   effective request URI, those stored responses will be invalidated (see
   &p6-invalid;).
</t>
</section>

<section title="CONNECT" anchor="CONNECT">
  <iref primary="true" item="CONNECT method" x:for-anchor=""/>
<t>
   The CONNECT method requests that the recipient establish a tunnel to the
   destination origin server identified by the request-target and, if
   successful, thereafter restrict its behavior to blind forwarding of
   packets, in both directions, until the tunnel is closed.
   Tunnels are commonly used to create an end-to-end virtual connection,
   through one or more proxies, which can then be secured using TLS
   (Transport Layer Security, <xref target="RFC5246"/>).
</t>
<t>
   CONNECT is intended only for use in requests to a proxy.
   An origin server that receives a CONNECT request for itself &MAY;
   respond with a <x:ref>2xx (Successful)</x:ref> status code to indicate that a connection
   is established.  However, most origin servers do not implement CONNECT.
</t>
<t>
   A client sending a CONNECT request &MUST; send the authority form of
   request-target (&request-target;); i.e., the request-target consists
   of only the host name and port number of the tunnel destination, separated
   by a colon. For example,
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80

</artwork></figure>
<t>
   The recipient proxy can establish a tunnel either by directly connecting to
   the request-target or, if configured to use another proxy, by forwarding
   the CONNECT request to the next inbound proxy.
   Any <x:ref>2xx (Successful)</x:ref> response indicates
   that the sender (and all inbound proxies) will switch to tunnel mode
   immediately after the blank line that concludes the successful response's
   header section; data received after that blank line is from the server
   identified by the request-target.
   Any response other than a successful response indicates that the tunnel
   has not yet been formed and that the connection remains governed by HTTP.
</t>
<t>
   A tunnel is closed when a tunnel intermediary detects that either side
   has closed its connection: the intermediary &MUST; attempt to send any
   outstanding data that came from the closed side to the other side, close
   both connections, and then discard any remaining data left undelivered.
</t>
<t>
   Proxy authentication might be used to establish the
   authority to create a tunnel.  For example,
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=

</artwork></figure>
<t>
   There are significant risks in establishing a tunnel to arbitrary servers,
   particularly when the destination is a well-known or reserved TCP port that
   is not intended for Web traffic. For example, a CONNECT to a request-target
   of "example.com:25" would suggest that the proxy connect to the reserved
   port for SMTP traffic; if allowed, that could trick the proxy into
   relaying spam email. Proxies that support CONNECT &SHOULD; restrict its
   use to a limited set of known ports or a configurable whitelist of safe
   request targets.
</t>
<t>
   A server &MUST-NOT; send any <x:ref>Transfer-Encoding</x:ref> or
   <x:ref>Content-Length</x:ref> header fields in a
   <x:ref>2xx (Successful)</x:ref> response to CONNECT.
   A client &MUST; ignore any Content-Length or Transfer-Encoding header
   fields received in a successful response to CONNECT.
</t>
<t>
   A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.
</t>
<t>
   Responses to the CONNECT method are not cacheable.
</t>
</section>

<section title="OPTIONS" anchor="OPTIONS">
  <rdf:Description>
    <safe xmlns="urn:ietf:id:draft-ietf-httpbis-p2-semantics#">yes</safe>
    <idempotent xmlns="urn:ietf:id:draft-ietf-httpbis-p2-semantics#">yes</idempotent>
  </rdf:Description>
  <iref primary="true" item="OPTIONS method" x:for-anchor=""/>
<t>
   The OPTIONS method requests information about the communication options
   available for the target resource, at either the origin server or an
   intervening intermediary. This method allows a client to determine the
   options and/or requirements associated with a resource, or the capabilities
   of a server, without implying a resource action.
</t>
<t>
   An OPTIONS request with an asterisk ("*") as the request-target
   (&request-target;) applies to the server in general rather than to a
   specific resource. Since a server's communication options typically depend
   on the resource, the "*" request is only useful as a "ping" or "no-op"
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 conformance (or lack thereof).
</t>
<t>
   If the request-target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.
</t>
<t>
   A server generating a successful response to OPTIONS &SHOULD; send any
   header fields that might indicate optional features implemented by the
   server and applicable to the target resource (e.g., <x:ref>Allow</x:ref>),
   including potential extensions not defined by this specification.
   The response payload, if any, might also describe the communication options
   in a machine or human-readable representation. A standard format for such a
   representation is not defined by this specification, but might be defined by
   future extensions to HTTP.
   A server &MUST; generate a <x:ref>Content-Length</x:ref> field with a value
   of "0" if no payload body is to be sent in the response.
</t>
<t>
   A client &MAY; send a <x:ref>Max-Forwards</x:ref> header field in an
   OPTIONS request to target a specific recipient in the request chain (see
   <xref target="header.max-forwards"/>). A proxy &MUST-NOT; generate a
   Max-Forwards header field while forwarding a request unless that request
   was received with a Max-Forwards field.
</t>
<t>
   A client that generates an OPTIONS request containing a payload body
   &MUST; send a valid <x:ref>Content-Type</x:ref> header field describing
   the representation media type. Although this specification does not define
   any use for such a payload, future extensions to HTTP might use the OPTIONS
   body to make more detailed queries about the target resource.
</t>
<t>
   Responses to the OPTIONS method are not cacheable.
</t>
</section>

<section title="TRACE" anchor="TRACE">
  <rdf:Description>
    <safe xmlns="urn:ietf:id:draft-ietf-httpbis-p2-semantics#">yes</safe>
    <idempotent xmlns="urn:ietf:id:draft-ietf-httpbis-p2-semantics#">yes</idempotent>
  </rdf:Description>
  <iref primary="true" item="TRACE method" x:for-anchor=""/>
<t>
   The TRACE method requests a remote, application-level loop-back of the
   request message. The final recipient of the request &SHOULD; reflect the
   message received, excluding some fields described below, back to the client
   as the message body of a <x:ref>200 (OK)</x:ref> response with a
   <x:ref>Content-Type</x:ref> of "message/http" (&media-type-message-http;).
   The final recipient is either the origin server or the first server to
   receive a <x:ref>Max-Forwards</x:ref> value of zero (0) in the request
   (<xref target="header.max-forwards"/>).
</t>
<t>
   A client &MUST-NOT; generate header fields in a TRACE request containing
   sensitive data that might be disclosed by the response. For example, it
   would be foolish for a user agent to send stored user credentials
   <xref target="RFC7235"/> or cookies <xref target="RFC6265"/> in a TRACE
   request. The final recipient of the request &SHOULD; exclude any request
   header fields that are likely to contain sensitive data when that recipient
   generates the response body.
</t>
<t>
   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the <x:ref>Via</x:ref> header field (&header-via;)
   is of particular interest, since it acts as a trace of the request chain.
   Use of the <x:ref>Max-Forwards</x:ref> header field allows the client to
   limit the length of the request chain, which is useful for testing a chain
   of proxies forwarding messages in an infinite loop.
</t>
<t>
   A client &MUST-NOT; send a message body in a TRACE request.
</t>
<t>
   Responses to the TRACE method are not cacheable.
</t>
</section>
</section>
</section>

<section title="Request Header Fields" anchor="request.header.fields">
  <x:anchor-alias value="request-header"/>
<t>
   A client sends request header fields to provide more information about
   the request context, make the request conditional based on the target
   resource state, suggest preferred formats for the response, supply
   authentication credentials, or modify the expected request processing.
   These fields act as request modifiers, similar to the parameters on a
   programming language method invocation.
</t>
<section title="Controls" anchor="request.controls">
<t>
   Controls are request header fields that direct specific handling of the
   request.
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol>
  <ttcol>Defined in...</ttcol>

  <c>Cache-Control</c> <c>&header-cache-control;</c>
  <c>Expect</c> <c><xref target="header.expect"/></c>
  <c>Host</c> <c>&header-host;</c>
  <c>Max-Forwards</c> <c><xref target="header.max-forwards"/></c>
  <c>Pragma</c> <c>&header-pragma;</c>
  <c>Range</c> <c>&header-range;</c>
  <c>TE</c> <c>&header-te;</c>
</texttable>

<section title="Expect" anchor="header.expect">
  <iref primary="true" item="Expect header field" x:for-anchor=""/>
  <iref primary="true" item="100-continue (expect value)"/>
  <x:anchor-alias value="Expect"/>
  <x:anchor-alias value="expectation"/>
  <x:anchor-alias value="100-continue"/>
<t>
   The "Expect" header field in a request indicates a certain set of
   behaviors (expectations) that need to be supported by the server in
   order to properly handle this request. The only such expectation defined
   by this specification is <x:ref>100-continue</x:ref>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Expect"/>
  <x:ref>Expect</x:ref>  = "100-continue"
</artwork></figure>
<t>
   The Expect field-value is case-insensitive.
</t>
<t>
   A server that receives an Expect field-value other than
   <x:ref>100-continue</x:ref> &MAY; respond with a
   <x:ref>417 (Expectation Failed)</x:ref> status code to indicate that the
   unexpected expectation cannot be met.
</t>
<t>
   A <x:dfn>100-continue</x:dfn> expectation informs recipients that the
   client is about to send a (presumably large) message body in this request
   and wishes to receive a <x:ref>100 (Continue)</x:ref> interim response if
   the request-line and header fields are not sufficient to cause an immediate
   success, redirect, or error response. This allows the client to wait for an
   indication that it is worthwhile to send the message body before actually
   doing so, which can improve efficiency when the message body is huge or
   when the client anticipates that an error is likely (e.g., when sending a
   state-changing method, for the first time, without previously verified
   authentication credentials).
</t>
<t>
   For example, a request that begins with
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
PUT /somewhere/fun HTTP/1.1
Host: origin.example.com
Content-Type: video/h264
Content-Length: 1234567890987
Expect: 100-continue

</artwork></figure>
<t>
   allows the origin server to immediately respond with an error message, such
   as <x:ref>401 (Unauthorized)</x:ref> or <x:ref>405 (Method Not Allowed)</x:ref>,
   before the client starts filling the pipes with an unnecessary data
   transfer.
</t>
<t>
   Requirements for clients:
  <list style="symbols">
    <t>
     A client &MUST-NOT; generate a 100-continue expectation in a request that
     does not include a message body.
    </t>
    <t>
     A client that will wait for a <x:ref>100 (Continue)</x:ref> response
     before sending the request message body &MUST; send an
     <x:ref>Expect</x:ref> header field containing a 100-continue expectation.
    </t>
    <t>
     A client that sends a 100-continue expectation is not required to wait
     for any specific length of time; such a client &MAY; proceed to send the
     message body even if it has not yet received a response. Furthermore,
     since <x:ref>100 (Continue)</x:ref> responses cannot be sent through an
     HTTP/1.0 intermediary, such a client &SHOULD-NOT; wait for an indefinite
     period before sending the message body.
    </t>
    <t>
     A client that receives a <x:ref>417 (Expectation Failed)</x:ref> status
     code in response to a request containing a 100-continue expectation
     &SHOULD; repeat that request without a 100-continue expectation, since
     the 417 response merely indicates that the response chain does not
     support expectations (e.g., it passes through an HTTP/1.0 server).
    </t>
  </list>
</t>
<t>
   Requirements for servers:
  <list style="symbols">
    <t>
     A server that receives a 100-continue expectation in an HTTP/1.0 request
     &MUST; ignore that expectation.
    </t>
    <t>
     A server &MAY; omit sending a <x:ref>100 (Continue)</x:ref> response if
     it has already received some or all of the message body for the
     corresponding request, or if the framing indicates that there is no
     message body.
    </t>
    <t>
     A server that sends a <x:ref>100 (Continue)</x:ref> response &MUST;
     ultimately send a final status code, once the message body is received
     and processed, unless the connection is closed prematurely.
    </t>
    <t>
     A server that responds with a final status code before reading
     the entire message body &SHOULD; indicate in that response whether it
     intends to close the connection or continue reading and discarding the
     request message (see &persistent-tear-down;).
    </t>
  </list>
</t>
<t>
   An origin server &MUST;, upon receiving an HTTP/1.1 (or later) request-line
   and a complete header section that contains a 100-continue expectation and
   indicates a request message body will follow, either send an immediate
   response with a final status code, if that status can be determined by
   examining just the request-line and header fields, or send an immediate
   <x:ref>100 (Continue)</x:ref> response to encourage the client to send the
   request's message body. The origin server &MUST-NOT; wait for the message
   body before sending the <x:ref>100 (Continue)</x:ref> response.
</t>
<t>
   A proxy &MUST;, upon receiving an HTTP/1.1 (or later) request-line
   and a complete header section that contains a 100-continue expectation and
   indicates a request message body will follow, either send an immediate
   response with a final status code, if that status can be determined by
   examining just the request-line and header fields, or begin forwarding the
   request toward the origin server by sending a corresponding request-line
   and header section to the next inbound server. If the proxy believes (from
   configuration or past interaction) that the next inbound server only
   supports HTTP/1.0, the proxy &MAY; generate an immediate
   <x:ref>100 (Continue)</x:ref> response to encourage the client to begin
   sending the message body.
</t>
<x:note>
  <t>
    &Note; The Expect header field was added after the original publication of
    HTTP/1.1 <xref target="RFC2068"/> as both the means to request an interim
    <x:ref>100 (Continue)</x:ref> response and the general mechanism for indicating must-understand
    extensions. However, the extension mechanism has not been used by clients
    and the must-understand requirements have not been implemented by many
    servers, rendering the extension mechanism useless. This specification has
    removed the extension mechanism in order to simplify the definition and
    processing of 100-continue.
  </t>
</x:note>
</section>

<section title="Max-Forwards" anchor="header.max-forwards">
  <iref primary="true" item="Max-Forwards header field" x:for-anchor=""/>
  <x:anchor-alias value="Max-Forwards"/>
<t>
   The "Max-Forwards" header field provides a mechanism with the
   TRACE (<xref target="TRACE"/>) and OPTIONS (<xref target="OPTIONS"/>)
   request methods to limit the number of times that the request is forwarded by
   proxies. This can be useful when the client is attempting to
   trace a request that appears to be failing or looping mid-chain.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Max-Forwards"/>
  <x:ref>Max-Forwards</x:ref> = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message can be forwarded.
</t>
<t>
   Each intermediary that receives a TRACE or OPTIONS request containing a
   Max-Forwards header field &MUST; check and update its value prior to
   forwarding the request. If the received value is zero (0), the intermediary
   &MUST-NOT; forward the request; instead, the intermediary &MUST; respond as
   the final recipient. If the received Max-Forwards value is greater than
   zero, the intermediary &MUST; generate an updated Max-Forwards field in the
   forwarded message with a field-value that is the lesser of a) the received
   value decremented by one (1) or b) the recipient's maximum supported value
   for Max-Forwards.
</t>
<t>
   A recipient &MAY; ignore a Max-Forwards header field received with any
   other request methods.
</t>
</section>
</section>

<section title="Conditionals" anchor="request.conditionals">
  <iref item="conditional request" primary="true"/>
<t>
   The HTTP conditional request header fields <xref target="RFC7232"/> allow a
   client to place a precondition on the state of the target resource, so that
   the action corresponding to the method semantics will not be applied if the
   precondition evaluates to false. Each precondition defined by this
   specification consists of a comparison between a set of validators obtained
   from prior representations of the target resource to the current state of
   validators for the <x:ref>selected representation</x:ref>
   (<xref target="response.validator"/>). Hence, these preconditions evaluate
   whether the state of the target resource has changed since a given state
   known by the client. The effect of such an evaluation depends on the method
   semantics and choice of conditional, as defined in &evaluate-conditional;.
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol>
  <ttcol>Defined in...</ttcol>

  <c>If-Match</c> <c>&header-if-match;</c>
  <c>If-None-Match</c> <c>&header-if-none-match;</c>
  <c>If-Modified-Since</c> <c>&header-if-modified-since;</c>
  <c>If-Unmodified-Since</c> <c>&header-if-unmodified-since;</c>
  <c>If-Range</c> <c>&header-if-range;</c>
</texttable>
</section>

<section title="Content Negotiation" anchor="request.conneg">
<t>
   The following request header fields are sent by a user agent to engage in
   <x:ref>proactive negotiation</x:ref> of the response content, as defined in
   <xref target="proactive.negotiation"/>. The preferences sent in these
   fields apply to any content in the response, including representations of
   the target resource, representations of error or processing status, and
   potentially even the miscellaneous text strings that might appear within
   the protocol.
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol>
  <ttcol>Defined in...</ttcol>

  <c>Accept</c> <c>&header-accept;</c>
  <c>Accept-Charset</c> <c>&header-accept-charset;</c>
  <c>Accept-Encoding</c> <c>&header-accept-encoding;</c>
  <c>Accept-Language</c> <c>&header-accept-language;</c>
</texttable>

<section title="Quality Values" anchor="quality.values">
  <x:anchor-alias value="weight"/>
  <x:anchor-alias value="qvalue"/>
<t>
   Many of the request header fields for <x:ref>proactive negotiation</x:ref>
   use a common parameter, named "q" (case-insensitive), to assign a relative
   "weight" to the preference for that associated kind of content.
   This weight is referred to as a "quality value" (or "qvalue") because
   the same parameter name is often used within server configurations to
   assign a weight to the relative quality of the various representations
   that can be selected for a resource.
</t>
<t>
   The weight is normalized to a real number in the range 0 through 1,
   where 0.001 is the least preferred and 1 is the most preferred;
   a value of 0 means "not acceptable". If no "q" parameter is present,
   the default weight is 1.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="weight"/><iref primary="true" item="Grammar" subitem="qvalue"/>
  <x:ref>weight</x:ref> = <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> "q=" <x:ref>qvalue</x:ref>
  <x:ref>qvalue</x:ref> = ( "0" [ "." 0*3<x:ref>DIGIT</x:ref> ] )
         / ( "1" [ "." 0*3("0") ] )
</artwork></figure>
<t>
   A sender of qvalue &MUST-NOT; generate more than three digits after the
   decimal point. User configuration of these values ought to be limited in
   the same fashion.
</t>
</section>

<section title="Accept" anchor="header.accept">
  <iref primary="true" item="Accept header field" x:for-anchor=""/>
  <x:anchor-alias value="Accept"/>
  <x:anchor-alias value="accept-ext"/>
  <x:anchor-alias value="accept-params"/>
  <x:anchor-alias value="media-range"/>
<t>
   The "Accept" header field can be used by user agents to specify
   response media types that are acceptable. Accept header fields can be used to
   indicate that the request is specifically limited to a small set of desired
   types, as in the case of a request for an in-line image.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept"/><iref primary="true" item="Grammar" subitem="media-range"/><iref primary="true" item="Grammar" subitem="accept-params"/><iref primary="true" item="Grammar" subitem="accept-ext"/>
  <x:ref>Accept</x:ref> = #( <x:ref>media-range</x:ref> [ <x:ref>accept-params</x:ref> ] )
  
  <x:ref>media-range</x:ref>    = ( "*/*"
                   / ( <x:ref>type</x:ref> "/" "*" )
                   / ( <x:ref>type</x:ref> "/" <x:ref>subtype</x:ref> )
                   ) *( <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> <x:ref>parameter</x:ref> )
  <x:ref>accept-params</x:ref>  = <x:ref>weight</x:ref> *( <x:ref>accept-ext</x:ref> )
  <x:ref>accept-ext</x:ref> = <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> <x:ref>token</x:ref> [ "=" ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> ) ]
</artwork></figure>
<t>
   The asterisk "*" character is used to group media types into ranges,
   with "*/*" indicating all media types and "type/*" indicating all
   subtypes of that type. The media-range can include media type
   parameters that are applicable to that range.
</t>
<t>
   Each media-range might be followed by zero or more applicable media type
   parameters (e.g., <x:ref>charset</x:ref>), an optional "q" parameter for
   indicating a relative weight (&qvalue;), and then zero or more extension
   parameters. The "q" parameter is necessary if any extensions (accept-ext) are present,
   since it acts as a separator between the two parameter sets.
</t>
<x:note>
  <t>
    &Note; Use of the "q" parameter name to separate media type
    parameters from Accept extension parameters is due to historical
    practice. Although this prevents any media type parameter named
    "q" from being used with a media range, such an event is believed
    to be unlikely given the lack of any "q" parameters in the IANA
    media type registry and the rare usage of any media type
    parameters in Accept. Future media types are discouraged from
    registering any parameter named "q".
  </t>
</x:note>
<t>
   The example
</t>
<figure><artwork type="example">
  Accept: audio/*; q=0.2, audio/basic
</artwork></figure>
<t>
   is interpreted as "I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% markdown in quality".
</t>
<t>
   A request without any Accept header field implies that the user agent
   will accept any media type in response. If the header field is present in a
   request and none of the available representations for the response have a
   media type that is listed as acceptable, the origin server can either honor
   the header field by sending a <x:ref>406 (Not Acceptable)</x:ref> response
   or disregard the header field by treating the response as if it is not
   subject to content negotiation.
</t>
<t>
   A more elaborate example is
</t>
<figure><artwork type="example">
  Accept: text/plain; q=0.5, text/html,
          text/x-dvi; q=0.8, text/x-c
</artwork></figure>
<t>
   Verbally, this would be interpreted as "text/html and text/x-c are
   the equally preferred media types, but if they do not exist, then send the
   text/x-dvi representation, and if that does not exist, send the text/plain
   representation".
</t>
<t>
   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,
</t>
<figure><artwork type="example">
  Accept: text/*, text/plain, text/plain;format=flowed, */*
</artwork></figure>
<t>
   have the following precedence:
   <list style="numbers">
    <t>text/plain;format=flowed</t>
    <t>text/plain</t>
    <t>text/*</t>
    <t>*/*</t>
   </list>
</t>
<t>
   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   that matches the type. For example,
</t>
<figure><artwork type="example">
  Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
          text/html;level=2;q=0.4, */*;q=0.5
</artwork></figure>
<t>
   would cause the following values to be associated:
</t>
<texttable align="left">
  <ttcol>Media Type</ttcol><ttcol>Quality Value</ttcol>
  <c>text/html;level=1</c>    <c>1</c>
  <c>text/html</c>            <c>0.7</c>
  <c>text/plain</c>           <c>0.3</c>
  <c>image/jpeg</c>           <c>0.5</c>
  <c>text/html;level=2</c>    <c>0.4</c>
  <c>text/html;level=3</c>    <c>0.7</c>
</texttable>
<t>
   &Note; A user agent might be provided with a default set of quality
   values for certain media ranges. However, unless the user agent is
   a closed system that cannot interact with other rendering agents,
   this default set ought to be configurable by the user.
</t>
</section>

<section title="Accept-Charset" anchor="header.accept-charset">
  <iref primary="true" item="Accept-Charset header field" x:for-anchor=""/>
  <x:anchor-alias value="Accept-Charset"/>
<t>
   The "Accept-Charset" header field can be sent by a user agent to
   indicate what charsets are acceptable in textual response content.
   This field allows user agents capable of understanding more comprehensive
   or special-purpose charsets to signal that capability to an origin server
   that is capable of representing information in those charsets.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Charset"/>
  <x:ref>Accept-Charset</x:ref> = 1#( ( <x:ref>charset</x:ref> / "*" ) [ <x:ref>weight</x:ref> ] )
</artwork></figure>
<t>
   Charset names are defined in <xref target="charset"/>.
   A user agent &MAY; associate a quality value with each charset to indicate
   the user's relative preference for that charset, as defined in &qvalue;.
   An example is
</t>
<figure><artwork type="example">
  Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</artwork></figure>
<t>
   The special value "*", if present in the Accept-Charset field,
   matches every charset that is not mentioned elsewhere in the
   Accept-Charset field. If no "*" is present in an Accept-Charset field,
   then any charsets not explicitly mentioned in the field are
   considered "not acceptable" to the client.
</t>
<t>
   A request without any Accept-Charset header field implies that the user
   agent will accept any charset in response. Most general-purpose user agents
   do not send Accept-Charset, unless specifically configured to do so, because
   a detailed list of supported charsets makes it easier for a server to
   identify an individual by virtue of the user agent's request characteristics
   (<xref target="fingerprinting"/>).
</t>
<t>
   If an Accept-Charset header field is present in a request and none of the
   available representations for the response has a charset that is listed as
   acceptable, the origin server can either honor the header field, by sending a
   <x:ref>406 (Not Acceptable)</x:ref> response, or disregard the header field by
   treating the resource as if it is not subject to content negotiation.
</t>
</section>

<section title="Accept-Encoding" anchor="header.accept-encoding">
  <iref primary="true" item="Accept-Encoding header field" x:for-anchor=""/>
  <x:anchor-alias value="Accept-Encoding"/>
  <x:anchor-alias value="codings"/>
<t>
   The "Accept-Encoding" header field can be used by user agents to
   indicate what response content-codings (<xref target="content.codings"/>)
   are acceptable in the response.  An "identity" token is used as a synonym
   for "no encoding" in order to communicate when no encoding is preferred.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Encoding"/><iref primary="true" item="Grammar" subitem="codings"/>
  <x:ref>Accept-Encoding</x:ref>  = #( <x:ref>codings</x:ref> [ <x:ref>weight</x:ref> ] )
  <x:ref>codings</x:ref>          = <x:ref>content-coding</x:ref> / "identity" / "*"
</artwork></figure>
<t>
   Each codings value &MAY; be given an associated quality value
   representing the preference for that encoding, as defined in &qvalue;.
   The asterisk "*" symbol in an Accept-Encoding field matches any available
   content-coding not explicitly listed in the header field.
</t>
<t>
   For example,
</t>
<figure><artwork type="example">
  Accept-Encoding: compress, gzip
  Accept-Encoding:
  Accept-Encoding: *
  Accept-Encoding: compress;q=0.5, gzip;q=1.0
  Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
</artwork></figure>
<t>
   A request without an Accept-Encoding header field implies that the user
   agent has no preferences regarding content-codings. Although this allows
   the server to use any content-coding in a response, it does not imply that
   the user agent will be able to correctly process all encodings.
</t>
<t>
   A server tests whether a content-coding for a given representation is
   acceptable using these rules:
  <list style="numbers">
      <t>If no Accept-Encoding field is in the request, any content-coding is
         considered acceptable by the user agent.</t>

      <t>If the representation has no content-coding, then it is acceptable
         by default unless specifically excluded by the Accept-Encoding field
         stating either "identity;q=0" or "*;q=0" without a more specific
         entry for "identity".</t>

      <t>If the representation's content-coding is one of the content-codings
         listed in the Accept-Encoding field, then it is acceptable unless
         it is accompanied by a qvalue of 0. (As defined in &qvalue;, a
         qvalue of 0 means "not acceptable".)</t>

      <t>If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.</t>
  </list>
</t>
<t>
   An Accept-Encoding header field with a combined field-value that is empty
   implies that the user agent does not want any content-coding in response.
   If an Accept-Encoding header field is present in a request and none of the
   available representations for the response have a content-coding that
   is listed as acceptable, the origin server &SHOULD; send a response
   without any content-coding.
</t>
<x:note>
  <t>
    &Note; Most HTTP/1.0 applications do not recognize or obey qvalues
    associated with content-codings. This means that qvalues might not
    work and are not permitted with x-gzip or x-compress.
  </t>
</x:note>
</section>

<section title="Accept-Language" anchor="header.accept-language">
  <iref primary="true" item="Accept-Language header field" x:for-anchor=""/>
  <x:anchor-alias value="Accept-Language"/>
  <x:anchor-alias value="language-range"/>
<t>
   The "Accept-Language" header field can be used by user agents to
   indicate the set of natural languages that are preferred in the response.
   Language tags are defined in <xref target="language.tags"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Language"/><iref primary="true" item="Grammar" subitem="language-range"/>
  <x:ref>Accept-Language</x:ref> = 1#( <x:ref>language-range</x:ref> [ <x:ref>weight</x:ref> ] )
  <x:ref>language-range</x:ref>  = 
            &lt;language-range, see <xref target="RFC4647" x:fmt="," x:sec="2.1"/>&gt;
</artwork></figure>
<t>
   Each language-range can be given an associated quality value
   representing an estimate of the user's preference for the languages
   specified by that range, as defined in &qvalue;. For example,
</t>
<figure><artwork type="example">
  Accept-Language: da, en-gb;q=0.8, en;q=0.7
</artwork></figure>
<t>
   would mean: "I prefer Danish, but will accept British English and
   other types of English".
</t>
<t>
   A request without any Accept-Language header field implies that the user
   agent will accept any language in response. If the header field is present
   in a request and none of the available representations for the response have
   a matching language tag, the origin server can either disregard the header
   field by treating the response as if it is not subject to content
   negotiation or honor the header field by sending a <x:ref>406 (Not Acceptable)</x:ref>
   response. However, the latter is not encouraged, as doing so can prevent
   users from accessing content that they might be able to use (with
   translation software, for example). 
</t>
<t>
   Note that some recipients treat the order in which language tags are listed
   as an indication of descending priority, particularly for tags that are
   assigned equal quality values (no value is the same as q=1). However, this
   behavior cannot be relied upon. For consistency and to maximize
   interoperability, many user agents assign each language tag a unique
   quality value while also listing them in order of decreasing quality.
   Additional discussion of language priority lists can be found in
   <xref target="RFC4647" x:sec="2.3" x:fmt="of"/>.
</t>
<t>
   For matching, <xref target="RFC4647" x:sec="3" x:fmt="of"/> defines 
   several matching schemes. Implementations can offer the most appropriate
   matching scheme for their requirements. The "Basic Filtering" scheme
   (<xref target="RFC4647" x:fmt="," x:sec="3.3.1"/>) is identical to the
   matching scheme that was previously defined for HTTP in
   <xref target="RFC2616" x:fmt="of" x:sec="14.4"/>.
</t>
<t>
   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic preferences of
   the user in every request (<xref target="fingerprinting"/>).
</t>
<t>
   Since intelligibility is highly dependent on the individual user, user
   agents need to allow user control over the linguistic preference (either
   through configuration of the user agent itself or by defaulting to a user
   controllable system setting).
   A user agent that does not provide such control to the user &MUST-NOT;
   send an Accept-Language header field.
</t>
<x:note>
  <t>
    &Note; User agents ought to provide guidance to users when setting a
    preference, since users are rarely familiar with the details of language
    matching as described above. For example, users might assume that on
    selecting "en-gb", they will be served any kind of English document if
    British English is not available. A user agent might suggest, in such a
    case, to add "en" to the list for better matching behavior.
  </t>
</x:note>
</section>
</section>

<section title="Authentication Credentials" anchor="request.auth">
<t>
   Two header fields are used for carrying authentication credentials, as
   defined in <xref target="RFC7235"/>. Note that various custom mechanisms for
   user authentication use the Cookie header field for this purpose, as
   defined in <xref target="RFC6265"/>.
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol>
  <ttcol>Defined in...</ttcol>

  <c>Authorization</c> <c>&header-authorization;</c>
  <c>Proxy-Authorization</c> <c>&header-proxy-authorization;</c>
</texttable>
</section>

<section title="Request Context" anchor="request.context">
<t>
   The following request header fields provide additional information about the
   request context, including information about the user, user agent, and
   resource behind the request.
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol>
  <ttcol>Defined in...</ttcol>

  <c>From</c> <c><xref target="header.from"/></c>
  <c>Referer</c> <c><xref target="header.referer"/></c>
  <c>User-Agent</c> <c><xref target="header.user-agent"/></c>
</texttable>

<section title="From" anchor="header.from">
  <iref primary="true" item="From header field" x:for-anchor=""/>
  <x:anchor-alias value="From"/>
  <x:anchor-alias value="mailbox"/>
<t>
   The "From" header field contains an Internet email address for a human
   user who controls the requesting user agent. The address ought to be
   machine-usable, as defined by "mailbox"
   in <xref x:sec="3.4" x:fmt="of" target="RFC5322"/>:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="From"/>
  <x:ref>From</x:ref>    = <x:ref>mailbox</x:ref>
  
  <x:ref>mailbox</x:ref> = &lt;mailbox, see <xref x:sec="3.4" x:fmt="," target="RFC5322"/>&gt;
</artwork></figure>
<t>
   An example is:
</t>
<figure><artwork type="example">
  From: webmaster@example.org
</artwork></figure>
<t>
   The From header field is rarely sent by non-robotic user agents.
   A user agent &SHOULD-NOT; send a From header field without explicit
   configuration by the user, since that might conflict with the user's
   privacy interests or their site's security policy.
</t>
<t>
   A robotic user agent &SHOULD; send a valid From header field so that the
   person responsible for running the robot can be contacted if problems
   occur on servers, such as if the robot is sending excessive, unwanted,
   or invalid requests.
</t>
<t>
   A server &SHOULD-NOT; use the From header field for access control or
   authentication, since most recipients will assume that the field value is
   public information.
</t>
</section>

<section title="Referer" anchor="header.referer">
  <iref primary="true" item="Referer header field" x:for-anchor=""/>
  <x:anchor-alias value="Referer"/>
<t>
   The "Referer" [sic] header field allows the user agent to specify a URI
   reference for the resource from which the <x:ref>target URI</x:ref> was
   obtained (i.e., the "referrer", though the field name is misspelled).
   A user agent &MUST-NOT; include the fragment and userinfo components
   of the URI reference <xref target="RFC3986"/>, if any, when generating the
   Referer field value.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Referer"/>
  <x:ref>Referer</x:ref> = <x:ref>absolute-URI</x:ref> / <x:ref>partial-URI</x:ref>
</artwork></figure>
<t>
   The Referer header field allows servers to generate back-links to other
   resources for simple analytics, logging, optimized caching, etc. It also
   allows obsolete or mistyped links to be found for maintenance. Some servers
   use the Referer header field as a means of denying links from other sites
   (so-called "deep linking") or restricting cross-site request forgery (CSRF),
   but not all requests contain it.
</t>
<t>
   Example:
</t>
<figure><artwork type="example">
  Referer: http://www.example.org/hypertext/Overview.html
</artwork></figure>
<t>
   If the target URI was obtained from a source that does not have its own
   URI (e.g., input from the user keyboard, or an entry within the user's
   bookmarks/favorites), the user agent &MUST; either exclude the Referer field
   or send it with a value of "about:blank".
</t>
<t>
   The Referer field has the potential to reveal information about the request
   context or browsing history of the user, which is a privacy concern if the
   referring resource's identifier reveals personal information (such as an
   account name) or a resource that is supposed to be confidential (such as
   behind a firewall or internal to a secured service). Most general-purpose
   user agents do not send the Referer header field when the referring
   resource is a local "file" or "data" URI. A user agent &MUST-NOT; send a
   <x:ref>Referer</x:ref> header field in an unsecured HTTP request if the
   referring page was received with a secure protocol.
   See <xref target="sensitive.information.in.uris"/> for additional
   security considerations.
</t>
<t>
   Some intermediaries have been known to indiscriminately remove Referer
   header fields from outgoing requests. This has the unfortunate side effect
   of interfering with protection against CSRF attacks, which can be far
   more harmful to their users. Intermediaries and user agent extensions that
   wish to limit information disclosure in Referer ought to restrict their
   changes to specific edits, such as replacing internal domain names with
   pseudonyms or truncating the query and/or path components.
   An intermediary &SHOULD-NOT; modify or delete the Referer header field when
   the field value shares the same scheme and host as the request target.
</t>
</section>

<section title="User-Agent" anchor="header.user-agent">
  <iref primary="true" item="User-Agent header field" x:for-anchor=""/>
  <x:anchor-alias value="User-Agent"/>
  <x:anchor-alias value="product"/>
  <x:anchor-alias value="product-version"/>
<t>
   The "User-Agent" header field contains information about the user agent
   originating the request, which is often used by servers to help identify
   the scope of reported interoperability problems, to work around or tailor
   responses to avoid particular user agent limitations, and for analytics
   regarding browser or operating system use. A user agent &SHOULD; send
   a User-Agent field in each request unless specifically configured not
   to do so.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="User-Agent"/>
  <x:ref>User-Agent</x:ref> = <x:ref>product</x:ref> *( <x:ref>RWS</x:ref> ( <x:ref>product</x:ref> / <x:ref>comment</x:ref> ) )
</artwork></figure>
<t>
   The User-Agent field-value consists of one or more product identifiers,
   each followed by zero or more comments (&header-fields;), which together
   identify the user agent software and its significant subproducts.
   By convention, the product identifiers are listed in decreasing order of
   their significance for identifying the user agent software. Each product
   identifier consists of a name and optional version.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="product"/><iref primary="true" item="Grammar" subitem="product-version"/>
  <x:ref>product</x:ref>         = <x:ref>token</x:ref> ["/" <x:ref>product-version</x:ref>]
  <x:ref>product-version</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
   A sender &SHOULD; limit generated product identifiers to what is necessary
   to identify the product; a sender &MUST-NOT; generate advertising or other
   nonessential information within the product identifier.
   A sender &SHOULD-NOT; generate information in <x:ref>product-version</x:ref>
   that is not a version identifier (i.e., successive versions of the same
   product name ought to differ only in the product-version portion of the
   product identifier).
</t>
<t>
   Example:
</t>
<figure><artwork type="example">
  User-Agent: CERN-LineMode/2.15 libwww/2.17b3
</artwork></figure>
<t>
   A user agent &SHOULD-NOT; generate a User-Agent field containing needlessly
   fine-grained detail and &SHOULD; limit the addition of subproducts by third
   parties. Overly long and detailed User-Agent field values increase request
   latency and the risk of a user being identified against their wishes
   ("fingerprinting").
</t>
<t>
   Likewise, implementations are encouraged not to use the product tokens of
   other implementations in order to declare compatibility with them, as this
   circumvents the purpose of the field. If a user agent masquerades as a
   different user agent, recipients can assume that the user intentionally
   desires to see responses tailored for that identified user agent, even
   if they might not work as well for the actual user agent being used.
</t>
</section>
</section>
</section>

<section title="Response Status Codes" anchor="status.codes">
<t>
   The status-code element is a three-digit integer code giving the result of the
   attempt to understand and satisfy the request.
</t>
<t>
   HTTP status codes are extensible. HTTP clients are not required
   to understand the meaning of all registered status codes, though such
   understanding is obviously desirable. However, a client &MUST;
   understand the class of any status code, as indicated by the first
   digit, and treat an unrecognized status code as being equivalent to the
   x00 status code of that class, with the exception that
   a recipient &MUST-NOT; cache a response with an unrecognized status code.
</t>
<t>
   For example, if an unrecognized status code of 471 is received by a client,
   the client can assume that there was something wrong with its request and
   treat the response as if it had received a <x:ref>400 (Bad Request)</x:ref> status code. The response
   message will usually contain a representation that explains the status.
</t>
<t>
   The first digit of the status-code defines the class of response. The
   last two digits do not have any categorization role. There are five
   values for the first digit:
  <list style="symbols">
    <t>
      <x:ref>1xx (Informational)</x:ref>: The request was received, continuing
      process
    </t>
    <t>
      <x:ref>2xx (Successful)</x:ref>: The request was successfully received,
      understood, and accepted
    </t>
    <t>
      <x:ref>3xx (Redirection)</x:ref>: Further action needs to be taken in order to
      complete the request
    </t>
    <t>
      <x:ref>4xx (Client Error)</x:ref>: The request contains bad syntax or cannot
      be fulfilled
    </t>
    <t>
      <x:ref>5xx (Server Error)</x:ref>: The server failed to fulfill an apparently
      valid request
    </t>
  </list>
</t>

<section title="Overview of Status Codes" anchor="overview.of.status.codes">
<t>  
   The status codes listed below are defined in this specification,
   &p4-status-codes;, &p5-status-codes;, and &p7-status-codes;.
   The reason phrases listed here are only recommendations &mdash; they can be
   replaced by local equivalents without affecting the protocol.
</t>
<t>
   Responses with status codes that are defined as cacheable by default
   (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in this
   specification) can be reused by a cache with heuristic expiration unless
   otherwise indicated by the method definition or explicit cache controls
   &caching;; all other status codes are not cacheable by default.
</t>
<texttable align="left">
  <ttcol>Code</ttcol>
  <ttcol>Reason-Phrase</ttcol>
  <ttcol>Defined in...</ttcol>
  
  <c>100</c> <c>Continue</c> <c><xref target="status.100"/></c>
  <c>101</c> <c>Switching Protocols</c> <c><xref target="status.101"/></c>

  <c>200</c> <c>OK</c> <c><xref target="status.200"/></c>
  <c>201</c> <c>Created</c> <c><xref target="status.201"/></c>
  <c>202</c> <c>Accepted</c> <c><xref target="status.202"/></c>
  <c>203</c> <c>Non-Authoritative Information</c> <c><xref target="status.203"/></c>
  <c>204</c> <c>No Content</c> <c><xref target="status.204"/></c>
  <c>205</c> <c>Reset Content</c> <c><xref target="status.205"/></c>
  <c>206</c> <c>Partial Content</c> <c anchor="status.206">&status-206;</c>

  <c>300</c> <c>Multiple Choices</c> <c><xref target="status.300"/></c>
  <c>301</c> <c>Moved Permanently</c> <c><xref target="status.301"/></c>
  <c>302</c> <c>Found</c> <c><xref target="status.302"/></c>
  <c>303</c> <c>See Other</c> <c><xref target="status.303"/></c>
  <c>304</c> <c>Not Modified</c> <c anchor="status.304">&status-304;</c>
  <c>305</c> <c>Use Proxy</c> <c><xref target="status.305"/></c>
  <c>307</c> <c>Temporary Redirect</c> <c><xref target="status.307"/></c>

  <c>400</c> <c>Bad Request</c> <c><xref target="status.400"/></c>
  <c>401</c> <c>Unauthorized</c> <c anchor="status.401">&status-401;</c>
  <c>402</c> <c>Payment Required</c> <c><xref target="status.402"/></c>
  <c>403</c> <c>Forbidden</c> <c><xref target="status.403"/></c>
  <c>404</c> <c>Not Found</c> <c><xref target="status.404"/></c>
  <c>405</c> <c>Method Not Allowed</c> <c><xref target="status.405"/></c>
  <c>406</c> <c>Not Acceptable</c> <c><xref target="status.406"/></c>
  <c>407</c> <c>Proxy Authentication Required</c> <c anchor="status.407">&status-407;</c>
  <c>408</c> <c>Request Timeout</c> <c><xref target="status.408"/></c>
  <c>409</c> <c>Conflict</c> <c><xref target="status.409"/></c>
  <c>410</c> <c>Gone</c> <c><xref target="status.410"/></c>
  <c>411</c> <c>Length Required</c> <c><xref target="status.411"/></c>
  <c>412</c> <c>Precondition Failed</c> <c anchor="status.412">&status-412;</c>
  <c>413</c> <c>Payload Too Large</c> <c><xref target="status.413"/></c>
  <c>414</c> <c>URI Too Long</c> <c><xref target="status.414"/></c>
  <c>415</c> <c>Unsupported Media Type</c> <c><xref target="status.415"/></c>
  <c>416</c> <c>Range Not Satisfiable</c> <c anchor="status.416">&status-416;</c>
  <c>417</c> <c>Expectation Failed</c> <c><xref target="status.417"/></c>
  <c>426</c> <c>Upgrade Required</c> <c><xref target="status.426"/></c>

  <c>500</c> <c>Internal Server Error</c> <c><xref target="status.500"/></c>
  <c>501</c> <c>Not Implemented</c> <c><xref target="status.501"/></c>
  <c>502</c> <c>Bad Gateway</c> <c><xref target="status.502"/></c>
  <c>503</c> <c>Service Unavailable</c> <c><xref target="status.503"/></c>
  <c>504</c> <c>Gateway Timeout</c> <c><xref target="status.504"/></c>
  <c>505</c> <c>HTTP Version Not Supported</c> <c><xref target="status.505"/></c>
</texttable>
<t>
   Note that this list is not exhaustive &mdash; it does not include
   extension status codes defined in other specifications. The
   complete list of status codes is maintained by IANA. See
   <xref target="status.code.registry"/> for details.
</t>
</section>

<section title="Informational 1xx" anchor="status.1xx">
  <x:anchor-alias value="1xx"/>
  <x:anchor-alias value="1xx (Informational)"/>
  <iref primary="true" item="1xx Informational (status code class)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes Classes" subitem="1xx Informational" x:for-anchor=""/>
<t>
   The <x:dfn>1xx (Informational)</x:dfn> class of status code indicates an
   interim response for communicating connection status or request progress
   prior to completing the requested action and sending a final response.
   1xx responses are terminated by the first empty line after the
   status-line (the empty line signaling the end of the header section).
   Since HTTP/1.0 did not define any 1xx status codes, a server &MUST-NOT; send
   a 1xx response to an HTTP/1.0 client.
</t>
<t>
   A client &MUST; be able to parse one or more 1xx responses received
   prior to a final response, even if the client does not expect one.
   A user agent &MAY; ignore unexpected 1xx responses.
</t>
<t>
   A proxy &MUST; forward 1xx responses unless the proxy itself
   requested the generation of the 1xx response. For example, if a
   proxy adds an "Expect: 100-continue" field when it forwards a request,
   then it need not forward the corresponding <x:ref>100 (Continue)</x:ref>
   response(s).
</t>

<section title="100 Continue" anchor="status.100">
  <iref primary="true" item="100 Continue (status code)" x:for-anchor=""/>
  <x:anchor-alias value="100 (Continue)"/>
<t>
   The <x:dfn>100 (Continue)</x:dfn> status code indicates that the initial
   part of a request has been received and has not yet been rejected by the
   server. The server intends to send a final response after the request has
   been fully received and acted upon.
</t>
<t>
   When the request contains an <x:ref>Expect</x:ref> header field that
   includes a <x:ref>100-continue</x:ref> expectation, the 100 response
   indicates that the server wishes to receive the request payload body,
   as described in <xref target="header.expect"/>.  The client
   ought to continue sending the request and discard the 100 response.
</t>
<t>
   If the request did not contain an <x:ref>Expect</x:ref> header field
   containing the <x:ref>100-continue</x:ref> expectation,
   the client can simply discard this interim response.
</t>
</section>

<section title="101 Switching Protocols" anchor="status.101">
  <iref primary="true" item="101 Switching Protocols (status code)" x:for-anchor=""/>
  <x:anchor-alias value="101 (Switching Protocols)"/>
<t>
   The <x:dfn>101 (Switching Protocols)</x:dfn> status code indicates that the
   server understands and is willing to comply with the client's request,
   via the <x:ref>Upgrade</x:ref> header field (&header-upgrade;), for
   a change in the application protocol being used on this connection.
   The server &MUST; generate an Upgrade header field in the response that
   indicates which protocol(s) will be switched to immediately after the empty
   line that terminates the 101 response.
</t>
<t>
   It is assumed that the server will only agree to switch protocols when
   it is advantageous to do so. For example, switching to a newer version of
   HTTP might be advantageous over older versions, and switching to a
   real-time, synchronous protocol might be advantageous when delivering
   resources that use such features.
</t>
</section>
</section>

<section title="Successful 2xx" anchor="status.2xx">
  <x:anchor-alias value="2xx"/>
  <x:anchor-alias value="2xx (Successful)"/>
  <iref primary="true" item="2xx Successful (status code class)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes Classes" subitem="2xx Successful" x:for-anchor=""/>
<t>
   The <x:dfn>2xx (Successful)</x:dfn> class of status code indicates that
   the client's request was successfully received, understood, and accepted.
</t>

<section title="200 OK" anchor="status.200">
  <iref primary="true" item="200 OK (status code)" x:for-anchor=""/>
  <x:anchor-alias value="200 (OK)"/>
<t>
   The <x:dfn>200 (OK)</x:dfn> status code indicates that the request has
   succeeded. The payload sent in a 200 response depends on the request
   method. For the methods defined by this specification, the intended meaning
   of the payload can be summarized as:
  <list style="hanging">
    <t hangText="GET">
      a representation of the <x:ref>target resource</x:ref>;
    </t>
    <t hangText="HEAD">
      the same representation as GET, but without the representation data;
    </t>
    <t hangText="POST">
      a representation of the status of, or results obtained from, the action;
    </t>
    <t hangText="PUT, DELETE">
      a representation of the status of the action;
    </t>
    <t hangText="OPTIONS">
      a representation of the communications options;
    </t>
    <t hangText="TRACE">
      a representation of the request message as received by the
      end server.
    </t>
  </list>
</t>
<t>
   Aside from responses to CONNECT, a 200 response always has a payload,
   though an origin server &MAY; generate a payload body of zero length.
   If no payload is desired, an origin server ought to send
   <x:dfn>204 (No Content)</x:dfn> instead.
   For CONNECT, no payload is allowed because the successful result is a
   tunnel, which begins immediately after the 200 response header section.
</t>
<t>
   A 200 response is cacheable by default; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see &p6-heuristic;).
</t>
</section>

<section title="201 Created" anchor="status.201">
  <iref primary="true" item="201 Created (status code)" x:for-anchor=""/>
  <x:anchor-alias value="201 (Created)"/>
<t>
   The <x:dfn>201 (Created)</x:dfn> status code indicates that the request has
   been fulfilled and has resulted in one or more new resources being created.
   The primary resource created by the request is identified by either a
   <x:ref>Location</x:ref> header field in the response or, if no
   <x:ref>Location</x:ref> field is received, by the effective request URI.
</t>
<t>
   The 201 response payload typically describes and links to the resource(s)
   created. See <xref target="response.validator"/> for a discussion of the
   meaning and purpose of validator header fields, such as
   <x:ref>ETag</x:ref> and <x:ref>Last-Modified</x:ref>, in a 201 response.
</t>
</section>

<section title="202 Accepted" anchor="status.202">
  <iref primary="true" item="202 Accepted (status code)" x:for-anchor=""/>
  <x:anchor-alias value="202 (Accepted)"/>
<t>
   The <x:dfn>202 (Accepted)</x:dfn> status code indicates that the request
   has been accepted for processing, but the processing has not been
   completed. The request might or might not eventually be acted upon, as it
   might be disallowed when processing actually takes place. There is no
   facility in HTTP for re-sending a status code from an asynchronous
   operation.
</t>
<t>
   The 202 response is intentionally noncommittal. Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed. The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an estimate of
   when the request will be fulfilled.
</t>
</section>

<section title="203 Non-Authoritative Information" anchor="status.203">
  <iref primary="true" item="203 Non-Authoritative Information (status code)" x:for-anchor=""/>
  <x:anchor-alias value="203 (Non-Authoritative Information)"/>
<t>
   The <x:dfn>203 (Non-Authoritative Information)</x:dfn> status code
   indicates that the request was successful but the enclosed payload has been
   modified from that of the origin server's <x:ref>200 (OK)</x:ref> response
   by a transforming proxy (&transformations;). This status code allows the
   proxy to notify recipients when a transformation has been applied, since
   that knowledge might impact later decisions regarding the content. For
   example, future cache validation requests for the content might only be
   applicable along the same request path (through the same proxies).
</t>
<t>
   The 203 response is similar to the Warning code of 214 Transformation
   Applied (&header-warning;), which has the advantage of being applicable
   to responses with any status code.
</t>
<t>
   A 203 response is cacheable by default; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see &p6-heuristic;).
</t>
</section>

<section title="204 No Content" anchor="status.204">
  <iref primary="true" item="204 No Content (status code)" x:for-anchor=""/>
  <x:anchor-alias value="204 (No Content)"/>
<t>
   The <x:dfn>204 (No Content)</x:dfn> status code indicates that the server
   has successfully fulfilled the request and that there is no additional
   content to send in the response payload body. Metadata in the response
   header fields refer to the <x:ref>target resource</x:ref> and its
   <x:ref>selected representation</x:ref> after the requested action was applied.
</t>
<t>
   For example, if a 204 status code is received in response to a PUT
   request and the response contains an <x:ref>ETag</x:ref> header field, then
   the PUT was successful and the ETag field-value contains the entity-tag for
   the new representation of that target resource.
</t>
<t>
   The 204 response allows a server to indicate that the action has been
   successfully applied to the target resource, while implying that the
   user agent does not need to traverse away from its current "document view"
   (if any).  The server assumes that the user agent will provide some
   indication of the success to its user, in accord with its own interface,
   and apply any new or updated metadata in the response to its active
   representation.
</t>
<t>
   For example, a 204 status code is commonly used with document editing
   interfaces corresponding to a "save" action, such that the document
   being saved remains available to the user for editing. It is also
   frequently used with interfaces that expect automated data transfers
   to be prevalent, such as within distributed version control systems.
</t>
<t>
   A 204 response is terminated by the first empty line after the header
   fields because it cannot contain a message body.
</t>
<t>
   A 204 response is cacheable by default; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see &p6-heuristic;).
</t>
</section>

<section title="205 Reset Content" anchor="status.205">
  <iref primary="true" item="205 Reset Content (status code)" x:for-anchor=""/>
<t>
   The <x:dfn>205 (Reset Content)</x:dfn> status code indicates that the
   server has fulfilled the request and desires that the user agent reset the
   "document view", which caused the request to be sent, to its original state
   as received from the origin server.
</t>
<t>   
   This response is intended to support a common data entry use case where
   the user receives content that supports data entry (a form, notepad,
   canvas, etc.), enters or manipulates data in that space, causes the entered
   data to be submitted in a request, and then the data entry mechanism is
   reset for the next entry so that the user can easily initiate another
   input action.
</t>
<t>
   Since the 205 status code implies that no additional content will be
   provided, a server &MUST-NOT; generate a payload in a 205 response.
   In other words, a server &MUST; do one of the following for a 205 response:
   a) indicate a zero-length body for the response by including a
   <x:ref>Content-Length</x:ref> header field with a value of 0;
   b) indicate a zero-length payload for the response by including a
   <x:ref>Transfer-Encoding</x:ref> header field with a value of chunked and
   a message body consisting of a single chunk of zero-length; or,
   c) close the connection immediately after sending the blank line
   terminating the header section.
</t>
</section>
</section>

<section title="Redirection 3xx" anchor="status.3xx">
  <x:anchor-alias value="3xx"/>
  <x:anchor-alias value="3xx (Redirection)"/>
  <iref primary="true" item="3xx Redirection (status code class)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes Classes" subitem="3xx Redirection" x:for-anchor=""/>
<t>
   The <x:dfn>3xx (Redirection)</x:dfn> class of status code indicates that
   further action needs to be taken by the user agent in order to fulfill the
   request. If a <x:ref>Location</x:ref> header field
   (<xref target="header.location"/>) is provided, the user agent &MAY;
   automatically redirect its request to the URI referenced by the Location
   field value, even if the specific status code is not understood.
   Automatic redirection needs to done with care for methods not known to be
   <x:ref>safe</x:ref>, as defined in <xref target="safe.methods"/>, since
   the user might not wish to redirect an unsafe request.
</t>
<t>
   There are several types of redirects:
   <list style="numbers">
      <x:lt>
        <t>
          Redirects that indicate the resource might be available at a
          different URI, as provided by the <x:ref>Location</x:ref> field,
          as in the status codes <x:ref>301 (Moved Permanently)</x:ref>,
          <x:ref>302 (Found)</x:ref>, and
          <x:ref>307 (Temporary Redirect)</x:ref>.
        </t>
      </x:lt>
      <x:lt>
        <t>
          Redirection that offers a choice of matching resources, each capable
          of representing the original request target, as in the
          <x:ref>300 (Multiple Choices)</x:ref> status code.
        </t>
      </x:lt>
      <x:lt>
        <t>
          Redirection to a different resource, identified by the
          <x:ref>Location</x:ref> field, that can represent an indirect
          response to the request, as in the <x:ref>303 (See Other)</x:ref>
          status code.
        </t>
      </x:lt>
      <x:lt>
        <t>
          Redirection to a previously cached result, as in the
          <x:ref>304 (Not Modified)</x:ref> status code.
        </t>
      </x:lt>
   </list>
</t>
<x:note>
  <t>
    &Note; In HTTP/1.0, the status codes <x:ref>301 (Moved Permanently)</x:ref>
    and <x:ref>302 (Found)</x:ref> were defined for the first type of redirect
    (<xref target="RFC1945" x:fmt="," x:sec="9.3"/>). Early user agents split
    on whether the method applied to the redirect target would be the same as
    the original request or would be rewritten as GET. Although HTTP
    originally defined the former semantics for <x:ref>301</x:ref> and
    <x:ref>302</x:ref> (to match its original implementation at CERN), and
    defined <x:ref>303 (See Other)</x:ref> to match the latter semantics,
    prevailing practice gradually converged on the latter semantics for
    <x:ref>301</x:ref> and <x:ref>302</x:ref> as well. The first revision of
    HTTP/1.1 added <x:ref>307 (Temporary Redirect)</x:ref> to indicate the
    former semantics without being impacted by divergent practice.
    Over 10 years later, most user agents still do method rewriting for
    <x:ref>301</x:ref> and <x:ref>302</x:ref>; therefore, this specification
    makes that behavior conformant when the original request is POST.
  </t>
</x:note>
<t>
   A client &SHOULD; detect and intervene in cyclical redirections (i.e.,
   "infinite" redirection loops).
</t>
<x:note>
  <t>
    &Note; An earlier version of this specification recommended a
    maximum of five redirections (<xref target="RFC2068" x:fmt="," x:sec="10.3"/>).
    Content developers need to be aware that some clients might
    implement such a fixed limitation.
  </t>
</x:note>

<section title="300 Multiple Choices" anchor="status.300">
  <iref primary="true" item="300 Multiple Choices (status code)" x:for-anchor=""/>
  <x:anchor-alias value="300 (Multiple Choices)"/>
<t>
   The <x:dfn>300 (Multiple Choices)</x:dfn> status code indicates that the
   <x:ref>target resource</x:ref> has more than one representation, each with
   its own more specific identifier, and information about the alternatives is
   being provided so that the user (or user agent) can select a preferred
   representation by redirecting its request to one or more of those
   identifiers. In other words, the server desires that the user agent engage
   in reactive negotiation to select the most appropriate representation(s)
   for its needs (&content-negotiation;).
</t>
<t>
   If the server has a preferred choice, the server &SHOULD; generate a
   <x:ref>Location</x:ref> header field containing a preferred choice's URI
   reference. The user agent &MAY; use the Location field value for automatic
   redirection.
</t>
<t>
   For request methods other than HEAD, the server &SHOULD; generate a payload
   in the 300 response containing a list of representation metadata and URI
   reference(s) from which the user or user agent can choose the one most
   preferred. The user agent &MAY; make a selection from that list
   automatically if it understands the provided media type. A specific format
   for automatic selection is not defined by this specification because HTTP
   tries to remain orthogonal to the definition of its payloads.
   In practice, the representation is provided in some easily parsed format
   believed to be acceptable to the user agent, as determined by shared design
   or content negotiation, or in some commonly accepted hypertext format.
</t>
<t>
   A 300 response is cacheable by default; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see &p6-heuristic;).
</t>
<x:note>
  <t>
   &Note; The original proposal for the 300 status code defined the URI header field as
   providing a list of alternative representations, such that it would be
   usable for 200, 300, and 406 responses and be transferred in responses to
   the HEAD method. However, lack of deployment and disagreement over syntax
   led to both URI and Alternates (a subsequent proposal) being dropped from
   this specification. It is possible to communicate the list using a set of
   Link header fields <xref target="RFC5988"/>, each with a relationship of
   "alternate", though deployment is a chicken-and-egg problem.
  </t>
</x:note>
</section>

<section title="301 Moved Permanently" anchor="status.301">
  <iref primary="true" item="301 Moved Permanently (status code)" x:for-anchor=""/>
  <x:anchor-alias value="301"/>
  <x:anchor-alias value="301 (Moved Permanently)"/>
<t>
   The <x:dfn>301 (Moved Permanently)</x:dfn> status code indicates that the
   <x:ref>target resource</x:ref> has been assigned a new permanent URI and
   any future references to this resource ought to use one of the enclosed
   URIs. Clients with link-editing capabilities ought to automatically re-link
   references to the effective request URI to one or more of the new
   references sent by the server, where possible.
</t>
<t>
   The server &SHOULD; generate a <x:ref>Location</x:ref> header field in the
   response containing a preferred URI reference for the new permanent URI.
   The user agent &MAY; use the Location field value for automatic redirection.
   The server's response payload usually contains a short hypertext note with
   a hyperlink to the new URI(s).
</t>
<x:note>
  <t>
    &Note; For historical reasons, a user agent &MAY; change the
    request method from POST to GET for the subsequent request. If this
    behavior is undesired, the <x:ref>307 (Temporary Redirect)</x:ref>
    status code can be used instead.
  </t>
</x:note>
<t>
   A 301 response is cacheable by default; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see &p6-heuristic;).
</t>
</section>

<section title="302 Found" anchor="status.302">
  <iref primary="true" item="302 Found (status code)" x:for-anchor=""/>
  <x:anchor-alias value="302"/>
  <x:anchor-alias value="302 (Found)"/>
<t>
   The <x:dfn>302 (Found)</x:dfn> status code indicates that the target
   resource resides temporarily under a different URI. Since the redirection
   might be altered on occasion, the client ought to continue to use the
   effective request URI for future requests.
</t>
<t>
   The server &SHOULD; generate a <x:ref>Location</x:ref> header field in the
   response containing a URI reference for the different URI.
   The user agent &MAY; use the Location field value for automatic redirection.
   The server's response payload usually contains a short hypertext note with
   a hyperlink to the different URI(s).
</t>
<x:note>
  <t>
    &Note; For historical reasons, a user agent &MAY; change the
    request method from POST to GET for the subsequent request. If this
    behavior is undesired, the <x:ref>307 (Temporary Redirect)</x:ref>
    status code can be used instead.
  </t>
</x:note>
</section>

<section title="303 See Other" anchor="status.303">
  <iref primary="true" item="303 See Other (status code)" x:for-anchor=""/>
  <x:anchor-alias value="303 (See Other)"/>
<t>
   The <x:dfn>303 (See Other)</x:dfn> status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a URI
   in the <x:ref>Location</x:ref> header field, which is intended to provide
   an indirect response to the original request. A user agent can perform a
   retrieval request targeting that URI (a GET or HEAD request if using HTTP),
   which might also be redirected, and present the eventual result as an
   answer to the original request. Note that the new URI in the Location
   header field is not considered equivalent to the effective request URI.
</t>
<t>
   This status code is applicable to any HTTP method.  It is
   primarily used to allow the output of a POST action to redirect
   the user agent to a selected resource, since doing so provides the
   information corresponding to the POST response in a form that
   can be separately identified, bookmarked, and cached, independent
   of the original request.
</t>
<t>
   A 303 response to a GET request indicates that the origin server does not
   have a representation of the <x:ref>target resource</x:ref> that can be
   transferred by the server over HTTP. However, the
   <x:ref>Location</x:ref> field value refers to a resource that is
   descriptive of the target resource, such that making a retrieval request
   on that other resource might result in a representation that is useful to
   recipients without implying that it represents the original target resource.
   Note that answers to the questions of what can be represented, what
   representations are adequate, and what might be a useful description are
   outside the scope of HTTP.
</t>
<t>
   Except for responses to a HEAD request, the representation of a 303 
   response ought to contain a short hypertext note with a hyperlink to the
   same URI reference provided in the <x:ref>Location</x:ref> header field.
</t>
</section>

<section title="305 Use Proxy" anchor="status.305">
  <iref primary="true" item="305 Use Proxy (status code)" x:for-anchor=""/>
  <x:anchor-alias value="305 (Use Proxy)"/>
<t>
   The <x:dfn>305 (Use Proxy)</x:dfn> status code was defined in a previous
   version of this specification and is now deprecated
   (<xref target="changes.from.rfc.2616"/>).
</t>
</section>

<section title="306 (Unused)" anchor="status.306">
  <iref primary="true" item="306 (Unused) (status code)" x:for-anchor=""/>
<t>
   The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.
</t>
</section>

<section title="307 Temporary Redirect" anchor="status.307">
  <iref primary="true" item="307 Temporary Redirect (status code)" x:for-anchor=""/>
  <x:anchor-alias value="307"/>
  <x:anchor-alias value="307 (Temporary Redirect)"/>
<t>
   The <x:dfn>307 (Temporary Redirect)</x:dfn> status code indicates that the
   <x:ref>target resource</x:ref> resides temporarily under a different URI
   and the user agent &MUST-NOT; change the request method if it performs an
   automatic redirection to that URI.
   Since the redirection can change over time, the client ought to continue
   using the original effective request URI for future requests.
</t>
<t>
   The server &SHOULD; generate a <x:ref>Location</x:ref> header field in the
   response containing a URI reference for the different URI.
   The user agent &MAY; use the Location field value for automatic redirection.
   The server's response payload usually contains a short hypertext note with
   a hyperlink to the different URI(s).
</t>
<x:note>
  <t>
    &Note; This status code is similar to <x:ref>302 (Found)</x:ref>, except
    that it does not allow changing the request method from POST to GET. This
    specification defines no equivalent counterpart for <x:ref>301 (Moved
    Permanently)</x:ref> (<xref target="RFC7238"/>,
    however, defines the status code 308 (Permanent Redirect) for this purpose). 
  </t>
</x:note>
</section>
</section>

<section title="Client Error 4xx" anchor="status.4xx">
  <x:anchor-alias value="4xx"/>
  <x:anchor-alias value="4xx (Client Error)"/>
  <iref primary="true" item="4xx Client Error (status code class)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes Classes" subitem="4xx Client Error" x:for-anchor=""/>
<t>
   The <x:dfn>4xx (Client Error)</x:dfn> class of status code indicates that
   the client seems to have erred. Except when responding to a HEAD request,
   the server &SHOULD; send a representation containing an explanation of
   the error situation, and whether it is a temporary or permanent condition.
   These status codes are applicable to any request method. User agents
   &SHOULD; display any included representation to the user.
</t>

<section title="400 Bad Request" anchor="status.400">
  <iref primary="true" item="400 Bad Request (status code)" x:for-anchor=""/>
  <x:anchor-alias value="400 (Bad Request)"/>
<t>
   The <x:dfn>400 (Bad Request)</x:dfn> status code indicates that the server
   cannot or will not process the request due to something that is perceived
   to be a client error (e.g., malformed request syntax, invalid request
   message framing, or deceptive request routing).
</t>
</section>

<section title="402 Payment Required" anchor="status.402">
  <iref primary="true" item="402 Payment Required (status code)" x:for-anchor=""/>
  <x:anchor-alias value="402 (Payment Required)"/>
<t>
   The <x:dfn>402 (Payment Required)</x:dfn> status code is reserved for
   future use.
</t>
</section>

<section title="403 Forbidden" anchor="status.403">
  <iref primary="true" item="403 Forbidden (status code)" x:for-anchor=""/>
  <x:anchor-alias value="403 (Forbidden)"/>
<t>
   The <x:dfn>403 (Forbidden)</x:dfn> status code indicates that the
   server understood the request but refuses to authorize it.
   A server that wishes to make public why the request has been forbidden
   can describe that reason in the response payload (if any).
</t>
<t>
   If authentication credentials were provided in the request, the
   server considers them insufficient to grant access.
   The client &SHOULD-NOT; automatically repeat the request with the same
   credentials.
   The client &MAY; repeat the request with new or different credentials.
   However, a request might be forbidden for reasons unrelated to the
   credentials.
</t>
<t>
   An origin server that wishes to "hide" the current existence of a forbidden
   <x:ref>target resource</x:ref> &MAY; instead respond with a status
   code of <x:ref>404 (Not Found)</x:ref>.
</t>
</section>

<section title="404 Not Found" anchor="status.404">
  <iref primary="true" item="404 Not Found (status code)" x:for-anchor=""/>
  <x:anchor-alias value="404 (Not Found)"/>
<t>
   The <x:dfn>404 (Not Found)</x:dfn> status code indicates that the origin
   server did not find a current representation for the
   <x:ref>target resource</x:ref> or is not willing to disclose that one
   exists. A 404 status code does not indicate whether this lack of representation
   is temporary or permanent; the <x:ref>410 (Gone)</x:ref> status code is
   preferred over 404 if the origin server knows, presumably through some
   configurable means, that the condition is likely to be permanent.
</t>
<t>
   A 404 response is cacheable by default; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see &p6-heuristic;).
</t>
</section>

<section title="405 Method Not Allowed" anchor="status.405">
  <iref primary="true" item="405 Method Not Allowed (status code)" x:for-anchor=""/>
  <x:anchor-alias value="405 (Method Not Allowed)"/>
<t>
   The <x:dfn>405 (Method Not Allowed)</x:dfn> status code indicates that the
   method received in the request-line is known by the origin server but
   not supported by the <x:ref>target resource</x:ref>.
   The origin server &MUST; generate an <x:ref>Allow</x:ref> header field in
   a 405 response containing a list of the target resource's currently
   supported methods.
</t>
<t>
   A 405 response is cacheable by default; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see &p6-heuristic;).
</t>

</section>

<section title="406 Not Acceptable" anchor="status.406">
  <iref primary="true" item="406 Not Acceptable (status code)" x:for-anchor=""/>
  <x:anchor-alias value="406 (Not Acceptable)"/>
<t>
   The <x:dfn>406 (Not Acceptable)</x:dfn> status code indicates that the
   <x:ref>target resource</x:ref> does not have a current representation that
   would be acceptable to the user agent, according to the
   <x:ref>proactive negotiation</x:ref> header fields received in the request
   (<xref target="request.conneg"/>), and the server is unwilling to supply a
   default representation.
</t>
<t>
   The server &SHOULD; generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers from
   which the user or user agent can choose the one most appropriate.
   A user agent &MAY; automatically select the most appropriate choice from
   that list. However, this specification does not define any standard for
   such automatic selection, as described in <xref target="status.300"/>.
</t>
</section>

<section title="408 Request Timeout" anchor="status.408">
  <iref primary="true" item="408 Request Timeout (status code)" x:for-anchor=""/>
  <x:anchor-alias value="408 (Request Timeout)"/>
<t>
   The <x:dfn>408 (Request Timeout)</x:dfn> status code indicates
   that the server did not receive a complete request message within the time
   that it was prepared to wait.
   A server &SHOULD; send the "<x:ref>close</x:ref>" connection option
   (&header-connection;) in the response, since 408 implies that the server
   has decided to close the connection rather than continue waiting.
   If the client has an outstanding request in transit,
   the client &MAY; repeat that request on a new connection.
</t>
</section>

<section title="409 Conflict" anchor="status.409">
  <iref primary="true" item="409 Conflict (status code)" x:for-anchor=""/>
  <x:anchor-alias value="409 (Conflict)"/>
<t>
   The <x:dfn>409 (Conflict)</x:dfn> status code indicates that the request
   could not be completed due to a conflict with the current state of the target
   resource. This code is used in situations where the user might be able to
   resolve the conflict and resubmit the request. The server &SHOULD; generate
   a payload that includes enough information for a user to recognize the
   source of the conflict.
</t>
<t>
   Conflicts are most likely to occur in response to a PUT request. For
   example, if versioning were being used and the representation being PUT
   included changes to a resource that conflict with those made by an
   earlier (third-party) request, the origin server might use a 409 response
   to indicate that it can't complete the request. In this case, the response
   representation would likely contain information useful for merging the
   differences based on the revision history.
</t>
</section>

<section title="410 Gone" anchor="status.410">
  <iref primary="true" item="410 Gone (status code)" x:for-anchor=""/>
  <x:anchor-alias value="410 (Gone)"/>
<t>
   The <x:dfn>410 (Gone)</x:dfn> status code indicates that access to the
   <x:ref>target resource</x:ref> is no longer available at the origin
   server and that this condition is likely to be permanent. If the origin
   server does not know, or has no facility to determine, whether or not the
   condition is permanent, the status code <x:ref>404 (Not Found)</x:ref>
   ought to be used instead.
</t>
<t>
   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed. Such an event is common for
   limited-time, promotional services and for resources belonging to
   individuals no longer associated with the origin server's site. It is not
   necessary to mark all permanently unavailable resources as "gone" or
   to keep the mark for any length of time &mdash; that is left to the
   discretion of the server owner.
</t>
<t>
   A 410 response is cacheable by default; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see &p6-heuristic;).
</t>
</section>

<section title="411 Length Required" anchor="status.411">
  <iref primary="true" item="411 Length Required (status code)" x:for-anchor=""/>
  <x:anchor-alias value="411 (Length Required)"/>
<t>
   The <x:dfn>411 (Length Required)</x:dfn> status code indicates that the
   server refuses to accept the request without a defined
   <x:ref>Content-Length</x:ref> (&header-content-length;).
   The client &MAY; repeat the request if it adds a valid Content-Length
   header field containing the length of the message body in the request
   message.
</t>
</section>

<section title="413 Payload Too Large" anchor="status.413">
  <iref primary="true" item="413 Payload Too Large (status code)" x:for-anchor=""/>
  <x:anchor-alias value="413 (Payload Too Large)"/>
<t>
   The <x:dfn>413 (Payload Too Large)</x:dfn> status code indicates
   that the server is refusing to process a request because the request
   payload is larger than the server is willing or able to process.
   The server &MAY; close the connection to prevent the client from continuing
   the request.
</t>
<t>
   If the condition is temporary, the server &SHOULD; generate a
   <x:ref>Retry-After</x:ref> header field to indicate that it is temporary
   and after what time the client &MAY; try again.
</t>
</section>

<section title="414 URI Too Long" anchor="status.414">
  <iref primary="true" item="414 URI Too Long (status code)" x:for-anchor=""/>
  <x:anchor-alias value="414 (URI Too Long)"/>
<t>
   The <x:dfn>414 (URI Too Long)</x:dfn> status code indicates that the server
   is refusing to service the request because the
   request-target (&request-target;) is longer than the server is willing to
   interpret. This rare condition is only likely to occur when a client has
   improperly converted a POST request to a GET request with long query
   information, when the client has descended into a "black hole" of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself) or when the server is under attack by a client attempting to
   exploit potential security holes.
</t>
<t>
   A 414 response is cacheable by default; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see &p6-heuristic;).
</t>

</section>

<section title="415 Unsupported Media Type" anchor="status.415">
  <iref primary="true" item="415 Unsupported Media Type (status code)" x:for-anchor=""/>
  <x:anchor-alias value="415 (Unsupported Media Type)"/>
<t>
   The <x:dfn>415 (Unsupported Media Type)</x:dfn> status code indicates that
   the origin server is refusing to service the request because the payload is
   in a format not supported by this method on the <x:ref>target resource</x:ref>.
   The format problem might be due to the request's indicated
   <x:ref>Content-Type</x:ref> or <x:ref>Content-Encoding</x:ref>, or as a
   result of inspecting the data directly.
</t>
</section>

<section title="417 Expectation Failed" anchor="status.417">
  <iref primary="true" item="417 Expectation Failed (status code)" x:for-anchor=""/>
  <x:anchor-alias value="417 (Expectation Failed)"/>
<t>
   The <x:dfn>417 (Expectation Failed)</x:dfn> status code indicates that the
   expectation given in the request's <x:ref>Expect</x:ref> header field
   (<xref target="header.expect"/>) could not be met by at least one of the
   inbound servers.
</t>
</section>

<section title="426 Upgrade Required" anchor="status.426">
  <iref primary="true" item="426 Upgrade Required (status code)" x:for-anchor=""/>
  <x:anchor-alias value="426 (Upgrade Required)"/>
<t>
   The <x:dfn>426 (Upgrade Required)</x:dfn> status code indicates that the
   server refuses to perform the request using the current protocol but might
   be willing to do so after the client upgrades to a different protocol.
   The server &MUST; send an <x:ref>Upgrade</x:ref> header field in a 426
   response to indicate the required protocol(s) (&header-upgrade;).
</t>
<figure>
<preamble>Example:</preamble>
<artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 426 Upgrade Required
Upgrade: HTTP/3.0
Connection: Upgrade
Content-Length: <x:length-of target="s426body"/>
Content-Type: text/plain

<x:span anchor="s426body">This service requires use of the HTTP/3.0 protocol.
</x:span></artwork></figure>
</section>
</section>

<section title="Server Error 5xx" anchor="status.5xx">
  <x:anchor-alias value="5xx"/>
  <x:anchor-alias value="5xx (Server Error)"/>
  <iref primary="true" item="5xx Server Error (status code class)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes Classes" subitem="5xx Server Error" x:for-anchor=""/>
<t>
   The <x:dfn>5xx (Server Error)</x:dfn> class of status code indicates that
   the server is aware that it has erred or is incapable of performing the
   requested method.
   Except when responding to a HEAD request, the server &SHOULD; send a
   representation containing an explanation of the error situation, and
   whether it is a temporary or permanent condition.
   A user agent &SHOULD; display any included representation to the user.
   These response codes are applicable to any request method.
</t>

<section title="500 Internal Server Error" anchor="status.500">
  <iref primary="true" item="500 Internal Server Error (status code)" x:for-anchor=""/>
  <x:anchor-alias value="500 (Internal Server Error)"/>
<t>
   The <x:dfn>500 (Internal Server Error)</x:dfn> status code indicates that
   the server encountered an unexpected condition that prevented it from
   fulfilling the request.
</t>
</section>

<section title="501 Not Implemented" anchor="status.501">
  <iref primary="true" item="501 Not Implemented (status code)" x:for-anchor=""/>
  <x:anchor-alias value="501 (Not Implemented)"/>
<t>
   The <x:dfn>501 (Not Implemented)</x:dfn> status code indicates that the
   server does not support the functionality required to fulfill the request.
   This is the appropriate response when the server does not recognize the
   request method and is not capable of supporting it for any resource.
</t>
<t>
   A 501 response is cacheable by default; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see &p6-heuristic;).
</t>

</section>

<section title="502 Bad Gateway" anchor="status.502">
  <iref primary="true" item="502 Bad Gateway (status code)" x:for-anchor=""/>
  <x:anchor-alias value="502 (Bad Gateway)"/>
<t>
   The <x:dfn>502 (Bad Gateway)</x:dfn> status code indicates that the server,
   while acting as a gateway or proxy, received an invalid response from an
   inbound server it accessed while attempting to fulfill the request.
</t>
</section>

<section title="503 Service Unavailable" anchor="status.503">
  <iref primary="true" item="503 Service Unavailable (status code)" x:for-anchor=""/>
  <x:anchor-alias value="503 (Service Unavailable)"/>
<t>
   The <x:dfn>503 (Service Unavailable)</x:dfn> status code indicates that the
   server is currently unable to handle the request due to a temporary overload
   or scheduled maintenance, which will likely be alleviated after some delay.
   The server &MAY; send a <x:ref>Retry-After</x:ref> header field
   (<xref target="header.retry-after"/>) to suggest an appropriate
   amount of time for the client to wait before retrying the request.
</t>
<x:note>
  <t>
    &Note; The existence of the 503 status code does not imply that a
    server has to use it when becoming overloaded. Some servers might
    simply refuse the connection.
  </t>
</x:note>
</section>

<section title="504 Gateway Timeout" anchor="status.504">
  <iref primary="true" item="504 Gateway Timeout (status code)" x:for-anchor=""/>
  <x:anchor-alias value="504 (Gateway Timeout)"/>
<t>
   The <x:dfn>504 (Gateway Timeout)</x:dfn> status code indicates that the
   server, while acting as a gateway or proxy, did not receive a timely
   response from an upstream server it needed to access in order to
   complete the request.
</t>
</section>

<section title="505 HTTP Version Not Supported" anchor="status.505">
  <iref primary="true" item="505 HTTP Version Not Supported (status code)" x:for-anchor=""/>
  <x:anchor-alias value="505 (HTTP Version Not Supported)"/>
<t>
   The <x:dfn>505 (HTTP Version Not Supported)</x:dfn> status code indicates
   that the server does not support, or refuses to support, the major version
   of HTTP that was used in the request message. The server is indicating that
   it is unable or unwilling to complete the request using the same major
   version as the client, as described in &http-version;, other than with this
   error message. The server &SHOULD; generate a representation for the 505
   response that describes why that version is not supported and what other
   protocols are supported by that server.
</t>
</section>
</section>
</section>

<section title="Response Header Fields" anchor="response.header.fields">
  <x:anchor-alias value="response-header"/>
<t>
   The response header fields allow the server to pass additional
   information about the response beyond what is placed in the status-line.
   These header fields give information about the server, about
   further access to the <x:ref>target resource</x:ref>, or about related
   resources.
</t>
<t>
   Although each response header field has a defined meaning, in general,
   the precise semantics might be further refined by the semantics of the
   request method and/or response status code. 
</t>

<section title="Control Data" anchor="response.control.data">
<t>
   Response header fields can supply control data that supplements the
   status code, directs caching, or instructs the client where to go next.
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol><ttcol>Defined in...</ttcol>

  <c>Age</c> <c>&header-age;</c>
  <c>Cache-Control</c> <c>&header-cache-control;</c>
  <c>Expires</c> <c>&header-expires;</c>
  <c>Date</c> <c><xref target="header.date"/></c>
  <c>Location</c> <c><xref target="header.location"/></c>
  <c>Retry-After</c> <c><xref target="header.retry-after"/></c>
  <c>Vary</c> <c><xref target="header.vary"/></c>
  <c>Warning</c> <c>&header-warning;</c>
</texttable>

<section title="Origination Date" anchor="origination.date">

<section title="Date/Time Formats" anchor="http.date">
  <x:anchor-alias value="HTTP-date"/>
<t>
   Prior to 1995, there were three different formats commonly used by servers
   to communicate timestamps.  For compatibility with old implementations, all
   three are defined here. The preferred format is a fixed-length and
   single-zone subset of the date and time specification used by the
   Internet Message Format <xref target="RFC5322"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="HTTP-date"/>
  <x:ref>HTTP-date</x:ref>    = <x:ref>IMF-fixdate</x:ref> / <x:ref>obs-date</x:ref>
</artwork></figure>
<figure><preamble>An example of the preferred format is</preamble><artwork type="example" x:indent-with="  ">
Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate
</artwork></figure>
<figure><preamble>Examples of the two obsolete formats are</preamble><artwork type="example" x:indent-with="  ">
Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
</artwork></figure>
<t>
   A recipient that parses a timestamp value in an HTTP header field &MUST;
   accept all three HTTP-date formats. When a sender generates a header field
   that contains one or more timestamps defined as HTTP-date,
   the sender &MUST; generate those timestamps in the IMF-fixdate format.
</t>
<t>
   An HTTP-date value represents time as an instance of Coordinated Universal
   Time (UTC). The first two formats indicate UTC by the three-letter
   abbreviation for Greenwich Mean Time, "GMT", a predecessor of the UTC name;
   values in the asctime format are assumed to be in UTC.
   A sender that generates HTTP-date values from a local clock ought to use
   NTP (<xref target="RFC5905"/>) or some similar protocol to synchronize its
   clock to UTC.
</t>
<t anchor="preferred.date.format">
  <x:anchor-alias value="IMF-fixdate"/>
  <x:anchor-alias value="time-of-day"/>
  <x:anchor-alias value="hour"/>
  <x:anchor-alias value="minute"/>
  <x:anchor-alias value="second"/>
  <x:anchor-alias value="day-name"/>
  <x:anchor-alias value="day"/>
  <x:anchor-alias value="month"/>
  <x:anchor-alias value="year"/>
  <x:anchor-alias value="GMT"/>
  Preferred format:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="IMF-fixdate"/><iref primary="true" item="Grammar" subitem="date1"/><iref primary="true" item="Grammar" subitem="time-of-day"/><iref primary="true" item="Grammar" subitem="hour"/><iref primary="true" item="Grammar" subitem="minute"/><iref primary="true" item="Grammar" subitem="second"/><iref primary="true" item="Grammar" subitem="day-name"/><iref primary="true" item="Grammar" subitem="day-name-l"/><iref primary="true" item="Grammar" subitem="day"/><iref primary="true" item="Grammar" subitem="month"/><iref primary="true" item="Grammar" subitem="year"/><iref primary="true" item="Grammar" subitem="GMT"/>
  <x:ref>IMF-fixdate</x:ref>  = <x:ref>day-name</x:ref> "," <x:ref>SP</x:ref> date1 <x:ref>SP</x:ref> <x:ref>time-of-day</x:ref> <x:ref>SP</x:ref> <x:ref>GMT</x:ref>
  ; fixed length/zone/capitalization subset of the format
  ; see <xref target="RFC5322" x:fmt="of" x:sec="3.3"/>
  
  <x:ref>day-name</x:ref>     = <x:abnf-char-sequence>"Mon"</x:abnf-char-sequence> ; "Mon", case-sensitive
               / <x:abnf-char-sequence>"Tue"</x:abnf-char-sequence> ; "Tue", case-sensitive
               / <x:abnf-char-sequence>"Wed"</x:abnf-char-sequence> ; "Wed", case-sensitive
               / <x:abnf-char-sequence>"Thu"</x:abnf-char-sequence> ; "Thu", case-sensitive
               / <x:abnf-char-sequence>"Fri"</x:abnf-char-sequence> ; "Fri", case-sensitive
               / <x:abnf-char-sequence>"Sat"</x:abnf-char-sequence> ; "Sat", case-sensitive
               / <x:abnf-char-sequence>"Sun"</x:abnf-char-sequence> ; "Sun", case-sensitive
               
  <x:ref>date1</x:ref>        = <x:ref>day</x:ref> <x:ref>SP</x:ref> <x:ref>month</x:ref> <x:ref>SP</x:ref> <x:ref>year</x:ref>
               ; e.g., 02 Jun 1982

  <x:ref>day</x:ref>          = 2<x:ref>DIGIT</x:ref>
  <x:ref>month</x:ref>        = <x:abnf-char-sequence>"Jan"</x:abnf-char-sequence> ; "Jan", case-sensitive
               / <x:abnf-char-sequence>"Feb"</x:abnf-char-sequence> ; "Feb", case-sensitive
               / <x:abnf-char-sequence>"Mar"</x:abnf-char-sequence> ; "Mar", case-sensitive
               / <x:abnf-char-sequence>"Apr"</x:abnf-char-sequence> ; "Apr", case-sensitive
               / <x:abnf-char-sequence>"May"</x:abnf-char-sequence> ; "May", case-sensitive
               / <x:abnf-char-sequence>"Jun"</x:abnf-char-sequence> ; "Jun", case-sensitive
               / <x:abnf-char-sequence>"Jul"</x:abnf-char-sequence> ; "Jul", case-sensitive
               / <x:abnf-char-sequence>"Aug"</x:abnf-char-sequence> ; "Aug", case-sensitive
               / <x:abnf-char-sequence>"Sep"</x:abnf-char-sequence> ; "Sep", case-sensitive
               / <x:abnf-char-sequence>"Oct"</x:abnf-char-sequence> ; "Oct", case-sensitive
               / <x:abnf-char-sequence>"Nov"</x:abnf-char-sequence> ; "Nov", case-sensitive
               / <x:abnf-char-sequence>"Dec"</x:abnf-char-sequence> ; "Dec", case-sensitive
  <x:ref>year</x:ref>         = 4<x:ref>DIGIT</x:ref>

  <x:ref>GMT</x:ref>          = <x:abnf-char-sequence>"GMT"</x:abnf-char-sequence> ; "GMT", case-sensitive

  <x:ref>time-of-day</x:ref>  = <x:ref>hour</x:ref> ":" <x:ref>minute</x:ref> ":" <x:ref>second</x:ref>
               ; 00:00:00 - 23:59:60 (leap second)
                 
  <x:ref>hour</x:ref>         = 2<x:ref>DIGIT</x:ref>               
  <x:ref>minute</x:ref>       = 2<x:ref>DIGIT</x:ref>               
  <x:ref>second</x:ref>       = 2<x:ref>DIGIT</x:ref>               
</artwork></figure>
<t anchor="obsolete.date.formats">
  <x:anchor-alias value="obs-date"/>
  <x:anchor-alias value="rfc850-date"/>
  <x:anchor-alias value="asctime-date"/>
  <x:anchor-alias value="date1"/>
  <x:anchor-alias value="date2"/>
  <x:anchor-alias value="date3"/>
  <x:anchor-alias value="day-name-l"/>
  Obsolete formats:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="obs-date"/>
  <x:ref>obs-date</x:ref>     = <x:ref>rfc850-date</x:ref> / <x:ref>asctime-date</x:ref> 
</artwork></figure>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="rfc850-date"/>
  <x:ref>rfc850-date</x:ref>  = <x:ref>day-name-l</x:ref> "," <x:ref>SP</x:ref> <x:ref>date2</x:ref> <x:ref>SP</x:ref> <x:ref>time-of-day</x:ref> <x:ref>SP</x:ref> <x:ref>GMT</x:ref>
  <x:ref>date2</x:ref>        = <x:ref>day</x:ref> "-" <x:ref>month</x:ref> "-" 2<x:ref>DIGIT</x:ref>
               ; e.g., 02-Jun-82

  <x:ref>day-name-l</x:ref>   = <x:abnf-char-sequence>"Monday"</x:abnf-char-sequence>    ; "Monday", case-sensitive
         / <x:abnf-char-sequence>"Tuesday"</x:abnf-char-sequence>       ; "Tuesday", case-sensitive
         / <x:abnf-char-sequence>"Wednesday"</x:abnf-char-sequence> ; "Wednesday", case-sensitive
         / <x:abnf-char-sequence>"Thursday"</x:abnf-char-sequence>    ; "Thursday", case-sensitive
         / <x:abnf-char-sequence>"Friday"</x:abnf-char-sequence>          ; "Friday", case-sensitive
         / <x:abnf-char-sequence>"Saturday"</x:abnf-char-sequence>    ; "Saturday", case-sensitive
         / <x:abnf-char-sequence>"Sunday"</x:abnf-char-sequence>          ; "Sunday", case-sensitive
</artwork></figure>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="asctime-date"/>
  <x:ref>asctime-date</x:ref> = <x:ref>day-name</x:ref> <x:ref>SP</x:ref> <x:ref>date3</x:ref> <x:ref>SP</x:ref> <x:ref>time-of-day</x:ref> <x:ref>SP</x:ref> <x:ref>year</x:ref>
  <x:ref>date3</x:ref>        = <x:ref>month</x:ref> <x:ref>SP</x:ref> ( 2<x:ref>DIGIT</x:ref> / ( <x:ref>SP</x:ref> 1<x:ref>DIGIT</x:ref> ))
               ; e.g., Jun  2
</artwork></figure>
<t>
   HTTP-date is case sensitive.
   A sender &MUST-NOT; generate additional whitespace in an HTTP-date beyond
   that specifically included as SP in the grammar.
   The semantics of <x:ref>day-name</x:ref>, <x:ref>day</x:ref>,
   <x:ref>month</x:ref>, <x:ref>year</x:ref>, and <x:ref>time-of-day</x:ref>
   are the same as those defined for the Internet Message Format constructs
   with the corresponding name (<xref target="RFC5322" x:fmt="," x:sec="3.3"/>).
</t>
<t>
   Recipients of a timestamp value in rfc850-date format, which uses a
   two-digit year, &MUST; interpret a timestamp that appears to be more
   than 50 years in the future as representing the most recent year in the
   past that had the same last two digits.
</t>
<t>
   Recipients of timestamp values are encouraged to be robust in parsing
   timestamps unless otherwise restricted by the field definition.
   For example, messages are occasionally forwarded over HTTP from a non-HTTP
   source that might generate any of the date and time specifications defined
   by the Internet Message Format.
</t>
<x:note>
  <t>
    &Note; HTTP requirements for the date/time stamp format apply only
    to their usage within the protocol stream. Implementations are
    not required to use these formats for user presentation, request
    logging, etc.
  </t>
</x:note>
</section>

<section title="Date" anchor="header.date">
  <iref primary="true" item="Date header field" x:for-anchor=""/>
  <x:anchor-alias value="Date"/>
<t>
   The "Date" header field represents the date and time at which
   the message was originated, having the same semantics as the Origination
   Date Field (orig-date) defined in <xref target="RFC5322" x:fmt="of" x:sec="3.6.1"/>.
   The field value is an HTTP-date, as defined in <xref target="http.date"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Date"/>
  <x:ref>Date</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example is
</t>
<figure><artwork type="example">
  Date: Tue, 15 Nov 1994 08:12:31 GMT
</artwork></figure>
<t>
   When a Date header field is generated, the sender &SHOULD; generate its
   field value as the best available approximation of the date and time of
   message generation. In theory, the date ought to represent the moment just
   before the payload is generated. In practice, the date can be generated at
   any time during message origination.
</t>
<t>
   An origin server &MUST-NOT; send a Date header field if it does not have a
   clock capable of providing a reasonable approximation of the current
   instance in Coordinated Universal Time.
   An origin server &MAY; send a Date header field if the response is in the
   <x:ref>1xx (Informational)</x:ref> or <x:ref>5xx (Server Error)</x:ref>
   class of status codes.
   An origin server &MUST; send a Date header field in all other cases.
</t>
<t>
   A recipient with a clock that receives a response message without a Date
   header field &MUST; record the time it was received and append a
   corresponding Date header field to the message's header section if it is
   cached or forwarded downstream.
</t>
<t>
   A user agent &MAY; send a Date header field in a request, though generally
   will not do so unless it is believed to convey useful information to the
   server. For example, custom applications of HTTP might convey a Date if
   the server is expected to adjust its interpretation of the user's request
   based on differences between the user agent and server clocks.
</t>
</section>
</section>

<section title="Location" anchor="header.location">
  <iref primary="true" item="Location header field" x:for-anchor=""/>
  <x:anchor-alias value="Location"/>
<t>
   The "Location" header field is used in some responses to refer to a
   specific resource in relation to the response. The type of relationship is
   defined by the combination of request method and status code semantics.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Location"/>
  <x:ref>Location</x:ref> = <x:ref>URI-reference</x:ref>
</artwork></figure>
<t>
   The field value consists of a single URI-reference. When it has the form
   of a relative reference (<xref target="RFC3986" x:fmt="," x:sec="4.2"/>),
   the final value is computed by resolving it against the effective request
   URI (<xref target="RFC3986" x:fmt="," x:sec="5"/>).
</t>
<t>
   For <x:ref>201 (Created)</x:ref> responses, the Location value refers to
   the primary resource created by the request.
   For <x:ref>3xx (Redirection)</x:ref> responses, the Location value refers
   to the preferred target resource for automatically redirecting the request.
</t>
<t>
   If the Location value provided in a <x:ref>3xx (Redirection)</x:ref>
   response does not have a fragment component, a user agent &MUST; process the
   redirection as if the value inherits the fragment component of the URI
   reference used to generate the request target (i.e., the redirection
   inherits the original reference's fragment, if any).
</t>
<figure>
<preamble>For example, a GET request generated for the URI reference
   "http://www.example.org/~tim" might result in a
   <x:ref>303 (See Other)</x:ref> response containing the header field:</preamble><!--DO NOT DARE changing the vertical spacing below, it's necessary this way for xml2rfc-->
<artwork type="example">
  Location: /People.html#tim
</artwork>
<postamble>which suggests that the user agent redirect to
   "http://www.example.org/People.html#tim"</postamble>
</figure>
<figure>
<preamble>Likewise, a GET request generated for the URI reference
   "http://www.example.org/index.html#larry" might result in a
   <x:ref>301 (Moved Permanently)</x:ref> response containing the header
   field:</preamble><!--DO NOT DARE changing the vertical spacing below, it's necessary this way for xml2rfc-->
<artwork type="example">
  Location: http://www.example.net/index.html
</artwork>
<postamble>which suggests that the user agent redirect to
   "http://www.example.net/index.html#larry", preserving the original fragment
   identifier.</postamble>
</figure>
<t>
   There are circumstances in which a fragment identifier in a Location
   value would not be appropriate. For example, the Location header field in a
   <x:ref>201 (Created)</x:ref> response is supposed to provide a URI that is
   specific to the created resource.
</t>
<x:note>
  <t>
    &Note; Some recipients attempt to recover from Location fields
    that are not valid URI references. This specification does not mandate or
    define such processing, but does allow it for the sake of robustness.
  </t>
</x:note>
<x:note>
  <t>
    &Note; The <x:ref>Content-Location</x:ref> header field
    (&header-content-location;) differs from Location in that the
    Content-Location refers to the most specific resource corresponding to the
    enclosed representation. It is therefore possible for a response to contain
    both the Location and Content-Location header fields.
  </t>
</x:note>
</section>

<section title="Retry-After" anchor="header.retry-after">
  <iref primary="true" item="Retry-After header field" x:for-anchor=""/>
  <x:anchor-alias value="Retry-After"/>
<t>
   Servers send the "Retry-After" header field to indicate how long the user
   agent ought to wait before making a follow-up request. When sent with a
   <x:ref>503 (Service Unavailable)</x:ref> response, Retry-After indicates
   how long the service is expected to be unavailable to the client.
   When sent with any <x:ref>3xx (Redirection)</x:ref> response, Retry-After
   indicates the minimum time that the user agent is asked to wait before
   issuing the redirected request.
</t>
<t>
   The value of this field can be either an HTTP-date or a number
   of seconds to delay after the response is received.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Retry-After"/>
  <x:ref>Retry-After</x:ref> = <x:ref>HTTP-date</x:ref> / <x:ref>delay-seconds</x:ref>
</artwork></figure>
<t anchor="rule.delay-seconds">
  <x:anchor-alias value="delay-seconds"/>
   A delay-seconds value is a non-negative decimal integer, representing time
   in seconds.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="delay-seconds"/>
  <x:ref>delay-seconds</x:ref>  = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   Two examples of its use are
</t>
<figure><artwork type="example">
  Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
  Retry-After: 120
</artwork></figure>
<t>
   In the latter example, the delay is 2 minutes.
</t>
</section>

<section anchor="header.vary" title="Vary">
   <iref item="Vary header field" primary="true" x:for-anchor="" />
   <x:anchor-alias value="Vary"/>
<t>
   The "Vary" header field in a response describes what parts of a request
   message, aside from the method, Host header field, and request target,
   might influence the origin server's process for selecting and representing
   this response. The value consists of either a single asterisk ("*") or a
   list of header field names (case-insensitive).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Vary"/>
  <x:ref>Vary</x:ref> = "*" / 1#<x:ref>field-name</x:ref>
</artwork></figure>
<t>
   A Vary field value of "*" signals that anything about the request might
   play a role in selecting the response representation, possibly including
   elements outside the message syntax (e.g., the client's network address).
   A recipient will not be able to determine whether this response is
   appropriate for a later request without forwarding the request to the
   origin server. A proxy &MUST-NOT; generate a Vary field with a "*" value.
</t>
<t>
   A Vary field value consisting of a comma-separated list of names indicates
   that the named request header fields, known as the selecting header fields,
   might have a role in selecting the representation. The potential selecting
   header fields are not limited to those defined by this specification.
</t>
<figure><preamble>For example, a response that contains</preamble><artwork type="example">
  Vary: accept-encoding, accept-language
</artwork><postamble>indicates that the origin server might have used the
   request's <x:ref>Accept-Encoding</x:ref> and <x:ref>Accept-Language</x:ref>
   fields (or lack thereof) as determining factors while choosing the content
   for this response.
</postamble></figure>
<t>
   An origin server might send Vary with a list of fields for two purposes:
   <list style="numbers">
      <x:lt>
        <t>
           To inform cache recipients that they &MUST-NOT; use this response
           to satisfy a later request unless the later request has the
           same values for the listed fields as the original request
           (&caching-neg-resp;). In other words, Vary expands the cache key
           required to match a new request to the stored cache entry.
        </t>
      </x:lt>
      <x:lt>
        <t>
           To inform user agent recipients that this response is subject to
           content negotiation (<xref target="request.conneg"/>) and that a
           different representation might be sent in a subsequent request if
           additional parameters are provided in the listed header fields
           (<x:ref>proactive negotiation</x:ref>).
        </t>
      </x:lt>
   </list>
</t>
<t>
   An origin server &SHOULD; send a Vary header field when its algorithm for
   selecting a representation varies based on aspects of the request message
   other than the method and request target, unless the variance cannot be
   crossed or the origin server has been deliberately configured to prevent
   cache transparency. For example, there is no need to send the Authorization
   field name in Vary because reuse across users is constrained by the field
   definition (&header-authorization;). Likewise, an origin server might use
   Cache-Control directives (&header-cache-control;) to supplant Vary if it
   considers the variance less significant than the performance cost of Vary's
   impact on caching.
</t>
</section>
</section>

<section title="Validator Header Fields" anchor="response.validator">
   <iref item="selected representation"/>
<t>
   Validator header fields convey metadata about the
   <x:ref>selected representation</x:ref> (<xref target="representations"/>).
   In responses to safe requests, validator fields describe the selected
   representation chosen by the origin server while handling the response.
   Note that, depending on the status code semantics, the
   <x:ref>selected representation</x:ref> for a given response is not
   necessarily the same as the representation enclosed as response payload.
</t>
<t>
   In a successful response to a state-changing request, validator fields
   describe the new representation that has replaced the prior
   <x:ref>selected representation</x:ref> as a result of processing the
   request.
</t>
<t>
   For example, an ETag header field in a <x:ref>201 (Created)</x:ref> response communicates the
   entity-tag of the newly created resource's representation, so that it can
   be used in later conditional requests to prevent the "lost update"
   problem <xref target="RFC7232"/>.
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol>
  <ttcol>Defined in...</ttcol>

  <c>ETag</c> <c>&header-etag;</c>
  <c>Last-Modified</c> <c>&header-last-modified;</c>
</texttable>

</section>

<section title="Authentication Challenges" anchor="response.auth">
<t>
   Authentication challenges indicate what mechanisms are available for the
   client to provide authentication credentials in future requests.
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol><ttcol>Defined in...</ttcol>

  <c>WWW-Authenticate</c> <c>&header-www-authenticate;</c>
  <c>Proxy-Authenticate</c> <c>&header-proxy-authenticate;</c>
</texttable>
</section>

<section title="Response Context" anchor="response.context">
<t>
   The remaining response header fields provide more information about
   the <x:ref>target resource</x:ref> for potential use in later requests.
</t>
<texttable align="left">
  <ttcol>Header Field Name</ttcol><ttcol>Defined in...</ttcol>

  <c>Accept-Ranges</c> <c>&header-accept-ranges;</c>
  <c>Allow</c> <c><xref target="header.allow"/></c>
  <c>Server</c> <c><xref target="header.server"/></c>
</texttable>

<section title="Allow" anchor="header.allow">
  <iref primary="true" item="Allow header field" x:for-anchor=""/>
  <x:anchor-alias value="Allow"/>
<t>
   The "Allow" header field lists the set of methods advertised as
   supported by the <x:ref>target resource</x:ref>. The purpose of this field
   is strictly to inform the recipient of valid request methods associated
   with the resource.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Allow"/>
  <x:ref>Allow</x:ref> = #<x:ref>method</x:ref>
</artwork></figure>
<t>
   Example of use:
</t>
<figure><artwork type="example">
  Allow: GET, HEAD, PUT
</artwork></figure>
<t>
   The actual set of allowed methods is defined by the origin server at the
   time of each request. An origin server &MUST; generate an Allow field in a
   <x:ref>405 (Method Not Allowed)</x:ref> response and &MAY; do so in any
   other response. An empty Allow field value indicates that the resource
   allows no methods, which might occur in a 405 response if the resource has
   been temporarily disabled by configuration.
</t>
<t>
   A proxy &MUST-NOT; modify the Allow header field &mdash; it does not need
   to understand all of the indicated methods in order to handle them
   according to the generic message handling rules.
</t>
</section>

<section title="Server" anchor="header.server">
  <iref primary="true" item="Server header field" x:for-anchor=""/>
  <x:anchor-alias value="Server"/>
<t>
   The "Server" header field contains information about the
   software used by the origin server to handle the request, which is often
   used by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular server
   limitations, and for analytics regarding server or operating system use.
   An origin server &MAY; generate a Server field in its responses.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Server"/>
  <x:ref>Server</x:ref> = <x:ref>product</x:ref> *( <x:ref>RWS</x:ref> ( <x:ref>product</x:ref> / <x:ref>comment</x:ref> ) )
</artwork></figure>
<t>
   The Server field-value consists of one or more product identifiers, each
   followed by zero or more comments (&header-fields;), which together
   identify the origin server software and its significant subproducts.
   By convention, the product identifiers are listed in decreasing order of
   their significance for identifying the origin server software. Each product
   identifier consists of a name and optional version, as defined in
   <xref target="header.user-agent"/>.
</t>
<t>
   Example:
</t>
<figure><artwork type="example">
  Server: CERN/3.0 libwww/2.17
</artwork></figure>
<t>
   An origin server &SHOULD-NOT; generate a Server field containing needlessly
   fine-grained detail and &SHOULD; limit the addition of subproducts by third
   parties. Overly long and detailed Server field values increase response
   latency and potentially reveal internal implementation details that might
   make it (slightly) easier for attackers to find and exploit known security
   holes.
</t>
</section>
</section>
</section>

<section title="IANA Considerations" anchor="IANA.considerations">

<section title="Method Registry" anchor="method.registry">
<t>
  The "Hypertext Transfer Protocol (HTTP) Method Registry" defines the namespace for the request method
  token (<xref target="methods"/>).
  The method registry has been created and is now maintained at 
  <eref target="http://www.iana.org/assignments/http-methods"/>.
</t>

<section title="Procedure" anchor="method.registry.procedure">
<t>
  HTTP method registrations &MUST; include the following fields:
  <list style="symbols">
    <t>Method Name (see <xref target="methods"/>)</t>
    <t>Safe ("yes" or "no", see <xref target="safe.methods"/>)</t>
    <t>Idempotent ("yes" or "no", see <xref target="idempotent.methods"/>)</t>
    <t>Pointer to specification text</t>
  </list>
</t>
<t>
  Values to be added to this namespace require IETF Review
  (see <xref target="RFC5226" x:fmt="," x:sec="4.1"/>).
</t>
</section>

<section title="Considerations for New Methods" anchor="considerations.for.new.methods">
<t>
   Standardized methods are generic; that is, they are potentially
   applicable to any resource, not just one particular media type, kind of
   resource, or application. As such, it is preferred that new methods
   be registered in a document that isn't specific to a single application or
   data format, since orthogonal technologies deserve orthogonal specification.
</t>
<t>
   Since message parsing (&message-body;) needs to be independent of method
   semantics (aside from responses to HEAD), definitions of new methods
   cannot change the parsing algorithm or prohibit the presence of a message
   body on either the request or the response message.
   Definitions of new methods can specify that only a zero-length message body
   is allowed by requiring a Content-Length header field with a value of "0".
</t>
<t>
   A new method definition needs to indicate whether it is safe (<xref
   target="safe.methods"/>), idempotent (<xref target="idempotent.methods"/>),
   cacheable (<xref target="cacheable.methods"/>), what
   semantics are to be associated with the payload body if any is present
   in the request and what refinements the method makes to header field
   or status code semantics.
   If the new method is cacheable, its definition ought to describe how, and
   under what conditions, a cache can store a response and use it to satisfy a
   subsequent request.
   The new method ought to describe whether it can be made conditional
   (<xref target="request.conditionals"/>) and, if so, how a server responds
   when the condition is false.
   Likewise, if the new method might have some use for partial response
   semantics (<xref target="RFC7233"/>), it ought to document this, too.
</t>
<x:note>
  <t>
    &Note; Avoid defining a method name that starts with "M-", since that
    prefix might be misinterpreted as having the semantics assigned to it
    by <xref target="RFC2774"/>.
  </t>
</x:note>
</section>

<section title="Registrations" anchor="method.registration">
<t>
   The "Hypertext Transfer Protocol (HTTP) Method Registry" has been populated with the registrations below:
</t>
<?BEGININC p2-semantics.iana-methods ?>
<!--AUTOGENERATED FROM extract-method-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.method.registration.table">
   <ttcol>Method</ttcol>
   <ttcol>Safe</ttcol>
   <ttcol>Idempotent</ttcol>
   <ttcol>Reference</ttcol>
   <c>CONNECT</c>
   <c>no</c>
   <c>no</c>
   <c>
      <xref target="CONNECT"/>
   </c>
   <c>DELETE</c>
   <c>no</c>
   <c>yes</c>
   <c>
      <xref target="DELETE"/>
   </c>
   <c>GET</c>
   <c>yes</c>
   <c>yes</c>
   <c>
      <xref target="GET"/>
   </c>
   <c>HEAD</c>
   <c>yes</c>
   <c>yes</c>
   <c>
      <xref target="HEAD"/>
   </c>
   <c>OPTIONS</c>
   <c>yes</c>
   <c>yes</c>
   <c>
      <xref target="OPTIONS"/>
   </c>
   <c>POST</c>
   <c>no</c>
   <c>no</c>
   <c>
      <xref target="POST"/>
   </c>
   <c>PUT</c>
   <c>no</c>
   <c>yes</c>
   <c>
      <xref target="PUT"/>
   </c>
   <c>TRACE</c>
   <c>yes</c>
   <c>yes</c>
   <c>
      <xref target="TRACE"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p2-semantics.iana-methods ?>
</section>
</section>

<section title="Status Code Registry" anchor="status.code.registry">
<t>
   The "Hypertext Transfer Protocol (HTTP) Status Code Registry" defines the namespace for the response
   status-code token (<xref target="status.codes"/>). The status code registry
   is maintained at <eref target="http://www.iana.org/assignments/http-status-codes"/>.
</t>
<t>
   This section replaces the registration procedure for HTTP Status Codes
   previously defined in <xref target="RFC2817" x:fmt="of" x:sec="7.1"/>.
</t>

<section title="Procedure" anchor="status.code.registry.procedure">
<t>
   A registration &MUST; include the following fields:
   <list style="symbols">
      <t>Status Code (3 digits)</t>
      <t>Short Description</t>
      <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Values to be added to the HTTP status code namespace require IETF Review
   (see <xref target="RFC5226" x:fmt="," x:sec="4.1"/>).
</t>
</section>

<section title="Considerations for New Status Codes" anchor="considerations.for.new.status.codes">
<t>
   When it is necessary to express semantics for a response that are not
   defined by current status codes, a new status code can be registered.
   Status codes are generic; they are potentially applicable to any resource,
   not just one particular media type, kind of resource, or application of
   HTTP. As such, it is preferred that new status codes be registered in a
   document that isn't specific to a single application.
</t>
<t>
   New status codes are required to fall under one of the categories
   defined in <xref target="status.codes"/>. To allow existing parsers to
   process the response message, new status codes cannot disallow a payload,
   although they can mandate a zero-length payload body.
</t>
<t>
   Proposals for new status codes that are not yet widely deployed ought to
   avoid allocating a specific number for the code until there is clear
   consensus that it will be registered; instead, early drafts can use a
   notation such as "4NN", or "3N0" .. "3N9", to indicate the class
   of the proposed status code(s) without consuming a number prematurely.
</t>
<t>
   The definition of a new status code ought to explain the request
   conditions that would cause a response containing that status code (e.g.,
   combinations of request header fields and/or method(s)) along with any 
   dependencies on response header fields (e.g., what fields are required,
   what fields can modify the semantics, and what header field semantics are
   further refined when used with the new status code).
</t>
<t>
   The definition of a new status code ought to specify whether or not it is
   cacheable. Note that all status codes can be cached if the response they
   occur in has explicit freshness information; however, status codes that are
   defined as being cacheable are allowed to be cached without explicit
   freshness information. Likewise, the definition of a status code can place
   constraints upon cache behavior. See &caching; for more information.
</t>
<t>   
   Finally, the definition of a new status code ought to indicate whether the
   payload has any implied association with an identified resource (<xref
   target="identifying.payload"/>).
</t>
</section>

<section title="Registrations" anchor="status.code.registration">
<t>
   The status code registry has been updated with the registrations below:
</t>
<?BEGININC p2-semantics.iana-status-codes ?>
<!--AUTOGENERATED FROM extract-status-code-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.status.code.registration.table">
   <ttcol>Value</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>100</c>
   <c>Continue</c>
   <c>
      <xref target="status.100"/>
   </c>
   <c>101</c>
   <c>Switching Protocols</c>
   <c>
      <xref target="status.101"/>
   </c>
   <c>200</c>
   <c>OK</c>
   <c>
      <xref target="status.200"/>
   </c>
   <c>201</c>
   <c>Created</c>
   <c>
      <xref target="status.201"/>
   </c>
   <c>202</c>
   <c>Accepted</c>
   <c>
      <xref target="status.202"/>
   </c>
   <c>203</c>
   <c>Non-Authoritative Information</c>
   <c>
      <xref target="status.203"/>
   </c>
   <c>204</c>
   <c>No Content</c>
   <c>
      <xref target="status.204"/>
   </c>
   <c>205</c>
   <c>Reset Content</c>
   <c>
      <xref target="status.205"/>
   </c>
   <c>300</c>
   <c>Multiple Choices</c>
   <c>
      <xref target="status.300"/>
   </c>
   <c>301</c>
   <c>Moved Permanently</c>
   <c>
      <xref target="status.301"/>
   </c>
   <c>302</c>
   <c>Found</c>
   <c>
      <xref target="status.302"/>
   </c>
   <c>303</c>
   <c>See Other</c>
   <c>
      <xref target="status.303"/>
   </c>
   <c>305</c>
   <c>Use Proxy</c>
   <c>
      <xref target="status.305"/>
   </c>
   <c>306</c>
   <c>(Unused)</c>
   <c>
      <xref target="status.306"/>
   </c>
   <c>307</c>
   <c>Temporary Redirect</c>
   <c>
      <xref target="status.307"/>
   </c>
   <c>400</c>
   <c>Bad Request</c>
   <c>
      <xref target="status.400"/>
   </c>
   <c>402</c>
   <c>Payment Required</c>
   <c>
      <xref target="status.402"/>
   </c>
   <c>403</c>
   <c>Forbidden</c>
   <c>
      <xref target="status.403"/>
   </c>
   <c>404</c>
   <c>Not Found</c>
   <c>
      <xref target="status.404"/>
   </c>
   <c>405</c>
   <c>Method Not Allowed</c>
   <c>
      <xref target="status.405"/>
   </c>
   <c>406</c>
   <c>Not Acceptable</c>
   <c>
      <xref target="status.406"/>
   </c>
   <c>408</c>
   <c>Request Timeout</c>
   <c>
      <xref target="status.408"/>
   </c>
   <c>409</c>
   <c>Conflict</c>
   <c>
      <xref target="status.409"/>
   </c>
   <c>410</c>
   <c>Gone</c>
   <c>
      <xref target="status.410"/>
   </c>
   <c>411</c>
   <c>Length Required</c>
   <c>
      <xref target="status.411"/>
   </c>
   <c>413</c>
   <c>Payload Too Large</c>
   <c>
      <xref target="status.413"/>
   </c>
   <c>414</c>
   <c>URI Too Long</c>
   <c>
      <xref target="status.414"/>
   </c>
   <c>415</c>
   <c>Unsupported Media Type</c>
   <c>
      <xref target="status.415"/>
   </c>
   <c>417</c>
   <c>Expectation Failed</c>
   <c>
      <xref target="status.417"/>
   </c>
   <c>426</c>
   <c>Upgrade Required</c>
   <c>
      <xref target="status.426"/>
   </c>
   <c>500</c>
   <c>Internal Server Error</c>
   <c>
      <xref target="status.500"/>
   </c>
   <c>501</c>
   <c>Not Implemented</c>
   <c>
      <xref target="status.501"/>
   </c>
   <c>502</c>
   <c>Bad Gateway</c>
   <c>
      <xref target="status.502"/>
   </c>
   <c>503</c>
   <c>Service Unavailable</c>
   <c>
      <xref target="status.503"/>
   </c>
   <c>504</c>
   <c>Gateway Timeout</c>
   <c>
      <xref target="status.504"/>
   </c>
   <c>505</c>
   <c>HTTP Version Not Supported</c>
   <c>
      <xref target="status.505"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p2-semantics.iana-status-codes ?>
</section>
</section>

<section title="Header Field Registry" anchor="header.field.registry">
<t>
   HTTP header fields are registered within the "Message Headers" registry
   located at <eref target="http://www.iana.org/assignments/message-headers"/>,
   as defined by <xref target="BCP90"/>.
</t>

<section title="Considerations for New Header Fields" anchor="considerations.for.new.header.fields">
<t>
   Header fields are key:value pairs that can be used to communicate data about
   the message, its payload, the target resource, or the connection
   (i.e., control data).  See &header-fields; for a general definition
   of header field syntax in HTTP messages.
</t>
<t>
   The requirements for header field names are defined in
   <xref target="BCP90"/>.
</t>
<t>   
   Authors of specifications defining new fields are
   advised to keep the name as short as practical and not to prefix the name
   with "X-" unless the header field will never be used on the Internet.
   (The "X-" prefix idiom has been extensively misused in practice; it was
   intended to only be used as a mechanism for avoiding name collisions inside
   proprietary software or intranet processing, since the prefix would ensure
   that private names never collide with a newly registered Internet name; see
   <xref target="BCP178"/> for further information).
</t>
<t>
   New header field values typically have their syntax defined using ABNF
   (<xref target="RFC5234"/>), using the extension defined in &abnf-extension;
   as necessary, and are usually constrained to the range of US-ASCII characters.
   Header fields needing a greater range of characters can use an encoding
   such as the one defined in <xref target="RFC5987"/>. 
</t>
<t>
   Leading and trailing whitespace in raw field values is removed upon field
   parsing (&field-parsing;). Field definitions where leading or trailing
   whitespace in values is significant will have to use a container syntax such
   as quoted-string (&field-components;).
</t>
<t>
   Because commas (",") are used as a generic delimiter between field-values,
   they need to be treated with care if they are allowed in the field-value.
   Typically, components that might contain a comma are protected with
   double-quotes using the quoted-string ABNF production.
</t>
<t>
   For example, a textual date and a URI (either of which might contain a comma)
   could be safely carried in field-values like these:
</t>
<figure><artwork type="example">
  Example-URI-Field: "http://example.com/a.html,foo",
                     "http://without-a-comma.example.com/"
  Example-Date-Field: "Sat, 04 May 1996", "Wed, 14 Sep 2005"
</artwork></figure>
<t>
   Note that double-quote delimiters almost always are used with the
   quoted-string production; using a different syntax inside double-quotes
   will likely cause unnecessary confusion.
</t>
<t>
   Many header fields use a format including (case-insensitively) named
   parameters (for instance, <x:ref>Content-Type</x:ref>, defined in
   &header-content-type;). Allowing both unquoted (token) and quoted
   (quoted-string) syntax for the parameter value enables recipients to use
   existing parser components. When allowing both forms, the meaning of a
   parameter value ought to be independent of the syntax used for it (for an
   example, see the notes on parameter handling for media types in
   &media-type;).
</t>
<t>
   Authors of specifications defining new header fields are advised to consider
   documenting:
  <list style="symbols">
    <x:lt>
      <t>Whether the field is a single value or whether it can be a list
      (delimited by commas; see &header-fields;).</t>
      <t>If it does not use the list syntax, document how to treat messages
      where the field occurs multiple times (a sensible default would
      be to ignore the field, but this might not always be the right
      choice).</t>
      <t>Note that intermediaries and software libraries might combine
      multiple header field instances into a single one, despite the
      field's definition not allowing the list syntax. A robust format enables
      recipients to discover these situations (good example: "Content-Type",
      as the comma can only appear inside quoted strings;
      bad example: "Location", as a comma can occur inside a URI).</t>
    </x:lt>
    <x:lt><t>Under what conditions the header field can be used; e.g., only in
      responses or requests, in all messages, only on responses to a
      particular request method, etc.</t></x:lt>
    <x:lt><t>Whether the field should be stored by origin servers that
      understand it upon a PUT request.</t></x:lt>
    <x:lt><t>Whether the field semantics are further refined by the context,
      such as by existing request methods or status codes.</t></x:lt>
    <x:lt><t>Whether it is appropriate to list the field-name in the
      <x:ref>Connection</x:ref> header field (i.e., if the header field is to
      be hop-by-hop; see &header-connection;).</t></x:lt>
    <x:lt><t>Under what conditions intermediaries are allowed to insert,
      delete, or modify the field's value.</t></x:lt>
    <x:lt><t>Whether it is appropriate to list the field-name in a
      <x:ref>Vary</x:ref> response header field (e.g., when the request header
      field is used by an origin server's content selection algorithm; see
      <xref target="header.vary"/>).</t></x:lt>
    <x:lt><t>Whether the header field is useful or allowable in trailers (see
      &chunked-encoding;).</t></x:lt>
    <x:lt><t>Whether the header field ought to be preserved across redirects.</t></x:lt>
    <x:lt><t>Whether it introduces any additional security considerations, such
      as disclosure of privacy-related data.</t></x:lt>
  </list>
</t>
</section>

<section title="Registrations" anchor="header.field.registration">
<t>
   The "Message Headers" registry has been updated with the
   following permanent registrations:
</t>
<?BEGININC p2-semantics.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Accept</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.accept"/>
   </c>
   <c>Accept-Charset</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.accept-charset"/>
   </c>
   <c>Accept-Encoding</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.accept-encoding"/>
   </c>
   <c>Accept-Language</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.accept-language"/>
   </c>
   <c>Allow</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.allow"/>
   </c>
   <c>Content-Encoding</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-encoding"/>
   </c>
   <c>Content-Language</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-language"/>
   </c>
   <c>Content-Location</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-location"/>
   </c>
   <c>Content-Type</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-type"/>
   </c>
   <c>Date</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.date"/>
   </c>
   <c>Expect</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.expect"/>
   </c>
   <c>From</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.from"/>
   </c>
   <c>Location</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.location"/>
   </c>
   <c>Max-Forwards</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.max-forwards"/>
   </c>
   <c>MIME-Version</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="mime-version"/>
   </c>
   <c>Referer</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.referer"/>
   </c>
   <c>Retry-After</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.retry-after"/>
   </c>
   <c>Server</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.server"/>
   </c>
   <c>User-Agent</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.user-agent"/>
   </c>
   <c>Vary</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.vary"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p2-semantics.iana-headers ?>
<t>
   The change controller for the above registrations is:
   "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>
</section>

<section title="Content Coding Registry" anchor="content.coding.registry">
<t>
   The "HTTP Content Coding Registry" defines the namespace for content
   coding names (&compression-codings;).
   The content coding registry is maintained at
   <eref target="http://www.iana.org/assignments/http-parameters"/>.
</t>

<section title="Procedure" anchor="content.coding.procedure">
<t>
   Content coding registrations &MUST; include the following fields:
   <list style="symbols">
     <t>Name</t>
     <t>Description</t>
     <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Names of content codings &MUST-NOT; overlap with names of transfer codings
   (&transfer-codings;), unless the encoding transformation is identical (as
   is the case for the compression codings defined in
   &compression-codings;).
</t>
<t>
   Values to be added to this namespace require IETF Review
   (see <xref target="RFC5226" x:fmt="of" x:sec="4.1"/>) and &MUST;
   conform to the purpose of content coding defined in this section.
</t>
</section>

<section title="Registrations" anchor="content.coding.registration">
<t>
   The "HTTP Content Coding Registry" has been updated with the registrations
   below:
</t>
<texttable align="left" suppress-title="true" anchor="iana.content.coding.registration.table">
   <ttcol>Name</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>identity</c>
   <c>Reserved
      (synonym for "no encoding" in <x:ref>Accept-Encoding</x:ref>)</c>
   <c>
      <xref target="header.accept-encoding"/>
   </c>
</texttable>
</section>
</section>
</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   This section is meant to inform developers, information providers, and
   users of known security concerns relevant to HTTP semantics and its
   use for transferring information over the Internet. Considerations related
   to message syntax, parsing, and routing are discussed in
   &p1-security-considerations;.
</t>
<t>
   The list of considerations below is not exhaustive. Most security concerns
   related to HTTP semantics are about securing server-side applications (code
   behind the HTTP interface), securing user agent processing of payloads
   received via HTTP, or secure use of the Internet in general, rather than
   security of the protocol. Various organizations maintain topical
   information and links to current research on Web application security
   (e.g., <xref target="OWASP"/>).
</t>

<section title="Attacks Based on File and Path Names" anchor="attack.pathname">
<t>
   Origin servers frequently make use of their local file system to manage the
   mapping from effective request URI to resource representations.
   Most file systems are not designed to protect against malicious file
   or path names. Therefore, an origin server needs to avoid accessing
   names that have a special significance to the system when mapping the
   request target to files, folders, or directories.
</t>
<t>
   For example, UNIX, Microsoft Windows, and other operating systems use ".."
   as a path component to indicate a directory level above the current one,
   and they use specially named paths or file names to send data to system devices.
   Similar naming conventions might exist within other types of storage
   systems. Likewise, local storage systems have an annoying tendency to
   prefer user-friendliness over security when handling invalid or unexpected
   characters, recomposition of decomposed characters, and case-normalization
   of case-insensitive names.
</t>
<t>
   Attacks based on such special names tend to focus on either denial-of-service
   (e.g., telling the server to read from a COM port) or disclosure
   of configuration and source files that are not meant to be served.
</t>
</section>

<section title="Attacks Based on Command, Code, or Query Injection" anchor="attack.injection">
<t>
   Origin servers often use parameters within the URI as a
   means of identifying system services, selecting database entries, or
   choosing a data source. However, data received in a request cannot be
   trusted. An attacker could construct any of the request data elements
   (method, request-target, header fields, or body) to contain data that might
   be misinterpreted as a command, code, or query when passed through a
   command invocation, language interpreter, or database interface.
</t>
<t>
   For example, SQL injection is a common attack wherein additional query
   language is inserted within some part of the request-target or header
   fields (e.g., <x:ref>Host</x:ref>, <x:ref>Referer</x:ref>, etc.).
   If the received data is used directly within a SELECT statement, the
   query language might be interpreted as a database command instead of a
   simple string value. This type of implementation vulnerability is extremely
   common, in spite of being easy to prevent.
</t>
<t>
   In general, resource implementations ought to avoid use of request data
   in contexts that are processed or interpreted as instructions.  Parameters
   ought to be compared to fixed strings and acted upon as a result of that
   comparison, rather than passed through an interface that is not prepared
   for untrusted data. Received data that isn't based on fixed parameters
   ought to be carefully filtered or encoded to avoid being misinterpreted.
</t>
<t>
   Similar considerations apply to request data when it is stored and later
   processed, such as within log files, monitoring tools, or when included
   within a data format that allows embedded scripts.
</t>
</section>

<section title="Disclosure of Personal Information" anchor="personal.information">
<t>
   Clients are often privy to large amounts of personal information,
   including both information provided by the user to interact with resources
   (e.g., the user's name, location, mail address, passwords, encryption
   keys, etc.) and information about the user's browsing activity over
   time (e.g., history, bookmarks, etc.). Implementations need to
   prevent unintentional disclosure of personal information.
</t>
</section>

<section title="Disclosure of Sensitive Information in URIs" anchor="sensitive.information.in.uris">
<t>
   URIs are intended to be shared, not secured, even when they identify secure
   resources. URIs are often shown on displays, added to templates when a page
   is printed, and stored in a variety of unprotected bookmark lists.
   It is therefore unwise to include information within a URI that
   is sensitive, personally identifiable, or a risk to disclose.
</t>
<t>
   Authors of services ought to avoid GET-based forms for the submission of
   sensitive data because that data will be placed in the request-target. Many
   existing servers, proxies, and user agents log or display the request-target
   in places where it might be visible to third parties. Such services ought
   to use POST-based form submission instead.
</t>
<t>
   Since the <x:ref>Referer</x:ref> header field tells a target site about the
   context that resulted in a request, it has the potential to reveal
   information about the user's immediate browsing history and any personal
   information that might be found in the referring resource's URI.
   Limitations on the Referer header field are described in <xref target="header.referer"/> to
   address some of its security considerations.
</t>
</section>

<section title="Disclosure of Fragment after Redirects" anchor="fragment.disclosure">
<t>
   Although fragment identifiers used within URI references are not sent
   in requests, implementers ought to be aware that they will be visible to
   the user agent and any extensions or scripts running as a result of the
   response. In particular, when a redirect occurs and the original request's
   fragment identifier is inherited by the new reference in
   <x:ref>Location</x:ref> (<xref target="header.location"/>), this might
   have the effect of disclosing one site's fragment to another site.
   If the first site uses personal information in fragments, it ought to
   ensure that redirects to other sites include a (possibly empty) fragment
   component in order to block that inheritance.
</t>
</section>

<section title="Disclosure of Product Information" anchor="disclosure.product.information">
<t>
   The <x:ref>User-Agent</x:ref> (<xref target="header.user-agent"/>),
   <x:ref>Via</x:ref> (&header-via;), and
   <x:ref>Server</x:ref> (<xref target="header.server"/>) header fields often
   reveal information about the respective sender's software systems.
   In theory, this can make it easier for an attacker to exploit known
   security holes; in practice, attackers tend to try all potential holes
   regardless of the apparent software versions being used.
</t>
<t>
   Proxies that serve as a portal through a network firewall ought to take
   special precautions regarding the transfer of header information that might
   identify hosts behind the firewall. The <x:ref>Via</x:ref> header field
   allows intermediaries to replace sensitive machine names with pseudonyms.
</t>
</section>

<section title="Browser Fingerprinting" anchor="fingerprinting">
<t>
   Browser fingerprinting is a set of techniques for identifying a specific
   user agent over time through its unique set of characteristics. These
   characteristics might include information related to its TCP behavior,
   feature capabilities, and scripting environment, though of particular
   interest here is the set of unique characteristics that might be
   communicated via HTTP. Fingerprinting is considered a privacy concern
   because it enables tracking of a user agent's behavior over time without
   the corresponding controls that the user might have over other forms of
   data collection (e.g., cookies). Many general-purpose user agents
   (i.e., Web browsers) have taken steps to reduce their fingerprints.
</t>
<t>
   There are a number of request header fields that might reveal information
   to servers that is sufficiently unique to enable fingerprinting.
   The <x:ref>From</x:ref> header field is the most obvious, though it is
   expected that From will only be sent when self-identification is desired by
   the user. Likewise, Cookie header fields are deliberately designed to
   enable re-identification, so fingerprinting concerns only apply to
   situations where cookies are disabled or restricted by the user agent's
   configuration.
</t>
<t>
   The <x:ref>User-Agent</x:ref> header field might contain enough information
   to uniquely identify a specific device, usually when combined with other
   characteristics, particularly if the user agent sends excessive details
   about the user's system or extensions. However, the source of unique
   information that is least expected by users is
   <x:ref>proactive negotiation</x:ref> (<xref target="request.conneg"/>),
   including the <x:ref>Accept</x:ref>, <x:ref>Accept-Charset</x:ref>,
   <x:ref>Accept-Encoding</x:ref>, and <x:ref>Accept-Language</x:ref>
   header fields.
</t>
<t>
   In addition to the fingerprinting concern, detailed use of the
   <x:ref>Accept-Language</x:ref> header field can reveal information the
   user might consider to be of a private nature. For example, understanding
   a given language set might be strongly correlated to membership in a
   particular ethnic group.
   An approach that limits such loss of privacy would be for a user agent
   to omit the sending of Accept-Language except for sites that have been
   whitelisted, perhaps via interaction after detecting a <x:ref>Vary</x:ref>
   header field that indicates language negotiation might be useful.
</t>
<t>
   In environments where proxies are used to enhance privacy, user agents
   ought to be conservative in sending proactive negotiation header fields.
   General-purpose user agents that provide a high degree of header field
   configurability ought to inform users about the loss of privacy that might
   result if too much detail is provided. As an extreme privacy measure,
   proxies could filter the proactive negotiation header fields in relayed
   requests.
</t>
</section>
</section>

<section title="Acknowledgments" anchor="acks">
<t>
  See &acks;.
</t>
</section>
</middle>
<back>

<references title="Normative References">

<reference anchor="RFC7230">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7230"/>
  <x:source href="rfc7230.xml" basename="rfc7230">
    <x:defines>close</x:defines>
    <x:defines>Connection</x:defines>
    <x:defines>Content-Length</x:defines>
    <x:defines>Host</x:defines>
    <x:defines>Transfer-Encoding</x:defines>
    <x:defines>Upgrade</x:defines>
    <x:defines>Via</x:defines>
    <x:defines>effective request URI</x:defines>
    <x:defines>target URI</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7232">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7232"/>
  <x:source href="rfc7232.xml" basename="rfc7232">
    <x:defines>304 (Not Modified)</x:defines>
    <x:defines>412 (Precondition Failed)</x:defines>
    <x:defines>ETag</x:defines>
    <x:defines>If-Match</x:defines>
    <x:defines>If-Modified-Since</x:defines>
    <x:defines>If-None-Match</x:defines>
    <x:defines>If-Unmodified-Since</x:defines>
    <x:defines>Last-Modified</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7233">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7233"/>
  <x:source href="rfc7233.xml" basename="rfc7233">
    <x:defines>206</x:defines>
    <x:defines>206 (Partial Content)</x:defines>
    <x:defines>416</x:defines>
    <x:defines>416 (Range Not Satisfiable)</x:defines>
    <x:defines>Content-Range</x:defines>
    <x:defines>If-Range</x:defines>
    <x:defines>Range</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7234">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
      <organization>Akamai</organization>
      <address><email>mnot@mnot.net</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7234"/>
  <x:source href="rfc7234.xml" basename="rfc7234"/>
</reference>

<reference anchor="RFC7235">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7235"/>
  <x:source href="rfc7235.xml" basename="rfc7235">
     <x:defines>401 (Unauthorized)</x:defines>
  </x:source>
</reference>

<reference anchor="RFC2045">
  <front>
    <title abbrev="Internet Message Bodies">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2045"/>
</reference>

<reference anchor="RFC2046">
  <front>
    <title abbrev="Media Types">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2046"/>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC3986">
 <front>
  <title abbrev='URI Generic Syntax'>Uniform Resource Identifier (URI): Generic Syntax</title>
  <author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
       <email>timbl@w3.org</email>
       <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>
  <author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
    <organization abbrev="Day Software">Day Software</organization>
    <address>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>
  <author initials='L.' surname='Masinter' fullname='Larry Masinter'>
    <organization abbrev="Adobe Systems">Adobe Systems Incorporated</organization>
    <address>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>
  <date month='January' year='2005'></date>
 </front>
 <seriesInfo name="STD" value="66"/>
 <seriesInfo name="RFC" value="3986"/>
</reference>

<reference anchor='RFC4647'>
  <front>
    <title>Matching of Language Tags</title>
    <author initials='A.' surname='Phillips' fullname='Addison Phillips' role="editor">
      <organization>Yahoo! Inc.</organization>
      <address><email>addison@inter-locale.com</email></address>
    </author>
    <author initials='M.' surname='Davis' fullname='Mark Davis' role="editor">
      <organization>Google</organization>
      <address><email>mark.davis@macchiato.com</email></address>
    </author>
    <date year='2006' month='September' />
  </front>
  <seriesInfo name='BCP' value='47' />
  <seriesInfo name='RFC' value='4647' />
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
        <email>dcrocker@bbiw.net</email>
      </address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
        <email>paul.overell@thus.net</email>
      </address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

<reference anchor='RFC5646'>
  <front>
    <title>Tags for Identifying Languages</title>
    <author initials='A.' surname='Phillips' fullname='Addison Phillips' role='editor'>
      <organization>Lab126</organization>
      <address><email>addison@inter-locale.com</email></address>
    </author>
    <author initials='M.' surname='Davis' fullname='Mark Davis' role='editor'>
      <organization>Google</organization>
      <address><email>mark.davis@google.com</email></address>
    </author>
    <date month='September' year='2009' />
  </front>
  <seriesInfo name='BCP' value='47' />
  <seriesInfo name='RFC' value='5646' />
</reference>

<reference anchor='RFC6365'>
  <front>
    <title>Terminology Used in Internationalization in the IETF</title>
    <author initials='P.' surname='Hoffman' fullname='P. Hoffman'/>
    <author initials='J.' surname='Klensin' fullname='J. Klensin'/>
    <date year='2011' month='September' />
  </front>
  <seriesInfo name='BCP' value='166' />
  <seriesInfo name='RFC' value='6365' />
</reference>

</references>

<references title="Informative References">

<reference anchor="REST" target="http://roy.gbiv.com/pubs/dissertation/top.htm">
  <front>
    <title>Architectural Styles and the Design of Network-based Software Architectures</title>
    <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
    </author>
    <date month="September" year="2000"/>
  </front>
  <x:prose>Doctoral Dissertation, University of California, Irvine</x:prose>
</reference>

<reference anchor="RFC1945">
  <front>
    <title abbrev="HTTP/1.0">Hypertext Transfer Protocol -- HTTP/1.0</title>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization>MIT, Laboratory for Computer Science</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
      <organization>University of California, Irvine, Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="H.F." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>W3 Consortium, MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1945"/>
</reference>

<reference anchor="RFC2049">
  <front>
    <title abbrev="MIME Conformance">Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2049"/>
</reference>

<reference anchor="RFC2068">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding">
      <organization>University of California, Irvine, Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization>Digital Equipment Corporation, Western Research Laboratory</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="January" year="1997"/>
  </front>
  <seriesInfo name="RFC" value="2068"/>
</reference>

<reference anchor='RFC2295'>
  <front>
    <title abbrev='HTTP Content Negotiation'>Transparent Content Negotiation in HTTP</title>
    <author initials='K.' surname='Holtman' fullname='Koen Holtman'>
      <organization>Technische Universiteit Eindhoven</organization>
      <address>
        <email>koen@win.tue.nl</email>
      </address>
    </author>
    <author initials='A.H.' surname='Mutz' fullname='Andrew H. Mutz'>
      <organization>Hewlett-Packard Company</organization>
      <address>
        <email>mutz@hpl.hp.com</email>
      </address>
    </author>
    <date year='1998' month='March'/>
  </front>
  <seriesInfo name='RFC' value='2295'/>
</reference>

<reference anchor="RFC2388">
  <front>
    <title abbrev="multipart/form-data">Returning Values from Forms:  multipart/form-data</title>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization>Xerox Palo Alto Research Center</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <date year="1998" month="August"/>
  </front>
  <seriesInfo name="RFC" value="2388"/>
</reference>

<reference anchor="RFC2557">
  <front>
    <title abbrev="MIME Encapsulation of Aggregate Documents">MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)</title>
    <author initials="F." surname="Palme" fullname="Jacob Palme">
      <organization>Stockholm University and KTH</organization>
      <address><email>jpalme@dsv.su.se</email></address>
    </author>
    <author initials="A." surname="Hopmann" fullname="Alex Hopmann">
      <organization>Microsoft Corporation</organization>
      <address><email>alexhop@microsoft.com</email></address>
    </author>
    <author initials="N." surname="Shelness" fullname="Nick Shelness">
      <organization>Lotus Development Corporation</organization>
      <address><email>Shelness@lotus.com</email></address>
    </author>
    <author initials="E." surname="Stefferud" fullname="Einar Stefferud">
      <address><email>stef@nma.com</email></address>
    </author>
    <date year="1999" month="March"/>
  </front>
  <seriesInfo name="RFC" value="2557"/>
</reference>

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor='RFC2774'>
  <front>
    <title>An HTTP Extension Framework</title>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials='P.' surname='Leach' fullname='Paul J. Leach'>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials='S.' surname='Lawrence' fullname='Scott Lawrence'>
      <address><email>lawrence@agranat.com</email></address>
    </author>
    <date year='2000' month='February' />
  </front>
  <seriesInfo name='RFC' value='2774' />
</reference>

<reference anchor='RFC2817'>
  <front>
    <title>Upgrading to TLS Within HTTP/1.1</title>
    <author initials='R.' surname='Khare' fullname='R. Khare'>
      <organization>4K Associates / UC Irvine</organization>
      <address><email>rohit@4K-associates.com</email></address>
    </author>
    <author initials='S.' surname='Lawrence' fullname='S. Lawrence'>
      <organization>Agranat Systems, Inc.</organization>
      <address><email>lawrence@agranat.com</email></address>
    </author>
    <date year='2000' month='May' />
  </front>
  <seriesInfo name='RFC' value='2817' />
</reference>

<reference anchor='RFC2978'>
  <front>
    <title>IANA Charset Registration Procedures</title>
    <author initials='N.' surname='Freed' fullname='N. Freed'/>
    <author initials='J.' surname='Postel' fullname='J. Postel'/>
    <date year='2000' month='October' />
  </front>
   <seriesInfo name='BCP' value='19' />
   <seriesInfo name='RFC' value='2978' />
</reference>

<reference anchor='RFC5905'>
  <front>
    <title>Network Time Protocol Version 4: Protocol and Algorithms Specification</title>
    <author initials='D.' surname='Mills' fullname='David L. Mills'/>
    <author initials='J.' surname='Martin' fullname='Jim Martin' role="editor"/>
    <author initials='J.' surname='Burbank' fullname='Jack Burbank'/>
    <author initials='W.' surname='Kasch' fullname='William Kasch'/>
    <date year='2010' month='June' />
  </front>
  <seriesInfo name='RFC' value='5905' />
</reference>

<reference anchor='BCP90'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

<reference anchor="BCP13">
  <front>
    <title>Media Type Specifications and Registration Procedures</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Oracle</organization>
      <address>
        <email>ned+ietf@mrochek.com</email>
      </address>
    </author>
    <author initials="J." surname="Klensin" fullname="John C. Klensin">
      <address>
        <email>john+ietf@jck.com</email>
      </address>
    </author>
    <author initials="T." surname="Hansen" fullname="Tony Hansen">
      <organization>AT&amp;T Laboratories</organization>
      <address>
        <email>tony+mtsuffix@maillennium.att.com</email>
      </address>
    </author>
    <date year="2013" month="January"/>
  </front>
  <seriesInfo name="BCP" value="13"/>
  <seriesInfo name="RFC" value="6838"/>
</reference>

<reference anchor='RFC5226'>
  <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author initials='T.' surname='Narten' fullname='T. Narten'>
      <organization>IBM</organization>
      <address><email>narten@us.ibm.com</email></address>
    </author>
    <author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
      <organization>Google</organization>
      <address><email>Harald@Alvestrand.no</email></address>
    </author>
    <date year='2008' month='May' />
  </front>
  <seriesInfo name='BCP' value='26' />
  <seriesInfo name='RFC' value='5226' />
</reference>

<reference anchor='RFC5246'>
   <front>
      <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
      <author initials='T.' surname='Dierks' fullname='T. Dierks'/>
      <author initials='E.' surname='Rescorla' fullname='E. Rescorla'/>
      <date year='2008' month='August' />
   </front>
   <seriesInfo name='RFC' value='5246' />
</reference>

<reference anchor="RFC5322">
  <front>
    <title>Internet Message Format</title>
    <author initials="P." surname="Resnick" fullname="P. Resnick">
      <organization>Qualcomm Incorporated</organization>
    </author>
    <date year="2008" month="October"/>
  </front> 
  <seriesInfo name="RFC" value="5322"/>
</reference>

<reference anchor='RFC5789'>
  <front>
    <title>PATCH Method for HTTP</title>
    <author initials='L.' surname='Dusseault' fullname='L. Dusseault'>
      <organization>Linden Lab</organization>
    </author>
    <author initials='J.' surname='Snell' fullname='J. Snell' />
    <date year='2010' month='March' />
  </front>
  <seriesInfo name='RFC' value='5789' />
</reference>

<reference anchor="RFC5987">
	<front>
    <title>Character Set and Language Encoding for Hypertext Transfer Protocol (HTTP) Header Field Parameters</title>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address>
        <postal>
          <street>Hafenweg 16</street>
          <city>Muenster</city><region>NW</region><code>48155</code>
          <country>Germany</country>
        </postal>
        <email>julian.reschke@greenbytes.de</email>	
        <uri>http://greenbytes.de/tech/webdav/</uri>	
      </address>
    </author>
    <date month="August" year="2010"/>
  </front>
  <seriesInfo name="RFC" value="5987"/>
</reference>

<reference anchor='RFC5988'>
  <front>
    <title>Web Linking</title>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'/>
    <date year='2010' month='October' />
  </front>
  <seriesInfo name='RFC' value='5988' />
</reference>

<reference anchor="RFC6265">
  <front>
    <title>HTTP State Management Mechanism</title>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization abbrev="U.C. Berkeley">
        University of California, Berkeley
      </organization>
      <address><email>abarth@eecs.berkeley.edu</email></address>
    </author>
    <date year="2011" month="April" />
  </front>
  <seriesInfo name="RFC" value="6265"/>
</reference>

<reference anchor="RFC6266">
  <front>
    <title abbrev="Content-Disposition in HTTP">Use of the Content-Disposition Header Field
    in the Hypertext Transfer Protocol (HTTP)</title>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address>
        <email>julian.reschke@greenbytes.de</email>
      </address>
    </author>
    <date month="June" year="2011"/>
  </front>
  <seriesInfo name='RFC' value='6266' />
</reference>

<reference anchor="BCP178">
  <front>
    <title>Deprecating the "X-" Prefix and Similar Constructs in Application Protocols</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre"/>
    <author initials="D." surname="Crocker" fullname="Dave Crocker"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham"/>
    <date year="2012" month="June"/>
  </front>
  <seriesInfo name="BCP" value="178"/>
  <seriesInfo name="RFC" value="6648"/>
</reference>

<reference anchor="RFC7238">
	<front>
    <title abbrev="HTTP Status Code 308">The Hypertext Transfer Protocol (HTTP) Status Code 308 (Permanent Redirect)</title>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address>
        <email>julian.reschke@greenbytes.de</email>	
      </address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7238"/>
</reference>

<reference anchor="OWASP" target="https://www.owasp.org/">
	<front>
    <title abbrev="OWASP">A Guide to Building Secure Web Applications and Web Services</title>
    <author role="editor" initials="A." surname="van der Stock"
            fullname="Andrew van der Stock"/>
    <date month="July" day="27" year="2005"/>
  </front>
  <seriesInfo name="The Open Web Application Security Project (OWASP)" value="2.0.1"/>
</reference>
</references>

<section title="Differences between HTTP and MIME" anchor="differences.between.http.and.mime">
<t>
   HTTP/1.1 uses many of the constructs defined for the
   Internet Message Format <xref target="RFC5322"/> and the Multipurpose
   Internet Mail Extensions (MIME) <xref target="RFC2045"/> to
   allow a message body to be transmitted in an open variety of
   representations and with extensible header fields. However, RFC 2045
   is focused only on email; applications of HTTP have many characteristics
   that differ from email; hence, HTTP has features that differ from MIME.
   These differences were carefully chosen to optimize performance over binary
   connections, to allow greater freedom in the use of new media types, to
   make date comparisons easier, and to acknowledge the practice of some early
   HTTP servers and clients.
</t>
<t>
   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to and from strict MIME environments need to be
   aware of these differences and provide the appropriate conversions
   where necessary.
</t>

<section title="MIME-Version" anchor="mime-version">
  <iref primary="true" item="MIME-Version header field" x:for-anchor=""/>
  <x:anchor-alias value="MIME-Version"/>
<t>
   HTTP is not a MIME-compliant protocol. However, messages can
   include a single MIME-Version header field to indicate what
   version of the MIME protocol was used to construct the message. Use
   of the MIME-Version header field indicates that the message is in
   full conformance with the MIME protocol (as defined in <xref target="RFC2045"/>).
   Senders are responsible for ensuring full conformance (where
   possible) when exporting HTTP messages to strict MIME environments.
</t>
</section>

<section title="Conversion to Canonical Form" anchor="conversion.to.canonical.form">
<t>
   MIME requires that an Internet mail body part be converted to canonical
   form prior to being transferred, as described in <xref target="RFC2049"
   x:fmt="of" x:sec="4"/>. <xref target="canonicalization.and.text.defaults"/>
   of this document describes the forms allowed for subtypes of the "text"
   media type when transmitted over HTTP. <xref target="RFC2046"/> requires
   that content with a type of "text" represent line breaks as CRLF and
   forbids the use of CR or LF outside of line break sequences. HTTP allows
   CRLF, bare CR, and bare LF to indicate a line break within text content.
</t>
<t>
   A proxy or gateway from HTTP to a strict MIME
   environment ought to translate all line breaks within the text media
   types described in <xref target="canonicalization.and.text.defaults"/>
   of this document to the RFC 2049 canonical form of CRLF. Note, however,
   this might be complicated by the presence of a <x:ref>Content-Encoding</x:ref>
   and by the fact that HTTP allows the use of some charsets
   that do not use octets 13 and 10 to represent CR and LF, respectively.
</t>
<t>
   Conversion will break any cryptographic
   checksums applied to the original content unless the original content
   is already in canonical form. Therefore, the canonical form is
   recommended for any content that uses such checksums in HTTP.
</t>
</section>


<section title="Conversion of Date Formats" anchor="conversion.of.date.formats">
<t>
   HTTP/1.1 uses a restricted set of date formats (&http-date;) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols ought to ensure that any <x:ref>Date</x:ref> header field
   present in a message conforms to one of the HTTP/1.1 formats and rewrite
   the date if necessary.
</t>
</section>

<section title="Conversion of Content-Encoding" anchor="conversion.content-encoding">
<t>
   MIME does not include any concept equivalent to HTTP/1.1's
   <x:ref>Content-Encoding</x:ref> header field. Since this acts as a modifier
   on the media type, proxies and gateways from HTTP to MIME-compliant
   protocols ought to either change the value of the <x:ref>Content-Type</x:ref>
   header field or decode the representation before forwarding the message.
   (Some experimental applications of Content-Type for Internet mail have used
   a media-type parameter of ";conversions=&lt;content-coding&gt;" to perform
   a function equivalent to Content-Encoding. However, this parameter is
   not part of the MIME standards).
</t>
</section>

<section title="Conversion of Content-Transfer-Encoding" anchor="conversion.content-transfer-encoding">
  <iref item="Content-Transfer-Encoding header field" x:for-anchor=""/>
<t>
   HTTP does not use the Content-Transfer-Encoding field of MIME.
   Proxies and gateways from MIME-compliant protocols to HTTP need to remove
   any Content-Transfer-Encoding prior to delivering the response message to
   an HTTP client.
</t>
<t>
   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where "safe
   transport" is defined by the limitations of the protocol being used.
   Such a proxy or gateway ought to transform and label the data with an
   appropriate Content-Transfer-Encoding if doing so will improve the
   likelihood of safe transport over the destination protocol.
</t>
</section>

<section title="MHTML and Line Length Limitations" anchor="mhtml.line.length">
<t>
   HTTP implementations that share code with MHTML <xref target="RFC2557"/>
   implementations need to be aware of MIME line length limitations.
   Since HTTP does not have this limitation, HTTP does not fold long lines.
   MHTML messages being transported by HTTP follow all conventions of MHTML,
   including line length limitations and folding, canonicalization, etc.,
   since HTTP transfers message-bodies as payload and, aside from the
   "multipart/byteranges" type (&multipart-byteranges;), does not interpret
   the content or any MIME header lines that might be contained therein.
</t>
</section>
</section>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
   The primary changes in this revision have been editorial in nature:
   extracting the messaging syntax and partitioning HTTP semantics into
   separate documents for the core features, conditional requests, partial
   requests, caching, and authentication.  The conformance language has been
   revised to clearly target requirements and the terminology has been
   improved to distinguish payload from representations and representations
   from resources.
</t>
<t>
   A new requirement has been added that semantics embedded in a URI
   be disabled when those semantics are inconsistent with the request
   method, since this is a common cause of interoperability failure.
   (<xref target="resources"/>)
</t>
<t>
   An algorithm has been added for determining if a payload is associated with
   a specific identifier.
   (<xref target="identifying.payload" />)
</t>
<t>
   The default charset of ISO-8859-1 for text media types has been removed;
   the default is now whatever the media type definition says. Likewise,
   special treatment of ISO-8859-1 has been removed from the
   <x:ref>Accept-Charset</x:ref> header field.
   (<xref target="canonicalization.and.text.defaults"/> and <xref target="header.accept-charset"/>)
</t>
<t>
   The definition of <x:ref>Content-Location</x:ref> has been changed to no
   longer affect the base URI for resolving relative URI references, due to
   poor implementation support and the undesirable effect of potentially
   breaking relative links in content-negotiated resources.
   (<xref target="header.content-location"/>)
</t>
<t>
   To be consistent with the method-neutral parsing algorithm of
   <xref target="RFC7230"/>, the definition of GET has been relaxed so that
   requests can have a body, even though a body has no meaning for GET.
   (<xref target="GET"/>)
</t>
<t>
   Servers are no longer required to handle all Content-* header fields and
   use of <x:ref>Content-Range</x:ref> has been explicitly banned in PUT
   requests.
   (<xref target="PUT"/>)
</t>
<t>
   Definition of the CONNECT method has been moved from
   <xref target="RFC2817"/> to this specification.
   (<xref target="CONNECT"/>)
</t>
<t>
   The <x:ref>OPTIONS</x:ref> and <x:ref>TRACE</x:ref> request methods have been
   defined as being safe.
   (<xref target="OPTIONS"/> and <xref target="TRACE"/>) 
</t>
<t>
   The <x:ref>Expect</x:ref> header field's extension mechanism has been removed
   due to widely-deployed broken implementations.
   (<xref target="header.expect"/>)
</t>
<t>
   The <x:ref>Max-Forwards</x:ref> header field has been restricted to the
   <x:ref>OPTIONS</x:ref> and <x:ref>TRACE</x:ref> methods; previously,
   extension methods could have used it as well.
   (<xref target="header.max-forwards"/>) 
</t>
<t>
   The "about:blank" URI has been suggested as a value for the
   <x:ref>Referer</x:ref> header field when no referring URI is applicable,
   which distinguishes that case from others where the Referer field is
   not sent or has been removed.
   (<xref target="header.referer"/>)
</t>
<t>
   The following status codes are now cacheable (that is, they can be stored and
   reused by a cache without explicit freshness information present): 204, 404, 
   405, 414, 501.
   (<xref target="status.codes"/>)
</t>
<t>
   The <x:ref>201 (Created)</x:ref> status description has been changed to
   allow for the possibility that more than one resource has been created.
   (<xref target="status.201"/>)
</t>
<t>
   The definition of <x:ref>203 (Non-Authoritative Information)</x:ref> has
   been broadened to include cases of payload transformations as well.
   (<xref target="status.203"/>)
</t>
<t>
   The set of request methods that are safe to automatically redirect is no
   longer closed; user agents are able to make that determination
   based upon the request method semantics.
   The redirect status codes <x:ref>301</x:ref>, <x:ref>302</x:ref>, and
   <x:ref>307</x:ref> no longer have normative requirements on response
   payloads and user interaction.
   (<xref target="status.3xx"/>)
</t>
<t>
   The status codes <x:ref>301</x:ref> and <x:ref>302</x:ref> have been
   changed to allow user agents to rewrite the method from POST to GET.
   (Sections <xref format="counter" target="status.301"/> and
   <xref format="counter" target="status.302"/>)
</t>
<t>
   The description of the <x:ref>303 (See Other)</x:ref> status code has been changed to allow
   it to be cached if explicit freshness information is given, and a specific
   definition has been added for a 303 response to GET.
   (<xref target="status.303"/>)
</t>
<t>
   The <x:ref>305 (Use Proxy)</x:ref> status code has been deprecated due to
   security concerns regarding in-band configuration of a proxy.
   (<xref target="status.305"/>)
</t>
<t>
   The <x:ref>400 (Bad Request)</x:ref> status code has been relaxed so that
   it isn't limited to syntax errors.
   (<xref target="status.400"/>)
</t>
<t>
   The <x:ref>426 (Upgrade Required)</x:ref> status code has been incorporated
   from <xref target="RFC2817"/>.
   (<xref target="status.426"/>)
</t>
<t>
   The target of requirements on HTTP-date and the Date header field have been
   reduced to those systems generating the date, rather than all systems
   sending a date.
   (<xref target="origination.date"/>)
</t>
<t>
   The syntax of the <x:ref>Location</x:ref> header field has been changed
   to allow all URI references, including relative references and fragments,
   along with some clarifications as to when use of fragments would not be
   appropriate.
   (<xref target="header.location"/>)
</t>
<t>
   <x:ref>Allow</x:ref> has been reclassified as a response header field,
   removing the option to specify it in a PUT request.
   Requirements relating to the content of Allow have been relaxed;
   correspondingly, clients are not required to always trust its value.
   (<xref target="header.allow"/>)
</t>
<t>
   A Method Registry has been defined.
   (<xref target="method.registry"/>)
</t>
<t>
   The Status Code Registry  has been
   redefined by this specification; previously, it was defined in
   <xref target="RFC2817" x:fmt="of" x:sec="7.1"/>.
   (<xref target="status.code.registry"/>)
</t>
<t>
   Registration of content codings has been changed to require IETF Review.
   (<xref target="content.coding.registry"/>)
</t>
<t>
   The Content-Disposition header field has been removed since it is now
   defined by <xref target="RFC6266"/>.
</t>
<t>
   The Content-MD5 header field has been removed because it was inconsistently
   implemented with respect to partial responses.
</t>
</section>

<section title="Imported ABNF" anchor="imported.abnf">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="SP"/>
  <x:anchor-alias value="VCHAR"/>
  <x:anchor-alias value="field-name"/>
  <x:anchor-alias value="quoted-string"/>
  <x:anchor-alias value="token"/>
  <x:anchor-alias value="BWS"/>
  <x:anchor-alias value="OWS"/>
  <x:anchor-alias value="RWS"/>
  <x:anchor-alias value="absolute-URI"/>
  <x:anchor-alias value="comment"/>
  <x:anchor-alias value="partial-URI"/>
  <x:anchor-alias value="URI-reference"/>
<t>
  The following core rules are included by
  reference, as defined in <xref target="RFC5234" x:fmt="of" x:sec="B.1"/>:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space), and
  VCHAR (any visible US-ASCII character).
</t>
<t>
  The rules below are defined in <xref target="RFC7230"/>:
</t>
<figure><artwork type="abnf2616">
  <x:ref>BWS</x:ref>           = &lt;BWS, see &whitespace;&gt;
  <x:ref>OWS</x:ref>           = &lt;OWS, see &whitespace;&gt;
  <x:ref>RWS</x:ref>           = &lt;RWS, see &whitespace;&gt;
  <x:ref>URI-reference</x:ref> = &lt;URI-reference, see &uri;&gt;
  <x:ref>absolute-URI</x:ref>  = &lt;absolute-URI, see &uri;&gt;
  <x:ref>comment</x:ref>       = &lt;comment, see &field-components;&gt;
  <x:ref>field-name</x:ref>    = &lt;comment, see &header-fields;&gt;
  <x:ref>partial-URI</x:ref>   = &lt;partial-URI, see &uri;&gt;
  <x:ref>quoted-string</x:ref> = &lt;quoted-string, see &field-components;&gt;
  <x:ref>token</x:ref>         = &lt;token, see &field-components;&gt;
</artwork></figure>
</section>

<?BEGININC p2-semantics.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<t>
  In the collected ABNF below, list rules are expanded as per <xref target="RFC7230" x:rel="#notation"/>.
</t><figure>
<artwork type="abnf" name="p2-semantics.parsed-abnf">
<x:ref>Accept</x:ref> = [ ( "," / ( media-range [ accept-params ] ) ) *( OWS "," [
 OWS ( media-range [ accept-params ] ) ] ) ]
<x:ref>Accept-Charset</x:ref> = *( "," OWS ) ( ( charset / "*" ) [ weight ] ) *( OWS
 "," [ OWS ( ( charset / "*" ) [ weight ] ) ] )
<x:ref>Accept-Encoding</x:ref> = [ ( "," / ( codings [ weight ] ) ) *( OWS "," [ OWS
 ( codings [ weight ] ) ] ) ]
<x:ref>Accept-Language</x:ref> = *( "," OWS ) ( language-range [ weight ] ) *( OWS
 "," [ OWS ( language-range [ weight ] ) ] )
<x:ref>Allow</x:ref> = [ ( "," / method ) *( OWS "," [ OWS method ] ) ]

<x:ref>BWS</x:ref> = &lt;BWS, see [RFC7230], Section 3.2.3&gt;

<x:ref>Content-Encoding</x:ref> = *( "," OWS ) content-coding *( OWS "," [ OWS
 content-coding ] )
<x:ref>Content-Language</x:ref> = *( "," OWS ) language-tag *( OWS "," [ OWS
 language-tag ] )
<x:ref>Content-Location</x:ref> = absolute-URI / partial-URI
<x:ref>Content-Type</x:ref> = media-type

<x:ref>Date</x:ref> = HTTP-date

<x:ref>Expect</x:ref> = "100-continue"

<x:ref>From</x:ref> = mailbox

<x:ref>GMT</x:ref> = %x47.4D.54 ; GMT

<x:ref>HTTP-date</x:ref> = IMF-fixdate / obs-date

<x:ref>IMF-fixdate</x:ref> = day-name "," SP date1 SP time-of-day SP GMT

<x:ref>Location</x:ref> = URI-reference

<x:ref>Max-Forwards</x:ref> = 1*DIGIT

<x:ref>OWS</x:ref> = &lt;OWS, see [RFC7230], Section 3.2.3&gt;

<x:ref>RWS</x:ref> = &lt;RWS, see [RFC7230], Section 3.2.3&gt;
<x:ref>Referer</x:ref> = absolute-URI / partial-URI
<x:ref>Retry-After</x:ref> = HTTP-date / delay-seconds

<x:ref>Server</x:ref> = product *( RWS ( product / comment ) )

<x:ref>URI-reference</x:ref> = &lt;URI-reference, see [RFC7230], Section 2.7&gt;
<x:ref>User-Agent</x:ref> = product *( RWS ( product / comment ) )

<x:ref>Vary</x:ref> = "*" / ( *( "," OWS ) field-name *( OWS "," [ OWS field-name ]
 ) )

<x:ref>absolute-URI</x:ref> = &lt;absolute-URI, see [RFC7230], Section 2.7&gt;
<x:ref>accept-ext</x:ref> = OWS ";" OWS token [ "=" ( token / quoted-string ) ]
<x:ref>accept-params</x:ref> = weight *accept-ext
<x:ref>asctime-date</x:ref> = day-name SP date3 SP time-of-day SP year

<x:ref>charset</x:ref> = token
<x:ref>codings</x:ref> = content-coding / "identity" / "*"
<x:ref>comment</x:ref> = &lt;comment, see [RFC7230], Section 3.2.6&gt;
<x:ref>content-coding</x:ref> = token

<x:ref>date1</x:ref> = day SP month SP year
<x:ref>date2</x:ref> = day "-" month "-" 2DIGIT
<x:ref>date3</x:ref> = month SP ( 2DIGIT / ( SP DIGIT ) )
<x:ref>day</x:ref> = 2DIGIT
<x:ref>day-name</x:ref> = %x4D.6F.6E ; Mon
 / %x54.75.65 ; Tue
 / %x57.65.64 ; Wed
 / %x54.68.75 ; Thu
 / %x46.72.69 ; Fri
 / %x53.61.74 ; Sat
 / %x53.75.6E ; Sun
<x:ref>day-name-l</x:ref> = %x4D.6F.6E.64.61.79 ; Monday
 / %x54.75.65.73.64.61.79 ; Tuesday
 / %x57.65.64.6E.65.73.64.61.79 ; Wednesday
 / %x54.68.75.72.73.64.61.79 ; Thursday
 / %x46.72.69.64.61.79 ; Friday
 / %x53.61.74.75.72.64.61.79 ; Saturday
 / %x53.75.6E.64.61.79 ; Sunday
<x:ref>delay-seconds</x:ref> = 1*DIGIT

<x:ref>field-name</x:ref> = &lt;comment, see [RFC7230], Section 3.2&gt;

<x:ref>hour</x:ref> = 2DIGIT

<x:ref>language-range</x:ref> = &lt;language-range, see [RFC4647], Section 2.1&gt;
<x:ref>language-tag</x:ref> = &lt;Language-Tag, see [RFC5646], Section 2.1&gt;

<x:ref>mailbox</x:ref> = &lt;mailbox, see [RFC5322], Section 3.4&gt;
<x:ref>media-range</x:ref> = ( "*/*" / ( type "/*" ) / ( type "/" subtype ) ) *( OWS
 ";" OWS parameter )
<x:ref>media-type</x:ref> = type "/" subtype *( OWS ";" OWS parameter )
<x:ref>method</x:ref> = token
<x:ref>minute</x:ref> = 2DIGIT
<x:ref>month</x:ref> = %x4A.61.6E ; Jan
 / %x46.65.62 ; Feb
 / %x4D.61.72 ; Mar
 / %x41.70.72 ; Apr
 / %x4D.61.79 ; May
 / %x4A.75.6E ; Jun
 / %x4A.75.6C ; Jul
 / %x41.75.67 ; Aug
 / %x53.65.70 ; Sep
 / %x4F.63.74 ; Oct
 / %x4E.6F.76 ; Nov
 / %x44.65.63 ; Dec

<x:ref>obs-date</x:ref> = rfc850-date / asctime-date

<x:ref>parameter</x:ref> = token "=" ( token / quoted-string )
<x:ref>partial-URI</x:ref> = &lt;partial-URI, see [RFC7230], Section 2.7&gt;
<x:ref>product</x:ref> = token [ "/" product-version ]
<x:ref>product-version</x:ref> = token

<x:ref>quoted-string</x:ref> = &lt;quoted-string, see [RFC7230], Section 3.2.6&gt;
<x:ref>qvalue</x:ref> = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )

<x:ref>rfc850-date</x:ref> = day-name-l "," SP date2 SP time-of-day SP GMT

<x:ref>second</x:ref> = 2DIGIT
<x:ref>subtype</x:ref> = token

<x:ref>time-of-day</x:ref> = hour ":" minute ":" second
<x:ref>token</x:ref> = &lt;token, see [RFC7230], Section 3.2.6&gt;
<x:ref>type</x:ref> = token

<x:ref>weight</x:ref> = OWS ";" OWS "q=" qvalue

<x:ref>year</x:ref> = 4DIGIT
</artwork>
</figure>
</section>
<?ENDINC p2-semantics.abnf-appendix ?>
</back>
</rfc>
