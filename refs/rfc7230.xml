<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY mdash "&#8212;">
  <!ENTITY nbsp "&#160;">
  <!ENTITY nbhy  "&#x2011;">
  <!ENTITY Note "<x:h xmlns:x='http://purl.org/net/xml2rfc/ext'>Note:</x:h>">
  <!ENTITY caching-overview       "<xref target='RFC7234' x:rel='#caching.overview' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY cache-incomplete       "<xref target='RFC7234' x:rel='#response.cacheability' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY cache-poisoning        "<xref target='RFC7234' x:rel='#security.considerations' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY payload                "<xref target='RFC7231' x:rel='#payload' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY media-type             "<xref target='RFC7231' x:rel='#media.type' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY content-codings        "<xref target='RFC7231' x:rel='#content.codings' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY CONNECT                "<xref target='RFC7231' x:rel='#CONNECT' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY content.negotiation    "<xref target='RFC7231' x:rel='#content.negotiation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY diff-mime              "<xref target='RFC7231' x:rel='#differences.between.http.and.mime' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY representation         "<xref target='RFC7231' x:rel='#representations' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY GET                    "<xref target='RFC7231' x:rel='#GET' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY HEAD                   "<xref target='RFC7231' x:rel='#HEAD' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-allow           "<xref target='RFC7231' x:rel='#header.allow' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-cache-control   "<xref target='RFC7234' x:rel='#header.cache-control' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-encoding    "<xref target='RFC7231' x:rel='#header.content-encoding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-location    "<xref target='RFC7231' x:rel='#header.content-location' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-range   "<xref target='RFC7233' x:rel='#header.content-range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-type    "<xref target='RFC7231' x:rel='#header.content-type' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-date            "<xref target='RFC7231' x:rel='#header.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-etag            "<xref target='RFC7232' x:rel='#header.etag' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-expect          "<xref target='RFC7231' x:rel='#header.expect' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-expires         "<xref target='RFC7234' x:rel='#header.expires' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-last-modified   "<xref target='RFC7232' x:rel='#header.last-modified' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-mime-version    "<xref target='RFC7231' x:rel='#mime-version' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-pragma          "<xref target='RFC7234' x:rel='#header.pragma' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-proxy-authenticate  "<xref target='RFC7235' x:rel='#header.proxy-authenticate' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-proxy-authorization "<xref target='RFC7235' x:rel='#header.proxy-authorization' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-server          "<xref target='RFC7231' x:rel='#header.server' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-warning         "<xref target='RFC7234' x:rel='#header.warning' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY idempotent-methods     "<xref target='RFC7231' x:rel='#idempotent.methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY safe-methods           "<xref target='RFC7231' x:rel='#safe.methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY methods                "<xref target='RFC7231' x:rel='#methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY OPTIONS                "<xref target='RFC7231' x:rel='#OPTIONS' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY qvalue                 "<xref target='RFC7231' x:rel='#quality.values' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY request-header-fields  "<xref target='RFC7231' x:rel='#request.header.fields' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY response-control-data  "<xref target='RFC7231' x:rel='#response.control.data' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY resource               "<xref target='RFC7231' x:rel='#resources' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY semantics              "<xref target='RFC7231' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-codes           "<xref target='RFC7231' x:rel='#status.codes' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-1xx             "<xref target='RFC7231' x:rel='#status.1xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-203             "<xref target='RFC7231' x:rel='#status.203' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-3xx             "<xref target='RFC7231' x:rel='#status.3xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-304             "<xref target='RFC7232' x:rel='#status.304' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-4xx             "<xref target='RFC7231' x:rel='#status.4xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-413             "<xref target='RFC7231' x:rel='#status.413' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-414             "<xref target='RFC7231' x:rel='#status.414' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY iana-header-registry   "<xref target='RFC7231' x:rel='#header.field.registry' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2145, 2616" updates="2817, 2818" category="std" x:maturity-level="proposed"
     ipr="pre5378Trust200902" number="7230" consensus="yes"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
<x:link rel="next" basename="rfc7231"/>
<!--<x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>-->
<front>

  <title abbrev="HTTP/1.1 Message Syntax and Routing">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="June" year="2014"/>

  <area>Applications</area>
  <workgroup>HTTPbis</workgroup>
  
  <keyword>Hypertext Transfer Protocol</keyword>
  <keyword>HTTP</keyword>
  <keyword>HTTP message format</keyword>
  
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is a stateless application-level
   protocol for distributed, collaborative, hypertext information systems.
   This document provides an overview of HTTP architecture and its associated
   terminology, defines the "http" and "https" Uniform Resource Identifier
   (URI) schemes, defines the HTTP/1.1 message syntax and parsing
   requirements, and describes related security concerns for implementations.
</t>   
</abstract>
</front>
<middle>
<section title="Introduction" anchor="introduction">
<t>
   The Hypertext Transfer Protocol (HTTP) is a stateless application-level
   request/response protocol that uses extensible semantics and
   self-descriptive message payloads for flexible interaction with
   network-based hypertext information systems. This document is the first in
   a series of documents that collectively form the HTTP/1.1 specification:
   <list style="numbers">
    <t>"Message Syntax and Routing" (this document)</t>
    <t>"Semantics and Content" <xref target="RFC7231"/></t>
    <t>"Conditional Requests" <xref target="RFC7232"/></t>
    <t>"Range Requests" <xref target="RFC7233"/></t>
    <t>"Caching" <xref target="RFC7234"/></t>
    <t>"Authentication" <xref target="RFC7235"/></t>
   </list>
</t>
<t>
   This HTTP/1.1 specification obsoletes 
   <xref target="RFC2616" x:fmt="none">RFC 2616</xref> and
   <xref target="RFC2145" x:fmt="none">RFC 2145</xref> (on HTTP versioning).
   This specification also updates the use of CONNECT to establish a tunnel,
   previously defined in <xref target="RFC2817" x:fmt="none">RFC 2817</xref>,
   and defines the "https" URI scheme that was described informally in
   <xref target="RFC2818" x:fmt="none">RFC 2818</xref>.
</t>
<t>
   HTTP is a generic interface protocol for information systems. It is
   designed to hide the details of how a service is implemented by presenting
   a uniform interface to clients that is independent of the types of
   resources provided. Likewise, servers do not need to be aware of each
   client's purpose: an HTTP request can be considered in isolation rather
   than being associated with a specific type of client or a predetermined
   sequence of application steps. The result is a protocol that can be used
   effectively in many different contexts and for which implementations can
   evolve independently over time.
</t>
<t>
   HTTP is also designed for use as an intermediation protocol for translating
   communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative information
   services by translating their diverse protocols into a hypertext
   format that can be viewed and manipulated by clients in the same way
   as HTTP services.
</t>
<t>
   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface. Instead, we
   are limited to defining the syntax of communication, the intent
   of received communication, and the expected behavior of recipients.
   If the communication is considered in isolation, then successful
   actions ought to be reflected in corresponding changes to the
   observable interface provided by servers. However, since multiple
   clients might act in parallel and perhaps at cross-purposes, we
   cannot require that such changes be observable beyond the scope
   of a single response.
</t>
<t>
   This document describes the architectural elements that are used or
   referred to in HTTP, defines the "http" and "https" URI schemes,
   describes overall network operation and connection management,
   and defines HTTP message framing and forwarding requirements.
   Our goal is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining the
   complete set of requirements for message parsers and
   message-forwarding intermediaries.
</t>


<section title="Requirements Notation" anchor="intro.requirements">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   Conformance criteria and considerations regarding error handling
   are defined in <xref target="conformance"/>.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
<iref primary="true" item="Grammar" subitem="ALPHA"/>
<iref primary="true" item="Grammar" subitem="CR"/>
<iref primary="true" item="Grammar" subitem="CRLF"/>
<iref primary="true" item="Grammar" subitem="CTL"/>
<iref primary="true" item="Grammar" subitem="DIGIT"/>
<iref primary="true" item="Grammar" subitem="DQUOTE"/>
<iref primary="true" item="Grammar" subitem="HEXDIG"/>
<iref primary="true" item="Grammar" subitem="HTAB"/>
<iref primary="true" item="Grammar" subitem="LF"/>
<iref primary="true" item="Grammar" subitem="OCTET"/>
<iref primary="true" item="Grammar" subitem="SP"/>
<iref primary="true" item="Grammar" subitem="VCHAR"/>
<t>
   This specification uses the Augmented Backus-Naur Form (ABNF) notation of
   <xref target="RFC5234"/> with a list extension, defined in
   <xref target="abnf.extension"/>, that allows for compact definition of
   comma-separated lists using a '#' operator (similar to how the '*' operator
   indicates repetition).
   <xref target="collected.abnf"/> shows the collected grammar with all list
   operators expanded to standard ABNF notation.
</t>
<t anchor="core.rules">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CTL"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="CRLF"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="DQUOTE"/>
  <x:anchor-alias value="HEXDIG"/>
  <x:anchor-alias value="HTAB"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="SP"/>
  <x:anchor-alias value="VCHAR"/>
   The following core rules are included by
   reference, as defined in <xref target="RFC5234" x:fmt="," x:sec="B.1"/>:
   ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
   DIGIT (decimal 0-9), DQUOTE (double quote),
   HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed),
   OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible <xref target="USASCII"/> character).
</t>
<t>
   As a convention, ABNF rule names prefixed with "obs-" denote
   "obsolete" grammar rules that appear for historical reasons.
</t>
</section>
</section>

<section title="Architecture" anchor="architecture">
<t>
   HTTP was created for the World Wide Web (WWW) architecture
   and has evolved over time to support the scalability needs of a worldwide
   hypertext system. Much of that architecture is reflected in the terminology
   and syntax productions used to define HTTP.
</t>

<section title="Client/Server Messaging" anchor="operation">
<iref primary="true" item="client"/>
<iref primary="true" item="server"/>
<iref primary="true" item="connection"/>
<t>
   HTTP is a stateless request/response protocol that operates by exchanging
   <x:dfn>messages</x:dfn> (<xref target="http.message"/>) across a reliable
   transport- or session-layer
   "<x:dfn>connection</x:dfn>" (<xref target="connection.management"/>).
   An HTTP "<x:dfn>client</x:dfn>" is a program that establishes a connection
   to a server for the purpose of sending one or more HTTP requests.
   An HTTP "<x:dfn>server</x:dfn>" is a program that accepts connections
   in order to service HTTP requests by sending HTTP responses.
</t>
<iref primary="true" item="user agent"/>
<iref primary="true" item="origin server"/>
<iref primary="true" item="browser"/>
<iref primary="true" item="spider"/>
<iref primary="true" item="sender"/>
<iref primary="true" item="recipient"/>
<t>
   The terms "client" and "server" refer only to the roles that
   these programs perform for a particular connection.  The same program
   might act as a client on some connections and a server on others.
   The term "<x:dfn>user agent</x:dfn>" refers to any of the various
   client programs that initiate a request, including (but not limited to)
   browsers, spiders (web-based robots), command-line tools, custom
   applications, and mobile apps.
   The term "<x:dfn>origin server</x:dfn>" refers to the program that can
   originate authoritative responses for a given target resource.
   The terms "<x:dfn>sender</x:dfn>" and "<x:dfn>recipient</x:dfn>" refer to
   any implementation that sends or receives a given message, respectively.
</t>
<t>
   HTTP relies upon the Uniform Resource Identifier (URI)
   standard <xref target="RFC3986"/> to indicate the target resource
   (<xref target="target-resource"/>) and relationships between resources.
   Messages are passed in a format similar to that used by Internet mail
   <xref target="RFC5322"/> and the Multipurpose Internet Mail Extensions
   (MIME) <xref target="RFC2045"/> (see &diff-mime; for the differences
   between HTTP and MIME messages).
</t>
<t>
   Most HTTP communication consists of a retrieval request (GET) for
   a representation of some resource identified by a URI.  In the
   simplest case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin server (O).
</t>
<figure><artwork type="drawing">
         request   &gt;
    <x:highlight>UA</x:highlight> ======================================= <x:highlight>O</x:highlight>
                                &lt;   response
</artwork></figure>
<iref primary="true" item="message"/>
<iref primary="true" item="request"/>
<iref primary="true" item="response"/>
<t>
   A client sends an HTTP request to a server in the form of a <x:dfn>request</x:dfn>
   message, beginning with a request-line that includes a method, URI, and
   protocol version (<xref target="request.line"/>),
   followed by header fields containing
   request modifiers, client information, and representation metadata
   (<xref target="header.fields"/>),
   an empty line to indicate the end of the header section, and finally
   a message body containing the payload body (if any,
   <xref target="message.body"/>).
</t>
<t>
   A server responds to a client's request by sending one or more HTTP
   <x:dfn>response</x:dfn>
   messages, each beginning with a status line that
   includes the protocol version, a success or error code, and textual
   reason phrase (<xref target="status.line"/>),
   possibly followed by header fields containing server
   information, resource metadata, and representation metadata
   (<xref target="header.fields"/>),
   an empty line to indicate the end of the header section, and finally
   a message body containing the payload body (if any,
   <xref target="message.body"/>).
</t>
<t>
   A connection might be used for multiple request/response exchanges,
   as defined in <xref target="persistent.connections"/>.
</t>
<t>
   The following example illustrates a typical message exchange for a
   GET request (&GET;) on the URI "http://www.example.com/hello.txt":
</t>
<figure><preamble>
Client request:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi

</artwork></figure>
<figure><preamble>
Server response:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: <x:length-of target="exbody"/>
Vary: Accept-Encoding
Content-Type: text/plain

<x:span anchor="exbody">Hello World! My payload includes a trailing CRLF.
</x:span></artwork>
</figure>
</section>

<section title="Implementation Diversity" anchor="implementation-diversity">
<t>
   When considering the design of HTTP, it is easy to fall into a trap of
   thinking that all user agents are general-purpose browsers and all origin
   servers are large public websites. That is not the case in practice.
   Common HTTP user agents include household appliances, stereos, scales,
   firmware update scripts, command-line programs, mobile apps,
   and communication devices in a multitude of shapes and sizes.  Likewise,
   common HTTP origin servers include home automation units, configurable
   networking components, office machines, autonomous robots, news feeds,
   traffic cameras, ad selectors, and video-delivery platforms.
</t>
<t>
   The term "user agent" does not imply that there is a human user directly
   interacting with the software agent at the time of a request. In many
   cases, a user agent is installed or configured to run in the background
   and save its results for later inspection (or save only a subset of those
   results that might be interesting or erroneous). Spiders, for example, are
   typically given a start URI and configured to follow certain behavior while
   crawling the Web as a hypertext graph.
</t>
<t>
   The implementation diversity of HTTP means that not all user agents can
   make interactive suggestions to their user or provide adequate warning for
   security or privacy concerns. In the few cases where this
   specification requires reporting of errors to the user, it is acceptable
   for such reporting to only be observable in an error console or log file.
   Likewise, requirements that an automated action be confirmed by the user
   before proceeding might be met via advance configuration choices,
   run-time options, or simple avoidance of the unsafe action; confirmation
   does not imply any specific user interface or interruption of normal
   processing if the user has already made that choice.
</t>
</section>

<section title="Intermediaries" anchor="intermediaries">
<iref primary="true" item="intermediary"/>
<t>
   HTTP enables the use of intermediaries to satisfy requests through
   a chain of connections.  There are three common forms of HTTP
   <x:dfn>intermediary</x:dfn>: proxy, gateway, and tunnel.  In some cases,
   a single intermediary might act as an origin server, proxy, gateway,
   or tunnel, switching behavior based on the nature of each request.
</t>
<figure><artwork type="drawing">
         &gt;             &gt;             &gt;             &gt;
    <x:highlight>UA</x:highlight> =========== <x:highlight>A</x:highlight> =========== <x:highlight>B</x:highlight> =========== <x:highlight>C</x:highlight> =========== <x:highlight>O</x:highlight>
               &lt;             &lt;             &lt;             &lt;
</artwork></figure>
<t>
   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   Some HTTP communication options
   might apply only to the connection with the nearest, non-tunnel
   neighbor, only to the endpoints of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant might
   be engaged in multiple, simultaneous communications. For example, B
   might be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request. Likewise, later requests might be sent through a
   different path of connections, often based on dynamic configuration for
   load balancing.   
</t>
<t>
<iref primary="true" item="upstream"/><iref primary="true" item="downstream"/>
<iref primary="true" item="inbound"/><iref primary="true" item="outbound"/>
   The terms "<x:dfn>upstream</x:dfn>" and "<x:dfn>downstream</x:dfn>" are
   used to describe directional requirements in relation to the message flow:
   all messages flow from upstream to downstream.
   The terms "inbound" and "outbound" are used to describe directional
   requirements in relation to the request route:
   "<x:dfn>inbound</x:dfn>" means toward the origin server and
   "<x:dfn>outbound</x:dfn>" means toward the user agent.
</t>
<t><iref primary="true" item="proxy"/>
   A "<x:dfn>proxy</x:dfn>" is a message-forwarding agent that is selected by the
   client, usually via local configuration rules, to receive requests
   for some type(s) of absolute URI and attempt to satisfy those
   requests via translation through the HTTP interface.  Some translations
   are minimal, such as for proxy requests for "http" URIs, whereas
   other requests might require translation to and from entirely different
   application-level protocols. Proxies are often used to group an
   organization's HTTP requests through a common intermediary for the
   sake of security, annotation services, or shared caching. Some proxies
   are designed to apply transformations to selected messages or payloads
   while they are being forwarded, as described in
   <xref target="message.transformations"/>.
</t>
<t><iref primary="true" item="gateway"/><iref primary="true" item="reverse proxy"/>
<iref primary="true" item="accelerator"/>
   A "<x:dfn>gateway</x:dfn>" (a.k.a. "<x:dfn>reverse proxy</x:dfn>") is an
   intermediary that acts as an origin server for the outbound connection but
   translates received requests and forwards them inbound to another server or
   servers. Gateways are often used to encapsulate legacy or untrusted
   information services, to improve server performance through
   "<x:dfn>accelerator</x:dfn>" caching, and to enable partitioning or load
   balancing of HTTP services across multiple machines.
</t>
<t>
   All HTTP requirements applicable to an origin server
   also apply to the outbound communication of a gateway.
   A gateway communicates with inbound servers using any protocol that
   it desires, including private extensions to HTTP that are outside
   the scope of this specification.  However, an HTTP-to-HTTP gateway
   that wishes to interoperate with third-party HTTP servers ought to conform
   to user agent requirements on the gateway's inbound connection.
</t>
<t><iref primary="true" item="tunnel"/>
   A "<x:dfn>tunnel</x:dfn>" acts as a blind relay between two connections
   without changing the messages. Once active, a tunnel is not
   considered a party to the HTTP communication, though the tunnel might
   have been initiated by an HTTP request. A tunnel ceases to exist when
   both ends of the relayed connection are closed. Tunnels are used to
   extend a virtual connection through an intermediary, such as when
   Transport Layer Security (TLS, <xref target="RFC5246"/>) is used to
   establish confidential communication through a shared firewall proxy.
</t>
<t>
   The above categories for intermediary only consider those acting as
   participants in the HTTP communication.  There are also intermediaries
   that can act on lower layers of the network protocol stack, filtering or
   redirecting HTTP traffic without the knowledge or permission of message
   senders. Network intermediaries are indistinguishable (at a protocol level)
   from a man-in-the-middle attack, often introducing security flaws or
   interoperability problems due to mistakenly violating HTTP semantics.
</t>
<t><iref primary="true" item="interception proxy"/>
<iref primary="true" item="transparent proxy"/>
<iref primary="true" item="captive portal"/>
   For example, an
   "<x:dfn>interception proxy</x:dfn>" <xref target="RFC3040"/> (also commonly
   known as a "<x:dfn>transparent proxy</x:dfn>" <xref target="RFC1919"/> or
   "<x:dfn>captive portal</x:dfn>")
   differs from an HTTP proxy because it is not selected by the client.
   Instead, an interception proxy filters or redirects outgoing TCP port 80
   packets (and occasionally other common port traffic).
   Interception proxies are commonly found on public network access points,
   as a means of enforcing account subscription prior to allowing use of
   non-local Internet services, and within corporate firewalls to enforce
   network usage policies.
</t>
<t>
   HTTP is defined as a stateless protocol, meaning that each request message
   can be understood in isolation.  Many implementations depend on HTTP's
   stateless design in order to reuse proxied connections or dynamically
   load balance requests across multiple servers.  Hence, a server &MUST-NOT;
   assume that two requests on the same connection are from the same user
   agent unless the connection is secured and specific to that agent.
   Some non-standard HTTP extensions (e.g., <xref target="RFC4559"/>) have
   been known to violate this requirement, resulting in security and
   interoperability problems.
</t>
</section>

<section title="Caches" anchor="caches">
<iref primary="true" item="cache"/>
<t>
   A "<x:dfn>cache</x:dfn>" is a local store of previous response messages and the
   subsystem that controls its message storage, retrieval, and deletion.
   A cache stores cacheable responses in order to reduce the response
   time and network bandwidth consumption on future, equivalent
   requests. Any client or server &MAY; employ a cache, though a cache
   cannot be used by a server while it is acting as a tunnel.
</t>
<t>
   The effect of a cache is that the request/response chain is shortened
   if one of the participants along the chain has a cached response
   applicable to that request. The following illustrates the resulting
   chain if B has a cached copy of an earlier response from O (via C)
   for a request that has not been cached by UA or A.
</t>
<figure><artwork type="drawing">
            &gt;             &gt;
       <x:highlight>UA</x:highlight> =========== <x:highlight>A</x:highlight> =========== <x:highlight>B</x:highlight> - - - - - - <x:highlight>C</x:highlight> - - - - - - <x:highlight>O</x:highlight>
                  &lt;             &lt;
</artwork></figure>
<t><iref primary="true" item="cacheable"/>
   A response is "<x:dfn>cacheable</x:dfn>" if a cache is allowed to store a copy of
   the response message for use in answering subsequent requests.
   Even when a response is cacheable, there might be additional
   constraints placed by the client or by the origin server on when
   that cached response can be used for a particular request. HTTP
   requirements for cache behavior and cacheable responses are
   defined in &caching-overview;.  
</t>
<t>
   There is a wide variety of architectures and configurations
   of caches deployed across the World Wide Web and
   inside large organizations. These include national hierarchies
   of proxy caches to save transoceanic bandwidth, collaborative systems that
   broadcast or multicast cache entries, archives of pre-fetched cache
   entries for use in off-line or high-latency environments, and so on.
</t>
</section>

<section title="Conformance and Error Handling" anchor="conformance">
<t>
   This specification targets conformance criteria according to the role of
   a participant in HTTP communication.  Hence, HTTP requirements are placed
   on senders, recipients, clients, servers, user agents, intermediaries,
   origin servers, proxies, gateways, or caches, depending on what behavior
   is being constrained by the requirement. Additional (social) requirements
   are placed on implementations, resource owners, and protocol element
   registrations when they apply beyond the scope of a single communication.
</t>
<t>
   The verb "generate" is used instead of "send" where a requirement
   differentiates between creating a protocol element and merely forwarding a
   received element downstream.
</t>
<t>
   An implementation is considered conformant if it complies with all of the
   requirements associated with the roles it partakes in HTTP.
</t>
<t>
   Conformance includes both the syntax and semantics of protocol
   elements. A sender &MUST-NOT; generate protocol elements that convey a
   meaning that is known by that sender to be false. A sender &MUST-NOT;
   generate protocol elements that do not match the grammar defined by the
   corresponding ABNF rules. Within a given message, a sender &MUST-NOT;
   generate protocol elements or syntax alternatives that are only allowed to
   be generated by participants in other roles (i.e., a role that the sender
   does not have for that message).
</t>
<t>
   When a received protocol element is parsed, the recipient &MUST; be able to
   parse any value of reasonable length that is applicable to the recipient's
   role and that matches the grammar defined by the corresponding ABNF rules.
   Note, however, that some received protocol elements might not be parsed.
   For example, an intermediary forwarding a message might parse a
   header-field into generic field-name and field-value components, but then
   forward the header field without further parsing inside the field-value.
</t>
<t>
   HTTP does not have specific length limitations for many of its protocol
   elements because the lengths that might be appropriate will vary widely,
   depending on the deployment context and purpose of the implementation.
   Hence, interoperability between senders and recipients depends on shared
   expectations regarding what is a reasonable length for each protocol
   element. Furthermore, what is commonly understood to be a reasonable length
   for some protocol elements has changed over the course of the past two
   decades of HTTP use and is expected to continue changing in the future.
</t>
<t>
   At a minimum, a recipient &MUST; be able to parse and process protocol
   element lengths that are at least as long as the values that it generates
   for those same protocol elements in other messages. For example, an origin
   server that publishes very long URI references to its own resources needs
   to be able to parse and process those same references when received as a
   request target.
</t>
<t>
   A recipient &MUST; interpret a received protocol element according to the
   semantics defined for it by this specification, including extensions to
   this specification, unless the recipient has determined (through experience
   or configuration) that the sender incorrectly implements what is implied by
   those semantics.
   For example, an origin server might disregard the contents of a received
   <x:ref>Accept-Encoding</x:ref> header field if inspection of the
   <x:ref>User-Agent</x:ref> header field indicates a specific implementation
   version that is known to fail on receipt of certain content codings.
</t>
<t>
   Unless noted otherwise, a recipient &MAY; attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct impact
   on security, since different applications of the protocol require
   different error handling strategies.  For example, a Web browser might
   wish to transparently recover from a response where the
   <x:ref>Location</x:ref> header field doesn't parse according to the ABNF,
   whereas a systems control client might consider any form of error recovery
   to be dangerous.
</t>
</section>

<section title="Protocol Versioning" anchor="http.version">
  <x:anchor-alias value="HTTP-version"/>
  <x:anchor-alias value="HTTP-name"/>
<t>
   HTTP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate
   versions of the protocol. This specification defines version "1.1".
   The protocol version as a whole indicates the sender's conformance
   with the set of requirements laid out in that version's corresponding
   specification of HTTP.
</t>
<t>
   The version of an HTTP message is indicated by an HTTP-version field
   in the first line of the message. HTTP-version is case-sensitive.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="HTTP-version"/><iref primary="true" item="Grammar" subitem="HTTP-name"/>
  <x:ref>HTTP-version</x:ref>  = <x:ref>HTTP-name</x:ref> "/" <x:ref>DIGIT</x:ref> "." <x:ref>DIGIT</x:ref>
  <x:ref>HTTP-name</x:ref>     = <x:abnf-char-sequence>"HTTP"</x:abnf-char-sequence> ; "HTTP", case-sensitive 
</artwork></figure>
<t>
   The HTTP version number consists of two decimal digits separated by a "."
   (period or decimal point).  The first digit ("major version") indicates the
   HTTP messaging syntax, whereas the second digit ("minor version") indicates
   the highest minor version within that major version to which the sender is
   conformant and able to understand for future communication.  The minor
   version advertises the sender's communication capabilities even when the
   sender is only using a backwards-compatible subset of the protocol,
   thereby letting the recipient know that more advanced features can
   be used in response (by servers) or in future requests (by clients).
</t>
<t>
   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient
   <xref target="RFC1945"/> or a recipient whose version is unknown,
   the HTTP/1.1 message is constructed such that it can be interpreted
   as a valid HTTP/1.0 message if all of the newer features are ignored.
   This specification places recipient-version requirements on some
   new features so that a conformant sender will only use compatible
   features until it has determined, through configuration or the
   receipt of a message, that the recipient supports HTTP/1.1.
</t>
<t>
   The interpretation of a header field does not change between minor
   versions of the same major HTTP version, though the default
   behavior of a recipient in the absence of such a field can change.
   Unless specified otherwise, header fields defined in HTTP/1.1 are
   defined for all versions of HTTP/1.x.  In particular, the <x:ref>Host</x:ref>
   and <x:ref>Connection</x:ref> header fields ought to be implemented by all
   HTTP/1.x implementations whether or not they advertise conformance with
   HTTP/1.1.
</t>
<t>
   New header fields can be introduced without changing the protocol version
   if their defined semantics allow them to be safely ignored by recipients
   that do not recognize them. Header field extensibility is discussed in
   <xref target="field.extensibility"/>.
</t>
<t>
   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) &MUST; send their own HTTP-version
   in forwarded messages.  In other words, they are not allowed to blindly
   forward the first line of an HTTP message without ensuring that the
   protocol version in that message matches a version to which that
   intermediary is conformant for both the receiving and
   sending of messages.  Forwarding an HTTP message without rewriting
   the HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what features
   are safe to use for later communication with that sender.
</t>
<t>
   A client &SHOULD; send a request version equal to the highest
   version to which the client is conformant and
   whose major version is no higher than the highest version supported
   by the server, if this is known.  A client &MUST-NOT; send a
   version to which it is not conformant.
</t>
<t>
   A client &MAY; send a lower request version if it is known that
   the server incorrectly implements the HTTP specification, but only
   after the client has attempted at least one normal request and determined
   from the response status code or header fields (e.g., <x:ref>Server</x:ref>) that
   the server improperly handles higher request versions.
</t>
<t>
   A server &SHOULD; send a response version equal to the highest version to
   which the server is conformant that has a major version less than or equal
   to the one received in the request.
   A server &MUST-NOT; send a version to which it is not conformant.
   A server can send a <x:ref>505 (HTTP Version Not Supported)</x:ref>
   response if it wishes, for any reason, to refuse service of the client's
   major protocol version.
</t>
<t>
   A server &MAY; send an HTTP/1.0 response to a request
   if it is known or suspected that the client incorrectly implements the
   HTTP specification and is incapable of correctly processing later
   version responses, such as when a client fails to parse the version
   number correctly or when an intermediary is known to blindly forward
   the HTTP-version even when it doesn't conform to the given minor
   version of the protocol. Such protocol downgrades &SHOULD-NOT; be
   performed unless triggered by specific client attributes, such as when
   one or more of the request header fields (e.g., <x:ref>User-Agent</x:ref>)
   uniquely match the values sent by a client known to be in error.
</t>
<t>
   The intention of HTTP's versioning design is that the major number
   will only be incremented if an incompatible message syntax is
   introduced, and that the minor number will only be incremented when
   changes made to the protocol have the effect of adding to the message
   semantics or implying additional capabilities of the sender.  However,
   the minor version was not incremented for the changes introduced between
   <xref target="RFC2068"/> and <xref target="RFC2616"/>, and this revision
   has specifically avoided any such changes to the protocol.
</t>
<t>
   When an HTTP message is received with a major version number that the
   recipient implements, but a higher minor version number than what the
   recipient implements, the recipient &SHOULD; process the message as if it
   were in the highest minor version within that major version to which the
   recipient is conformant. A recipient can assume that a message with a
   higher minor version, when sent to a recipient that has not yet indicated
   support for that higher version, is sufficiently backwards-compatible to be
   safely processed by any implementation of the same major version.
</t>
</section>

<section title="Uniform Resource Identifiers" anchor="uri">
<iref primary="true" item="resource"/>
<t>
   Uniform Resource Identifiers (URIs) <xref target="RFC3986"/> are used
   throughout HTTP as the means for identifying resources (&resource;).
   URI references are used to target requests, indicate redirects, and define
   relationships.
</t>
  <x:anchor-alias value="URI-reference"/>
  <x:anchor-alias value="absolute-URI"/>
  <x:anchor-alias value="relative-part"/>
  <x:anchor-alias value="scheme"/>
  <x:anchor-alias value="authority"/>
  <x:anchor-alias value="uri-host"/>
  <x:anchor-alias value="port"/>
  <x:anchor-alias value="path"/>
  <x:anchor-alias value="path-abempty"/>
  <x:anchor-alias value="segment"/>
  <x:anchor-alias value="query"/>
  <x:anchor-alias value="fragment"/>
  <x:anchor-alias value="absolute-path"/>
  <x:anchor-alias value="partial-URI"/>
<t>
   The definitions of "URI-reference",
   "absolute-URI", "relative-part", "scheme", "authority", "port", "host",
   "path-abempty", "segment", "query", and "fragment" are adopted from the
   URI generic syntax.
   An "absolute-path" rule is defined for protocol elements that can contain a
   non-empty path component. (This rule differs slightly from the path-abempty
   rule of RFC 3986, which allows for an empty path to be used in references,
   and path-absolute rule, which does not allow paths that begin with "//".)
   A "partial-URI" rule is defined for protocol elements
   that can contain a relative URI but not a fragment component.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="URI-reference"><!--exported production--></iref><iref primary="true" item="Grammar" subitem="absolute-URI"/><iref primary="true" item="Grammar" subitem="scheme"/><iref primary="true" item="Grammar" subitem="authority"/><iref primary="true" item="Grammar" subitem="absolute-path"/><iref primary="true" item="Grammar" subitem="port"/><iref primary="true" item="Grammar" subitem="query"/><iref primary="true" item="Grammar" subitem="fragment"/><iref primary="true" item="Grammar" subitem="segment"/><iref primary="true" item="Grammar" subitem="uri-host"/><iref primary="true" item="Grammar" subitem="partial-URI"><!--exported production--></iref>
  <x:ref>URI-reference</x:ref> = &lt;URI-reference, see <xref target="RFC3986" x:fmt="," x:sec="4.1"/>&gt;
  <x:ref>absolute-URI</x:ref>  = &lt;absolute-URI, see <xref target="RFC3986" x:fmt="," x:sec="4.3"/>&gt;
  <x:ref>relative-part</x:ref> = &lt;relative-part, see <xref target="RFC3986" x:fmt="," x:sec="4.2"/>&gt;
  <x:ref>scheme</x:ref>        = &lt;scheme, see <xref target="RFC3986" x:fmt="," x:sec="3.1"/>&gt;
  <x:ref>authority</x:ref>     = &lt;authority, see <xref target="RFC3986" x:fmt="," x:sec="3.2"/>&gt;
  <x:ref>uri-host</x:ref>      = &lt;host, see <xref target="RFC3986" x:fmt="," x:sec="3.2.2"/>&gt;
  <x:ref>port</x:ref>          = &lt;port, see <xref target="RFC3986" x:fmt="," x:sec="3.2.3"/>&gt;
  <x:ref>path-abempty</x:ref>  = &lt;path-abempty, see <xref target="RFC3986" x:fmt="," x:sec="3.3"/>&gt;
  <x:ref>segment</x:ref>       = &lt;segment, see <xref target="RFC3986" x:fmt="," x:sec="3.3"/>&gt;
  <x:ref>query</x:ref>         = &lt;query, see <xref target="RFC3986" x:fmt="," x:sec="3.4"/>&gt;
  <x:ref>fragment</x:ref>      = &lt;fragment, see <xref target="RFC3986" x:fmt="," x:sec="3.5"/>&gt;
  
  <x:ref>absolute-path</x:ref> = 1*( "/" segment )
  <x:ref>partial-URI</x:ref>   = relative-part [ "?" query ]
</artwork></figure>
<t>
   Each protocol element in HTTP that allows a URI reference will indicate
   in its ABNF production whether the element allows any form of reference
   (URI-reference), only a URI in absolute form (absolute-URI), only the
   path and optional query components, or some combination of the above.
   Unless otherwise indicated, URI references are parsed
   relative to the effective request URI
   (<xref target="effective.request.uri"/>).
</t>

<section title="http URI Scheme" anchor="http.uri">
  <x:anchor-alias value="http-URI"/>
  <iref item="http URI scheme" primary="true"/>
  <iref item="URI scheme" subitem="http" primary="true"/>
<t>
   The "http" URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   TCP (<xref target="RFC0793"/>) connections on a given port.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="http-URI"><!--terminal production--></iref>
  <x:ref>http-URI</x:ref> = "http:" "//" <x:ref>authority</x:ref> <x:ref>path-abempty</x:ref> [ "?" <x:ref>query</x:ref> ]
             [ "#" <x:ref>fragment</x:ref> ]
</artwork></figure>
<t>
   The origin server for an "http" URI is identified by the 
   <x:ref>authority</x:ref> component, which includes a host identifier
   and optional TCP port (<xref target="RFC3986" x:fmt="," x:sec="3.2.2"/>).
   The hierarchical path component and optional query component serve as an
   identifier for a potential target resource within that origin server's name
   space. The optional fragment component allows for indirect identification
   of a secondary resource, independent of the URI scheme, as defined in
   <xref target="RFC3986" x:fmt="of" x:sec="3.5"/>.
</t>
<t>
   A sender &MUST-NOT; generate an "http" URI with an empty host identifier.
   A recipient that processes such a URI reference &MUST; reject it as invalid. 
</t>
<t>
   If the host identifier is provided as an IP address, the origin server is
   the listener (if any) on the indicated TCP port at that IP address.
   If host is a registered name, the registered name is an indirect identifier
   for use with a name resolution service, such as DNS, to find an address for
   that origin server.
   If the port subcomponent is empty or not given, TCP port 80 (the
   reserved port for WWW services) is the default.
</t>
<t>
   Note that the presence of a URI with a given authority component does not
   imply that there is always an HTTP server listening for connections on
   that host and port. Anyone can mint a URI. What the authority component
   determines is who has the right to respond authoritatively to requests that
   target the identified resource. The delegated nature of registered names
   and IP addresses creates a federated namespace, based on control over the
   indicated host and port, whether or not an HTTP server is present.
   See <xref target="establishing.authority"/> for security considerations
   related to establishing authority.
</t>
<t>
   When an "http" URI is used within a context that calls for access to the
   indicated resource, a client &MAY; attempt access by resolving
   the host to an IP address, establishing a TCP connection to that address
   on the indicated port, and sending an HTTP request message
   (<xref target="http.message"/>) containing the URI's identifying data
   (<xref target="message.routing"/>) to the server.
   If the server responds to that request with a non-interim HTTP response
   message, as described in &status-codes;, then that response
   is considered an authoritative answer to the client's request.
</t>
<t>
   Although HTTP is independent of the transport protocol, the "http"
   scheme is specific to TCP-based services because the name delegation
   process depends on TCP for establishing authority.
   An HTTP service based on some other underlying connection protocol
   would presumably be identified using a different URI scheme, just as
   the "https" scheme (below) is used for resources that require an
   end-to-end secured connection. Other protocols might also be used to
   provide access to "http" identified resources &mdash; it is only the
   authoritative interface that is specific to TCP.
</t>
<t>
   The URI generic syntax for authority also includes a deprecated
   userinfo subcomponent (<xref target="RFC3986" x:fmt="," x:sec="3.2.1"/>)
   for including user authentication information in the URI.  Some
   implementations make use of the userinfo component for internal
   configuration of authentication information, such as within command
   invocation options, configuration files, or bookmark lists, even
   though such usage might expose a user identifier or password.
   A sender &MUST-NOT; generate the userinfo subcomponent (and its "@"
   delimiter) when an "http" URI reference is generated within a message as a
   request target or header field value.
   Before making use of an "http" URI reference received from an untrusted
   source, a recipient &SHOULD; parse for userinfo and treat its presence as
   an error; it is likely being used to obscure the authority for the sake of
   phishing attacks.
</t>
</section>

<section title="https URI Scheme" anchor="https.uri">
   <x:anchor-alias value="https-URI"/>
   <iref item="https URI scheme"/>
   <iref item="URI scheme" subitem="https"/>
<t>
   The "https" URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening to a
   given TCP port for TLS-secured connections (<xref target="RFC5246"/>).
</t>
<t>
   All of the requirements listed above for the "http" scheme are also
   requirements for the "https" scheme, except that TCP port 443 is the
   default if the port subcomponent is empty or not given,
   and the user agent &MUST; ensure that its connection to the origin
   server is secured through the use of strong encryption, end-to-end,
   prior to sending the first HTTP request.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="https-URI"><!--terminal production--></iref>
  <x:ref>https-URI</x:ref> = "https:" "//" <x:ref>authority</x:ref> <x:ref>path-abempty</x:ref> [ "?" <x:ref>query</x:ref> ]
              [ "#" <x:ref>fragment</x:ref> ]
</artwork></figure>
<t>
   Note that the "https" URI scheme depends on both TLS and TCP for
   establishing authority.
   Resources made available via the "https" scheme have no shared
   identity with the "http" scheme even if their resource identifiers
   indicate the same authority (the same host listening to the same
   TCP port).  They are distinct namespaces and are considered to be
   distinct origin servers.  However, an extension to HTTP that is
   defined to apply to entire host domains, such as the Cookie protocol 
   <xref target="RFC6265"/>, can allow information
   set by one service to impact communication with other services
   within a matching group of host domains.
</t>
<t>
   The process for authoritative access to an "https" identified
   resource is defined in <xref target="RFC2818"/>.
</t>
</section>

<section title="http and https URI Normalization and Comparison" anchor="uri.comparison">
<t>
   Since the "http" and "https" schemes conform to the URI generic syntax,
   such URIs are normalized and compared according to the algorithm defined
   in <xref target="RFC3986" x:fmt="of" x:sec="6"/>, using the defaults
   described above for each scheme.
</t>
<t>
   If the port is equal to the default port for a scheme, the normal form is
   to omit the port subcomponent. When not being used in absolute form as the
   request target of an OPTIONS request, an empty path component is equivalent
   to an absolute path of "/", so the normal form is to provide a path of "/"
   instead. The scheme and host are case-insensitive and normally provided in
   lowercase; all other components are compared in a case-sensitive manner.
   Characters other than those in the "reserved" set are equivalent to their
   percent-encoded octets: the normal form is to not encode them
   (see Sections <xref target="RFC3986" x:fmt="number" x:sec="2.1"/> and
   <xref target="RFC3986" x:fmt="number" x:sec="2.2"/> of 
   <xref target="RFC3986"/>).
</t>
<t>
   For example, the following three URIs are equivalent:
</t>
<figure><artwork type="example">
   http://example.com:80/~smith/home.html
   http://EXAMPLE.com/%7Esmith/home.html
   http://EXAMPLE.com:/%7esmith/home.html
</artwork></figure>
</section>
</section>
</section>

<section title="Message Format" anchor="http.message">
<x:anchor-alias value="generic-message"/>
<x:anchor-alias value="message.types"/>
<x:anchor-alias value="HTTP-message"/>
<x:anchor-alias value="start-line"/>
<iref item="header section"/>
<iref item="headers"/>
<iref item="header field"/>
<t>
   All HTTP/1.1 messages consist of a start-line followed by a sequence of
   octets in a format similar to the Internet Message Format
   <xref target="RFC5322"/>: zero or more header fields (collectively
   referred to as the "headers" or the "header section"), an empty line
   indicating the end of the header section, and an optional message body.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="HTTP-message"><!--terminal production--></iref>
  <x:ref>HTTP-message</x:ref>   = <x:ref>start-line</x:ref>
                   *( <x:ref>header-field</x:ref> <x:ref>CRLF</x:ref> )
                   <x:ref>CRLF</x:ref>
                   [ <x:ref>message-body</x:ref> ]
</artwork></figure>
<t>
   The normal procedure for parsing an HTTP message is to read the
   start-line into a structure, read each header field into a hash
   table by field name until the empty line, and then use the parsed
   data to determine if a message body is expected.  If a message body
   has been indicated, then it is read as a stream until an amount
   of octets equal to the message body length is read or the connection
   is closed.
</t>
<t>
   A recipient &MUST; parse an HTTP message as a sequence of octets in an
   encoding that is a superset of US-ASCII <xref target="USASCII"/>.
   Parsing an HTTP message as a stream of Unicode characters, without regard
   for the specific encoding, creates security vulnerabilities due to the
   varying ways that string processing libraries handle invalid multibyte
   character sequences that contain the octet LF (%x0A).  String-based
   parsers can only be safely used within protocol elements after the element
   has been extracted from the message, such as within a header field-value
   after message parsing has delineated the individual fields.
</t>
<t>
   An HTTP message can be parsed as a stream for incremental processing or
   forwarding downstream.  However, recipients cannot rely on incremental
   delivery of partial messages, since some implementations will buffer or
   delay message forwarding for the sake of network efficiency, security
   checks, or payload transformations.
</t>
<t>
   A sender &MUST-NOT; send whitespace between the start-line and
   the first header field.
   A recipient that receives whitespace between the start-line and
   the first header field &MUST; either reject the message as invalid or
   consume each whitespace-preceded line without further processing of it
   (i.e., ignore the entire line, along with any subsequent lines preceded
   by whitespace, until a properly formed header field is received or the
   header section is terminated).
</t>
<t>
   The presence of such whitespace in a request
   might be an attempt to trick a server into ignoring that field or
   processing the line after it as a new request, either of which might
   result in a security vulnerability if other implementations within
   the request chain interpret the same message differently.
   Likewise, the presence of such whitespace in a response might be
   ignored by some clients or cause others to cease parsing.
</t>

<section title="Start Line" anchor="start.line">
  <x:anchor-alias value="Start-Line"/>
<t>
   An HTTP message can be either a request from client to server or a
   response from server to client.  Syntactically, the two types of message
   differ only in the start-line, which is either a request-line (for requests)
   or a status-line (for responses), and in the algorithm for determining
   the length of the message body (<xref target="message.body"/>).
</t>
<t>
   In theory, a client could receive requests and a server could receive
   responses, distinguishing them by their different start-line formats,
   but, in practice, servers are implemented to only expect a request
   (a response is interpreted as an unknown or invalid request method)
   and clients are implemented to only expect a response.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="start-line"/>
  <x:ref>start-line</x:ref>     = <x:ref>request-line</x:ref> / <x:ref>status-line</x:ref>
</artwork></figure>

<section title="Request Line" anchor="request.line">
  <x:anchor-alias value="Request"/>
  <x:anchor-alias value="request-line"/>
<t>
   A request-line begins with a method token, followed by a single
   space (SP), the request-target, another single space (SP), the
   protocol version, and ends with CRLF.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="request-line"/>
  <x:ref>request-line</x:ref>   = <x:ref>method</x:ref> <x:ref>SP</x:ref> <x:ref>request-target</x:ref> <x:ref>SP</x:ref> <x:ref>HTTP-version</x:ref> <x:ref>CRLF</x:ref>
</artwork></figure>
<iref primary="true" item="method"/>
<t anchor="method">
   The method token indicates the request method to be performed on the
   target resource. The request method is case-sensitive.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="method"/>
  <x:ref>method</x:ref>         = <x:ref>token</x:ref>
</artwork></figure>
<t>
   The request methods defined by this specification can be found in
   &methods;, along with information regarding the HTTP method registry
   and considerations for defining new methods.
</t>
<iref item="request-target"/>
<t>
   The request-target identifies the target resource upon which to apply
   the request, as defined in <xref target="request-target"/>.
</t>
<t>
   Recipients typically parse the request-line into its component parts by
   splitting on whitespace (see <xref target="message.robustness"/>), since
   no whitespace is allowed in the three components.
   Unfortunately, some user agents fail to properly encode or exclude
   whitespace found in hypertext references, resulting in those disallowed
   characters being sent in a request-target.
</t>
<t>
   Recipients of an invalid request-line &SHOULD; respond with either a
   <x:ref>400 (Bad Request)</x:ref> error or a <x:ref>301 (Moved Permanently)</x:ref>
   redirect with the request-target properly encoded.  A recipient &SHOULD-NOT;
   attempt to autocorrect and then process the request without a redirect,
   since the invalid request-line might be deliberately crafted to bypass
   security filters along the request chain.
</t>
<t>
   HTTP does not place a predefined limit on the length of a request-line,
   as described in <xref target="conformance"/>.
   A server that receives a method longer than any that it implements
   &SHOULD; respond with a <x:ref>501 (Not Implemented)</x:ref> status code.
   A server that receives a request-target longer than any URI it wishes to
   parse &MUST; respond with a
   <x:ref>414 (URI Too Long)</x:ref> status code (see &status-414;).
</t>
<t>
   Various ad hoc limitations on request-line length are found in practice.
   It is &RECOMMENDED; that all HTTP senders and recipients support, at a
   minimum, request-line lengths of 8000 octets.
</t>
</section>

<section title="Status Line" anchor="status.line">
  <x:anchor-alias value="response"/>
  <x:anchor-alias value="status-line"/>
  <x:anchor-alias value="status-code"/>
  <x:anchor-alias value="reason-phrase"/>
<t>
   The first line of a response message is the status-line, consisting
   of the protocol version, a space (SP), the status code, another space,
   a possibly empty textual phrase describing the status code, and
   ending with CRLF.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="status-line"/>
  <x:ref>status-line</x:ref> = <x:ref>HTTP-version</x:ref> <x:ref>SP</x:ref> <x:ref>status-code</x:ref> <x:ref>SP</x:ref> <x:ref>reason-phrase</x:ref> <x:ref>CRLF</x:ref>
</artwork></figure>
<t>
   The status-code element is a 3-digit integer code describing the
   result of the server's attempt to understand and satisfy the client's
   corresponding request. The rest of the response message is to be
   interpreted in light of the semantics defined for that status code.
   See &status-codes; for information about the semantics of status codes,
   including the classes of status code (indicated by the first digit),
   the status codes defined by this specification, considerations for the
   definition of new status codes, and the IANA registry.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="status-code"/>
  <x:ref>status-code</x:ref>    = 3<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>   
   The reason-phrase element exists for the sole purpose of providing a
   textual description associated with the numeric status code, mostly
   out of deference to earlier Internet application protocols that were more
   frequently used with interactive text clients. A client &SHOULD; ignore
   the reason-phrase content.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="reason-phrase"/>
  <x:ref>reason-phrase</x:ref>  = *( <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref> )
</artwork></figure>
</section>
</section>

<section title="Header Fields" anchor="header.fields">
  <x:anchor-alias value="header-field"/>
  <x:anchor-alias value="field-content"/>
  <x:anchor-alias value="field-name"/>
  <x:anchor-alias value="field-value"/>
  <x:anchor-alias value="field-vchar"/>
  <x:anchor-alias value="obs-fold"/>
<t>
   Each header field consists of a case-insensitive field name
   followed by a colon (":"), optional leading whitespace, the field value,
   and optional trailing whitespace.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="header-field"/><iref primary="true" item="Grammar" subitem="field-name"/><iref primary="true" item="Grammar" subitem="field-value"/><iref primary="true" item="Grammar" subitem="field-vchar"/><iref primary="true" item="Grammar" subitem="field-content"/><iref primary="true" item="Grammar" subitem="obs-fold"/>
  <x:ref>header-field</x:ref>   = <x:ref>field-name</x:ref> ":" <x:ref>OWS</x:ref> <x:ref>field-value</x:ref> <x:ref>OWS</x:ref>

  <x:ref>field-name</x:ref>     = <x:ref>token</x:ref>
  <x:ref>field-value</x:ref>    = *( <x:ref>field-content</x:ref> / <x:ref>obs-fold</x:ref> )
  <x:ref>field-content</x:ref>  = <x:ref>field-vchar</x:ref> [ 1*( <x:ref>SP</x:ref> / <x:ref>HTAB</x:ref> ) <x:ref>field-vchar</x:ref> ]
  <x:ref>field-vchar</x:ref>    = <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref>

  <x:ref>obs-fold</x:ref>       = <x:ref>CRLF</x:ref> 1*( <x:ref>SP</x:ref> / <x:ref>HTAB</x:ref> )
                 ; obsolete line folding
                 ; see <xref target="field.parsing"/>
</artwork></figure>
<t>
   The field-name token labels the corresponding field-value as having the
   semantics defined by that header field.  For example, the <x:ref>Date</x:ref>
   header field is defined in &header-date; as containing the origination
   timestamp for the message in which it appears.
</t>

<section title="Field Extensibility" anchor="field.extensibility">
<t>
   Header fields are fully extensible: there is no limit on the
   introduction of new field names, each presumably defining new semantics,
   nor on the number of header fields used in a given message.  Existing
   fields are defined in each part of this specification and in many other
   specifications outside this document set.
</t>
<t>
   New header fields can be defined such that, when they are understood by a
   recipient, they might override or enhance the interpretation of previously
   defined header fields, define preconditions on request evaluation, or
   refine the meaning of responses.
</t>
<t>
   A proxy &MUST; forward unrecognized header fields unless the
   field-name is listed in the <x:ref>Connection</x:ref> header field
   (<xref target="header.connection"/>) or the proxy is specifically
   configured to block, or otherwise transform, such fields.
   Other recipients &SHOULD; ignore unrecognized header fields.
   These requirements allow HTTP's functionality to be enhanced without
   requiring prior update of deployed intermediaries.
</t>
<t>
   All defined header fields ought to be registered with IANA in the
   "Message Headers" registry, as described in &iana-header-registry;.
</t>
</section>

<section title="Field Order" anchor="field.order">
<t>
   The order in which header fields with differing field names are
   received is not significant. However, it is good practice to send
   header fields that contain control data first, such as <x:ref>Host</x:ref>
   on requests and <x:ref>Date</x:ref> on responses, so that implementations
   can decide when not to handle a message as early as possible.
   A server &MUST-NOT; apply a request to the target resource until the entire
   request header section is received, since later header fields might include
   conditionals, authentication credentials, or deliberately misleading
   duplicate header fields that would impact request processing.
</t>
<t>
   A sender &MUST-NOT; generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).
</t>
<t>
   A recipient &MAY; combine multiple header fields with the same field name
   into one "field-name: field-value" pair, without changing the semantics of
   the message, by appending each subsequent field value to the combined
   field value in order, separated by a comma. The order in which
   header fields with the same field name are received is therefore
   significant to the interpretation of the combined field value;
   a proxy &MUST-NOT; change the order of these field values when
   forwarding a message.
</t>
<x:note>
  <t>
   &Note; In practice, the "Set-Cookie" header field (<xref target="RFC6265"/>)
   often appears multiple times in a response message and does not use the
   list syntax, violating the above requirements on multiple header fields
   with the same name. Since it cannot be combined into a single field-value,
   recipients ought to handle "Set-Cookie" as a special case while processing
   header fields. (See Appendix A.2.3 of <xref target="Kri2001"/> for details.)
  </t>
</x:note>
</section>

<section title="Whitespace" anchor="whitespace">
<t anchor="rule.LWS">
   This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS ("bad" whitespace). 
</t>
<t anchor="rule.OWS">
   The OWS rule is used where zero or more linear whitespace octets might
   appear. For protocol elements where optional whitespace is preferred to
   improve readability, a sender &SHOULD; generate the optional whitespace
   as a single SP; otherwise, a sender &SHOULD-NOT; generate optional
   whitespace except as needed to white out invalid or unwanted protocol
   elements during in-place message filtering.
</t>
<t anchor="rule.RWS">
   The RWS rule is used when at least one linear whitespace octet is required
   to separate field tokens. A sender &SHOULD; generate RWS as a single SP.
</t>
<t anchor="rule.BWS">
   The BWS rule is used where the grammar allows optional whitespace only for
   historical reasons. A sender &MUST-NOT; generate BWS in messages.
   A recipient &MUST; parse for such bad whitespace and remove it before
   interpreting the protocol element.
</t>
<t anchor="rule.whitespace">
  <x:anchor-alias value="BWS"/>
  <x:anchor-alias value="OWS"/>
  <x:anchor-alias value="RWS"/>
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="OWS"/><iref primary="true" item="Grammar" subitem="RWS"/><iref primary="true" item="Grammar" subitem="BWS"/>
  <x:ref>OWS</x:ref>            = *( <x:ref>SP</x:ref> / <x:ref>HTAB</x:ref> )
                 ; optional whitespace
  <x:ref>RWS</x:ref>            = 1*( <x:ref>SP</x:ref> / <x:ref>HTAB</x:ref> )
                 ; required whitespace
  <x:ref>BWS</x:ref>            = <x:ref>OWS</x:ref>
                 ; "bad" whitespace
</artwork></figure>
</section>

<section title="Field Parsing" anchor="field.parsing">
<t>
   Messages are parsed using a generic algorithm, independent of the
   individual header field names. The contents within a given field value are
   not parsed until a later stage of message interpretation (usually after the
   message's entire header section has been processed).
   Consequently, this specification does not use ABNF rules to define each
   "Field-Name: Field Value" pair, as was done in previous editions.
   Instead, this specification uses ABNF rules that are named according to
   each registered field name, wherein the rule defines the valid grammar for
   that field's corresponding field values (i.e., after the field-value
   has been extracted from the header section by a generic field parser).
</t>
<t>
   No whitespace is allowed between the header field-name and colon.
   In the past, differences in the handling of such whitespace have led to
   security vulnerabilities in request routing and response handling.
   A server &MUST; reject any received request message that contains
   whitespace between a header field-name and colon with a response code of
   <x:ref>400 (Bad Request)</x:ref>. A proxy &MUST; remove any such whitespace
   from a response message before forwarding the message downstream.
</t>
<t>
   A field value might be preceded and/or followed by optional whitespace
   (OWS); a single SP preceding the field-value is preferred for consistent
   readability by humans.
   The field value does not include any leading or trailing whitespace: OWS
   occurring before the first non-whitespace octet of the field value or after
   the last non-whitespace octet of the field value ought to be excluded by
   parsers when extracting the field value from a header field.
</t>
<t>
   Historically, HTTP header field values could be extended over multiple
   lines by preceding each extra line with at least one space or horizontal
   tab (obs-fold). This specification deprecates such line folding except
   within the message/http media type
   (<xref target="internet.media.type.message.http"/>).
   A sender &MUST-NOT; generate a message that includes line folding
   (i.e., that has any field-value that contains a match to the
   <x:ref>obs-fold</x:ref> rule) unless the message is intended for packaging
   within the message/http media type.
</t>
<t>
   A server that receives an <x:ref>obs-fold</x:ref> in a request message that
   is not within a message/http container &MUST; either reject the message by
   sending a <x:ref>400 (Bad Request)</x:ref>, preferably with a
   representation explaining that obsolete line folding is unacceptable, or
   replace each received <x:ref>obs-fold</x:ref> with one or more
   <x:ref>SP</x:ref> octets prior to interpreting the field value or
   forwarding the message downstream.
</t>
<t>
   A proxy or gateway that receives an <x:ref>obs-fold</x:ref> in a response
   message that is not within a message/http container &MUST; either discard
   the message and replace it with a <x:ref>502 (Bad Gateway)</x:ref>
   response, preferably with a representation explaining that unacceptable
   line folding was received, or replace each received <x:ref>obs-fold</x:ref>
   with one or more <x:ref>SP</x:ref> octets prior to interpreting the field
   value or forwarding the message downstream.
</t>
<t>
   A user agent that receives an <x:ref>obs-fold</x:ref> in a response message
   that is not within a message/http container &MUST; replace each received
   <x:ref>obs-fold</x:ref> with one or more <x:ref>SP</x:ref> octets prior to
   interpreting the field value.
</t>
<t>
   Historically, HTTP has allowed field content with text in the ISO&nbhy;8859&nbhy;1
   charset <xref target="ISO-8859-1"/>, supporting other charsets only
   through use of <xref target="RFC2047"/> encoding.
   In practice, most HTTP header field values use only a subset of the
   US-ASCII charset <xref target="USASCII"/>. Newly defined
   header fields &SHOULD; limit their field values to US&nbhy;ASCII octets.
   A recipient &SHOULD; treat other octets in field content (obs&nbhy;text) as
   opaque data.
</t>
</section>

<section title="Field Limits" anchor="field.limits">
<t>
   HTTP does not place a predefined limit on the length of each header field
   or on the length of the header section as a whole, as described in
   <xref target="conformance"/>. Various ad hoc limitations on individual
   header field length are found in practice, often depending on the specific
   field semantics.
</t>
<t>
   A server that receives a request header field, or set of fields, larger
   than it wishes to process &MUST; respond with an appropriate
   <x:ref>4xx (Client Error)</x:ref> status code. Ignoring such header fields
   would increase the server's vulnerability to request smuggling attacks
   (<xref target="request.smuggling"/>).
</t>
<t>
   A client &MAY; discard or truncate received header fields that are larger
   than the client wishes to process if the field semantics are such that the
   dropped value(s) can be safely ignored without changing the
   message framing or response semantics.
</t>
</section>

<section title="Field Value Components" anchor="field.components">
<t anchor="rule.token.separators">
  <x:anchor-alias value="tchar"/>
  <x:anchor-alias value="token"/>
  <iref item="Delimiters"/>
   Most HTTP header field values are defined using common syntax components
   (token, quoted-string, and comment) separated by whitespace or specific
   delimiting characters. Delimiters are chosen from the set of US-ASCII
   visual characters not allowed in a <x:ref>token</x:ref>
   (DQUOTE and "(),/:;&lt;=>?@[\]{}").
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="token"/><iref primary="true" item="Grammar" subitem="tchar"/>
  <x:ref>token</x:ref>          = 1*<x:ref>tchar</x:ref>
<!--
  NOTE: the definition of tchar and the prose above about special characters need to match!
 -->
  <x:ref>tchar</x:ref>          = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*"
                 / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~" 
                 / <x:ref>DIGIT</x:ref> / <x:ref>ALPHA</x:ref>
                 ; any <x:ref>VCHAR</x:ref>, except delimiters
</artwork></figure>
<t anchor="rule.quoted-string">
  <x:anchor-alias value="quoted-string"/>
  <x:anchor-alias value="qdtext"/>
  <x:anchor-alias value="obs-text"/>
   A string of text is parsed as a single value if it is quoted using
   double-quote marks.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="quoted-string"/><iref primary="true" item="Grammar" subitem="qdtext"/><iref primary="true" item="Grammar" subitem="obs-text"/>
  <x:ref>quoted-string</x:ref>  = <x:ref>DQUOTE</x:ref> *( <x:ref>qdtext</x:ref> / <x:ref>quoted-pair</x:ref> ) <x:ref>DQUOTE</x:ref>
  <x:ref>qdtext</x:ref>         = <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> /%x21 / %x23-5B / %x5D-7E / <x:ref>obs-text</x:ref>
  <x:ref>obs-text</x:ref>       = %x80-FF
</artwork></figure>
<t anchor="rule.comment">
  <x:anchor-alias value="comment"/>
  <x:anchor-alias value="ctext"/>
   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing "comment" as part of their field value definition.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="comment"/><iref primary="true" item="Grammar" subitem="ctext"/>
  <x:ref>comment</x:ref>        = "(" *( <x:ref>ctext</x:ref> / <x:ref>quoted-pair</x:ref> / <x:ref>comment</x:ref> ) ")"
  <x:ref>ctext</x:ref>          = <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / %x21-27 / %x2A-5B / %x5D-7E / <x:ref>obs-text</x:ref>
</artwork></figure>
<t anchor="rule.quoted-pair">
  <x:anchor-alias value="quoted-pair"/>
   The backslash octet ("\") can be used as a single-octet
   quoting mechanism within quoted-string and comment constructs.
   Recipients that process the value of a quoted-string &MUST; handle a
   quoted-pair as if it were replaced by the octet following the backslash. 
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="quoted-pair"/>
  <x:ref>quoted-pair</x:ref>    = "\" ( <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref> ) 
</artwork></figure>
<t>
   A sender &SHOULD-NOT; generate a quoted-pair in a quoted-string except
   where necessary to quote DQUOTE and backslash octets occurring within that
   string.
   A sender &SHOULD-NOT; generate a quoted-pair in a comment except
   where necessary to quote parentheses ["(" and ")"] and backslash octets
   occurring within that comment.
</t>
</section>

</section>

<section title="Message Body" anchor="message.body">
  <x:anchor-alias value="message-body"/>
<t>
   The message body (if any) of an HTTP message is used to carry the
   payload body of that request or response.  The message body is
   identical to the payload body unless a transfer coding has been
   applied, as described in <xref target="header.transfer-encoding"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="message-body"/>
  <x:ref>message-body</x:ref> = *OCTET
</artwork></figure>
<t>
   The rules for when a message body is allowed in a message differ for
   requests and responses.
</t>
<t>
   The presence of a message body in a request is signaled by a
   <x:ref>Content-Length</x:ref> or <x:ref>Transfer-Encoding</x:ref> header
   field. Request message framing is independent of method semantics,
   even if the method does not define any use for a message body.
</t>
<t>
   The presence of a message body in a response depends on both
   the request method to which it is responding and the response
   status code (<xref target="status.line"/>).
   Responses to the HEAD request method (&HEAD;) never include a message body
   because the associated response header fields (e.g.,
   <x:ref>Transfer-Encoding</x:ref>, <x:ref>Content-Length</x:ref>, etc.),
   if present, indicate only what their values would have been if the request
   method had been GET (&GET;).
   <x:ref>2xx (Successful)</x:ref> responses to a CONNECT request method
   (&CONNECT;) switch to tunnel mode instead of having a message body.
   All <x:ref>1xx (Informational)</x:ref>, <x:ref>204 (No Content)</x:ref>, and
   <x:ref>304 (Not Modified)</x:ref> responses do not include a message body.
   All other responses do include a message body, although the body
   might be of zero length.
</t>

<section title="Transfer-Encoding" anchor="header.transfer-encoding">
  <iref primary="true" item="Transfer-Encoding header field" x:for-anchor=""/>
  <iref item="chunked (Coding Format)"/>
  <x:anchor-alias value="Transfer-Encoding"/>
<t>
   The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been
   (or will be) applied to the payload body in order to form the message body.
   Transfer codings are defined in <xref target="transfer.codings"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Transfer-Encoding"/>
  <x:ref>Transfer-Encoding</x:ref> = 1#<x:ref>transfer-coding</x:ref>
</artwork></figure>
<t>
   Transfer-Encoding is analogous to the Content-Transfer-Encoding field of
   MIME, which was designed to enable safe transport of binary data over a
   7-bit transport service (<xref target="RFC2045" x:fmt="," x:sec="6"/>).
   However, safe transport has a different focus for an 8bit-clean transfer
   protocol. In HTTP's case, Transfer-Encoding is primarily intended to
   accurately delimit a dynamically generated payload and to distinguish
   payload encodings that are only applied for transport efficiency or
   security from those that are characteristics of the selected resource.
</t>
<t>
   A recipient &MUST; be able to parse the chunked transfer coding
   (<xref target="chunked.encoding"/>) because it plays a crucial role in
   framing messages when the payload body size is not known in advance.
   A sender &MUST-NOT; apply chunked more than once to a message body
   (i.e., chunking an already chunked message is not allowed).
   If any transfer coding other than chunked is applied to a request payload
   body, the sender &MUST; apply chunked as the final transfer coding to
   ensure that the message is properly framed.
   If any transfer coding other than chunked is applied to a response payload
   body, the sender &MUST; either apply chunked as the final transfer coding
   or terminate the message by closing the connection.
</t>
<figure><preamble>
   For example,
</preamble><artwork type="example">
  Transfer-Encoding: gzip, chunked
</artwork><postamble>
   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.
</postamble></figure>
<t>
   Unlike <x:ref>Content-Encoding</x:ref> (&content-codings;),
   Transfer-Encoding is a property of the message, not of the representation, and
   any recipient along the request/response chain &MAY; decode the received
   transfer coding(s) or apply additional transfer coding(s) to the message
   body, assuming that corresponding changes are made to the Transfer-Encoding
   field-value. Additional information about the encoding parameters can be
   provided by other header fields not defined by this specification.
</t>
<t>
   Transfer-Encoding &MAY; be sent in a response to a HEAD request or in a
   <x:ref>304 (Not Modified)</x:ref> response (&status-304;) to a GET request,
   neither of which includes a message body,
   to indicate that the origin server would have applied a transfer coding
   to the message body if the request had been an unconditional GET.
   This indication is not required, however, because any recipient on
   the response chain (including the origin server) can remove transfer
   codings when they are not needed.
</t>
<t>
   A server &MUST-NOT; send a Transfer-Encoding header field in any response
   with a status code of
   <x:ref>1xx (Informational)</x:ref> or <x:ref>204 (No Content)</x:ref>.
   A server &MUST-NOT; send a Transfer-Encoding header field in any
   <x:ref>2xx (Successful)</x:ref> response to a CONNECT request (&CONNECT;).
</t>
<t>
   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed that
   implementations advertising only HTTP/1.0 support will not understand
   how to process a transfer-encoded payload.
   A client &MUST-NOT; send a request containing Transfer-Encoding unless it
   knows the server will handle HTTP/1.1 (or later) requests; such knowledge
   might be in the form of specific user configuration or by remembering the
   version of a prior received response.
   A server &MUST-NOT; send a response containing Transfer-Encoding unless
   the corresponding request indicates HTTP/1.1 (or later).
</t>
<t>
   A server that receives a request message with a transfer coding it does
   not understand &SHOULD; respond with <x:ref>501 (Not Implemented)</x:ref>.
</t>
</section>

<section title="Content-Length" anchor="header.content-length">
  <iref primary="true" item="Content-Length header field" x:for-anchor=""/>
  <x:anchor-alias value="Content-Length"/>
<t>
   When a message does not have a <x:ref>Transfer-Encoding</x:ref> header
   field, a Content-Length header field can provide the anticipated size,
   as a decimal number of octets, for a potential payload body.
   For messages that do include a payload body, the Content-Length field-value
   provides the framing information necessary for determining where the body
   (and message) ends.  For messages that do not include a payload body, the
   Content-Length indicates the size of the selected representation
   (&representation;).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Length"/>
  <x:ref>Content-Length</x:ref> = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   An example is
</t>
<figure><artwork type="example">
  Content-Length: 3495
</artwork></figure>
<t>
   A sender &MUST-NOT; send a Content-Length header field in any message that
   contains a <x:ref>Transfer-Encoding</x:ref> header field.
</t>
<t>
   A user agent &SHOULD; send a Content-Length in a request message when no
   <x:ref>Transfer-Encoding</x:ref> is sent and the request method defines
   a meaning for an enclosed payload body. For example, a Content-Length
   header field is normally sent in a POST request even when the value is
   0 (indicating an empty payload body).  A user agent &SHOULD-NOT; send a
   Content-Length header field when the request message does not contain a
   payload body and the method semantics do not anticipate such a body.
</t>
<t>
   A server &MAY; send a Content-Length header field in a response to a HEAD
   request (&HEAD;); a server &MUST-NOT; send Content-Length in such a
   response unless its field-value equals the decimal number of octets that
   would have been sent in the payload body of a response if the same
   request had used the GET method.
</t>
<t>
   A server &MAY; send a Content-Length header field in a
   <x:ref>304 (Not Modified)</x:ref> response to a conditional GET request
   (&status-304;); a server &MUST-NOT; send Content-Length in such a
   response unless its field-value equals the decimal number of octets that
   would have been sent in the payload body of a <x:ref>200 (OK)</x:ref>
   response to the same request.
</t>
<t>
   A server &MUST-NOT; send a Content-Length header field in any response
   with a status code of
   <x:ref>1xx (Informational)</x:ref> or <x:ref>204 (No Content)</x:ref>.
   A server &MUST-NOT; send a Content-Length header field in any
   <x:ref>2xx (Successful)</x:ref> response to a CONNECT request (&CONNECT;).
</t>
<t>
   Aside from the cases defined above, in the absence of Transfer-Encoding,
   an origin server &SHOULD; send a Content-Length header field when the
   payload body size is known prior to sending the complete header section.
   This will allow downstream recipients to measure transfer progress,
   know when a received message is complete, and potentially reuse the
   connection for additional requests.
</t>
<t>
   Any Content-Length field value greater than or equal to zero is valid.
   Since there is no predefined limit to the length of a payload, a
   recipient &MUST; anticipate potentially large decimal numerals and
   prevent parsing errors due to integer conversion overflows
   (<xref target="attack.protocol.element.length"/>).
</t>
<t>
   If a message is received that has multiple Content-Length header fields
   with field-values consisting of the same decimal value, or a single
   Content-Length header field with a field value containing a list of
   identical decimal values (e.g., "Content-Length: 42, 42"), indicating that
   duplicate Content-Length header fields have been generated or combined by an
   upstream message processor, then the recipient &MUST; either reject the
   message as invalid or replace the duplicated field-values with a single
   valid Content-Length field containing that decimal value prior to
   determining the message body length or forwarding the message.
</t>
<x:note>
  <t>
   &Note; HTTP's use of Content-Length for message framing differs
   significantly from the same field's use in MIME, where it is an optional
   field used only within the "message/external-body" media-type.
  </t>
</x:note>
</section>

<section title="Message Body Length" anchor="message.body.length">
  <iref item="chunked (Coding Format)"/>
<t>
   The length of a message body is determined by one of the following
   (in order of precedence):
</t>
<t>
  <list style="numbers">
    <x:lt><t>
     Any response to a HEAD request and any response with a 
     <x:ref>1xx (Informational)</x:ref>, <x:ref>204 (No Content)</x:ref>, or
     <x:ref>304 (Not Modified)</x:ref> status code is always
     terminated by the first empty line after the header fields, regardless of
     the header fields present in the message, and thus cannot contain a
     message body.
    </t></x:lt>
    <x:lt><t>
     Any <x:ref>2xx (Successful)</x:ref> response to a CONNECT request implies that the
     connection will become a tunnel immediately after the empty line that
     concludes the header fields.  A client &MUST; ignore any
     <x:ref>Content-Length</x:ref> or <x:ref>Transfer-Encoding</x:ref> header
     fields received in such a message.
    </t></x:lt>
    <x:lt><t>
     If a <x:ref>Transfer-Encoding</x:ref> header field is present
     and the chunked transfer coding (<xref target="chunked.encoding"/>)
     is the final encoding, the message body length is determined by reading
     and decoding the chunked data until the transfer coding indicates the
     data is complete.
    </t>
    <t>
     If a <x:ref>Transfer-Encoding</x:ref> header field is present in a
     response and the chunked transfer coding is not the final encoding, the
     message body length is determined by reading the connection until it is
     closed by the server.
     If a <x:ref>Transfer-Encoding</x:ref> header field is present in a request and the
     chunked transfer coding is not the final encoding, the message body
     length cannot be determined reliably; the server &MUST; respond with
     the <x:ref>400 (Bad Request)</x:ref> status code and then close the connection.
    </t>
    <t>
     If a message is received with both a <x:ref>Transfer-Encoding</x:ref>
     and a <x:ref>Content-Length</x:ref> header field, the Transfer-Encoding
     overrides the Content-Length. Such a message might indicate an attempt to
     perform request smuggling (<xref target="request.smuggling"/>) or
     response splitting (<xref target="response.splitting"/>) and ought to be
     handled as an error. A sender &MUST; remove the received Content-Length
     field prior to forwarding such a message downstream.
    </t></x:lt>
    <x:lt><t>
     If a message is received without <x:ref>Transfer-Encoding</x:ref> and with
     either multiple <x:ref>Content-Length</x:ref> header fields having
     differing field-values or a single Content-Length header field having an
     invalid value, then the message framing is invalid and
     the recipient &MUST; treat it as an unrecoverable error.
     If this is a request message, the server &MUST; respond with
     a <x:ref>400 (Bad Request)</x:ref> status code and then close the connection.
     If this is a response message received by a proxy,
     the proxy &MUST; close the connection to the server, discard the received
     response, and send a <x:ref>502 (Bad Gateway)</x:ref> response to the
     client.
     If this is a response message received by a user agent,
     the user agent &MUST; close the connection to the server and discard the
     received response.
    </t></x:lt>
    <x:lt><t>
     If a valid <x:ref>Content-Length</x:ref> header field is present without
     <x:ref>Transfer-Encoding</x:ref>, its decimal value defines the
     expected message body length in octets.
     If the sender closes the connection or the recipient times out before the
     indicated number of octets are received, the recipient &MUST; consider
     the message to be incomplete and close the connection.
    </t></x:lt>
    <x:lt><t>
     If this is a request message and none of the above are true, then the
     message body length is zero (no message body is present).
    </t></x:lt>
    <x:lt><t>
     Otherwise, this is a response message without a declared message body
     length, so the message body length is determined by the number of octets
     received prior to the server closing the connection.
    </t></x:lt>
  </list>
</t>
<t>
   Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server &SHOULD; generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.
</t>
<t>
   A server &MAY; reject a request that contains a message body but
   not a <x:ref>Content-Length</x:ref> by responding with
   <x:ref>411 (Length Required)</x:ref>.
</t>
<t>
   Unless a transfer coding other than chunked has been applied,
   a client that sends a request containing a message body &SHOULD;
   use a valid <x:ref>Content-Length</x:ref> header field if the message body
   length is known in advance, rather than the chunked transfer coding, since some
   existing services respond to chunked with a <x:ref>411 (Length Required)</x:ref>
   status code even though they understand the chunked transfer coding.  This
   is typically because such services are implemented via a gateway that
   requires a content-length in advance of being called and the server
   is unable or unwilling to buffer the entire request before processing.
</t>
<t>
   A user agent that sends a request containing a message body &MUST; send a
   valid <x:ref>Content-Length</x:ref> header field if it does not know the
   server will handle HTTP/1.1 (or later) requests; such knowledge can be in
   the form of specific user configuration or by remembering the version of a
   prior received response.
</t>
<t>
   If the final response to the last request on a connection has been
   completely received and there remains additional data to read, a user agent
   &MAY; discard the remaining data or attempt to determine if that data
   belongs as part of the prior response body, which might be the case if the
   prior message's Content-Length value is incorrect. A client &MUST-NOT;
   process, cache, or forward such extra data as a separate response, since
   such behavior would be vulnerable to cache poisoning.
</t>
</section>
</section>

<section anchor="incomplete.messages" title="Handling Incomplete Messages">
<t>
   A server that receives an incomplete request message, usually due to a
   canceled request or a triggered timeout exception, &MAY; send an error
   response prior to closing the connection.
</t>
<t>
   A client that receives an incomplete response message, which can occur
   when a connection is closed prematurely or when decoding a supposedly
   chunked transfer coding fails, &MUST; record the message as incomplete.
   Cache requirements for incomplete responses are defined in
   &cache-incomplete;.
</t>
<t>
   If a response terminates in the middle of the header section (before the
   empty line is received) and the status code might rely on header fields to
   convey the full meaning of the response, then the client cannot assume
   that meaning has been conveyed; the client might need to repeat the
   request in order to determine what action to take next.
</t>
<t>
   A message body that uses the chunked transfer coding is
   incomplete if the zero-sized chunk that terminates the encoding has not
   been received.  A message that uses a valid <x:ref>Content-Length</x:ref> is
   incomplete if the size of the message body received (in octets) is less than
   the value given by Content-Length.  A response that has neither chunked
   transfer coding nor Content-Length is terminated by closure of the
   connection and, thus, is considered complete regardless of the number of
   message body octets received, provided that the header section was received
   intact.
</t>
</section>

<section title="Message Parsing Robustness" anchor="message.robustness">
<t>
   Older HTTP/1.0 user agent implementations might send an extra CRLF
   after a POST request as a workaround for some early server
   applications that failed to read message body content that was
   not terminated by a line-ending. An HTTP/1.1 user agent &MUST-NOT;
   preface or follow a request with an extra CRLF.  If terminating
   the request message body with a line-ending is desired, then the
   user agent &MUST; count the terminating CRLF octets as part of the
   message body length. 
</t>
<t>
   In the interest of robustness, a server that is expecting to receive and
   parse a request-line &SHOULD; ignore at least one empty line (CRLF)
   received prior to the request-line.
</t>
<t>
   Although the line terminator for the start-line and header
   fields is the sequence CRLF, a recipient &MAY; recognize a
   single LF as a line terminator and ignore any preceding CR.
</t>
<t>
   Although the request-line and status-line grammar rules require that each
   of the component elements be separated by a single SP octet, recipients
   &MAY; instead parse on whitespace-delimited word boundaries and, aside
   from the CRLF terminator, treat any form of whitespace as the SP separator
   while ignoring preceding or trailing whitespace;
   such whitespace includes one or more of the following octets:
   SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.
   However, lenient parsing can result in security vulnerabilities if there
   are multiple recipients of the message and each has its own unique
   interpretation of robustness (see <xref target="request.smuggling"/>).
</t>
<t>
   When a server listening only for HTTP request messages, or processing
   what appears from the start-line to be an HTTP request message,
   receives a sequence of octets that does not match the HTTP-message
   grammar aside from the robustness exceptions listed above, the
   server &SHOULD; respond with a <x:ref>400 (Bad Request)</x:ref> response.  
</t>
</section>
</section>

<section title="Transfer Codings" anchor="transfer.codings">
  <x:anchor-alias value="transfer-coding"/>
  <x:anchor-alias value="transfer-extension"/>
<t>
   Transfer coding names are used to indicate an encoding
   transformation that has been, can be, or might need to be applied to a
   payload body in order to ensure "safe transport" through the network.
   This differs from a content coding in that the transfer coding is a
   property of the message rather than a property of the representation
   that is being transferred.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="transfer-coding"/><iref primary="true" item="Grammar" subitem="transfer-extension"/>
  <x:ref>transfer-coding</x:ref>    = "chunked" ; <xref target="chunked.encoding"/>
                     / "compress" ; <xref target="compress.coding"/>
                     / "deflate" ; <xref target="deflate.coding"/>
                     / "gzip" ; <xref target="gzip.coding"/>
                     / <x:ref>transfer-extension</x:ref>
  <x:ref>transfer-extension</x:ref> = <x:ref>token</x:ref> *( <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> <x:ref>transfer-parameter</x:ref> )
</artwork></figure>
<t anchor="rule.parameter">
  <x:anchor-alias value="transfer-parameter"/>
   Parameters are in the form of a name or name=value pair.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="transfer-parameter"/>
  <x:ref>transfer-parameter</x:ref> = <x:ref>token</x:ref> <x:ref>BWS</x:ref> "=" <x:ref>BWS</x:ref> ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> )
</artwork></figure>
<t>
   All transfer-coding names are case-insensitive and ought to be registered
   within the HTTP Transfer Coding registry, as defined in
   <xref target="transfer.coding.registry"/>.
   They are used in the <x:ref>TE</x:ref> (<xref target="header.te"/>) and
   <x:ref>Transfer-Encoding</x:ref> (<xref target="header.transfer-encoding"/>)
   header fields.
</t>

<section title="Chunked Transfer Coding" anchor="chunked.encoding">
  <iref primary="true" item="chunked (Coding Format)"/>
  <x:anchor-alias value="chunk"/>
  <x:anchor-alias value="chunked-body"/>
  <x:anchor-alias value="chunk-data"/>
  <x:anchor-alias value="chunk-size"/>
  <x:anchor-alias value="last-chunk"/>
<t>
   The chunked transfer coding wraps the payload body in order to transfer it
   as a series of chunks, each with its own size indicator, followed by an
   &OPTIONAL; trailer containing header fields. Chunked enables content
   streams of unknown size to be transferred as a sequence of length-delimited
   buffers, which enables the sender to retain connection persistence and the
   recipient to know when it has received the entire message.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="chunked-body"><!--terminal production--></iref><iref primary="true" item="Grammar" subitem="chunk"/><iref primary="true" item="Grammar" subitem="chunk-size"/><iref primary="true" item="Grammar" subitem="last-chunk"/><iref primary="false" item="Grammar" subitem="trailer-part"/><iref primary="false" item="Grammar" subitem="chunk-ext"/><iref primary="true" item="Grammar" subitem="chunk-data"/>
  <x:ref>chunked-body</x:ref>   = *<x:ref>chunk</x:ref>
                   <x:ref>last-chunk</x:ref>
                   <x:ref>trailer-part</x:ref>
                   <x:ref>CRLF</x:ref>
  
  <x:ref>chunk</x:ref>          = <x:ref>chunk-size</x:ref> [ <x:ref>chunk-ext</x:ref> ] <x:ref>CRLF</x:ref>
                   <x:ref>chunk-data</x:ref> <x:ref>CRLF</x:ref>
  <x:ref>chunk-size</x:ref>     = 1*<x:ref>HEXDIG</x:ref>
  <x:ref>last-chunk</x:ref>     = 1*("0") [ <x:ref>chunk-ext</x:ref> ] <x:ref>CRLF</x:ref>
  
  <x:ref>chunk-data</x:ref>     = 1*<x:ref>OCTET</x:ref> ; a sequence of chunk-size octets
</artwork></figure>
<t>
   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets. The chunked transfer coding is complete when a
   chunk with a chunk-size of zero is received, possibly followed by a
   trailer, and finally terminated by an empty line.
</t>
<t>
   A recipient &MUST; be able to parse and decode the chunked transfer coding.
</t>

<section title="Chunk Extensions" anchor="chunked.extension">
  <x:anchor-alias value="chunk-ext"/>
  <x:anchor-alias value="chunk-ext-name"/>
  <x:anchor-alias value="chunk-ext-val"/>
<t>
   The chunked encoding allows each chunk to include zero or more chunk
   extensions, immediately following the <x:ref>chunk-size</x:ref>, for the
   sake of supplying per-chunk metadata (such as a signature or hash),
   mid-message control information, or randomization of message body size.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="chunked-body"><!--terminal production--></iref><iref primary="true" item="Grammar" subitem="chunk-ext"/><iref primary="true" item="Grammar" subitem="chunk-ext-name"/><iref primary="true" item="Grammar" subitem="chunk-ext-val"/>
  <x:ref>chunk-ext</x:ref>      = *( ";" <x:ref>chunk-ext-name</x:ref> [ "=" <x:ref>chunk-ext-val</x:ref> ] )

  <x:ref>chunk-ext-name</x:ref> = <x:ref>token</x:ref>
  <x:ref>chunk-ext-val</x:ref>  = <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref>
</artwork></figure>
<t>
   The chunked encoding is specific to each connection and is likely to be
   removed or recoded by each recipient (including intermediaries) before any
   higher-level application would have a chance to inspect the extensions.
   Hence, use of chunk extensions is generally limited to specialized HTTP
   services such as "long polling" (where client and server can have shared
   expectations regarding the use of chunk extensions) or for padding within
   an end-to-end secured connection.
</t>
<t>
   A recipient &MUST; ignore unrecognized chunk extensions.
   A server ought to limit the total length of chunk extensions received in a
   request to an amount reasonable for the services provided, in the same way
   that it applies length limitations and timeouts for other parts of a
   message, and generate an appropriate <x:ref>4xx (Client Error)</x:ref>
   response if that amount is exceeded.
</t>
</section>

<section title="Chunked Trailer Part" anchor="chunked.trailer.part">
  <x:anchor-alias value="trailer-part"/>
<t>
   A trailer allows the sender to include additional fields at the end of a
   chunked message in order to supply metadata that might be dynamically
   generated while the message body is sent, such as a message integrity
   check, digital signature, or post-processing status. The trailer fields are
   identical to header fields, except they are sent in a chunked trailer
   instead of the message's header section.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="trailer-part"/><iref primary="false" item="Grammar" subitem="header-field"/>
  <x:ref>trailer-part</x:ref>   = *( <x:ref>header-field</x:ref> <x:ref>CRLF</x:ref> )
</artwork></figure>
<t>
   A sender &MUST-NOT; generate a trailer that contains a field necessary for
   message framing (e.g., <x:ref>Transfer-Encoding</x:ref> and
   <x:ref>Content-Length</x:ref>), routing (e.g., <x:ref>Host</x:ref>),
   request modifiers (e.g., controls and conditionals in
   &request-header-fields;), authentication (e.g., see <xref target="RFC7235"/>
   and <xref target="RFC6265"/>), response control data (e.g., see
   &response-control-data;), or determining how to process the payload
   (e.g., <x:ref>Content-Encoding</x:ref>, <x:ref>Content-Type</x:ref>,
   <x:ref>Content-Range</x:ref>, and <x:ref>Trailer</x:ref>).
</t>
<t>
   When a chunked message containing a non-empty trailer is received, the
   recipient &MAY; process the fields (aside from those forbidden above)
   as if they were appended to the message's header section.
   A recipient &MUST; ignore (or consider as an error) any fields that are
   forbidden to be sent in a trailer, since processing them as if they were
   present in the header section might bypass external security filters.
</t>
<t>
   Unless the request includes a <x:ref>TE</x:ref> header field indicating
   "trailers" is acceptable, as described in <xref target="header.te"/>, a
   server &SHOULD-NOT; generate trailer fields that it believes are necessary
   for the user agent to receive. Without a TE containing "trailers", the
   server ought to assume that the trailer fields might be silently discarded
   along the path to the user agent. This requirement allows intermediaries to
   forward a de-chunked message to an HTTP/1.0 recipient without buffering the
   entire response.
</t>
</section>

<section title="Decoding Chunked" anchor="decoding.chunked">
<t>
   A process for decoding the chunked transfer coding
   can be represented in pseudo-code as:
</t>
<figure><artwork type="code">
  length := 0
  read chunk-size, chunk-ext (if any), and CRLF
  while (chunk-size &gt; 0) {
     read chunk-data and CRLF
     append chunk-data to decoded-body
     length := length + chunk-size
     read chunk-size, chunk-ext (if any), and CRLF
  }
  read trailer field
  while (trailer field is not empty) {
     if (trailer field is allowed to be sent in a trailer) {
         append trailer field to existing header fields
     }
     read trailer-field
  }
  Content-Length := length
  Remove "chunked" from Transfer-Encoding
  Remove Trailer from existing header fields
</artwork></figure>
</section>
</section>

<section title="Compression Codings" anchor="compression.codings">
<t>
   The codings defined below can be used to compress the payload of a
   message.
</t>

<section title="Compress Coding" anchor="compress.coding">
<iref item="compress (Coding Format)"/>
<t>
   The "compress" coding is an adaptive Lempel-Ziv-Welch (LZW) coding
   <xref target="Welch"/> that is commonly produced by the UNIX file
   compression program "compress".
   A recipient &SHOULD; consider "x-compress" to be equivalent to "compress".
</t>
</section>

<section title="Deflate Coding" anchor="deflate.coding">
<iref item="deflate (Coding Format)"/>
<t>
   The "deflate" coding is a "zlib" data format <xref target="RFC1950"/>
   containing a "deflate" compressed data stream <xref target="RFC1951"/>
   that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and
   Huffman coding.
</t>
<x:note>
  <t>
    &Note; Some non-conformant implementations send the "deflate" 
    compressed data without the zlib wrapper.
   </t>
</x:note>
</section>

<section title="Gzip Coding" anchor="gzip.coding">
<iref item="gzip (Coding Format)"/>
<t>
   The "gzip" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check
   (CRC) that is commonly
   produced by the gzip file compression program <xref target="RFC1952"/>.
   A recipient &SHOULD; consider "x-gzip" to be equivalent to "gzip".
</t>
</section>

</section>

<section title="TE" anchor="header.te">
  <iref primary="true" item="TE header field" x:for-anchor=""/>
  <x:anchor-alias value="TE"/>
  <x:anchor-alias value="t-codings"/>
  <x:anchor-alias value="t-ranking"/>
  <x:anchor-alias value="rank"/>
<t>
   The "TE" header field in a request indicates what transfer codings,
   besides chunked, the client is willing to accept in response, and
   whether or not the client is willing to accept trailer fields in a
   chunked transfer coding.
</t>
<t>
   The TE field-value consists of a comma-separated list of transfer coding
   names, each allowing for optional parameters (as described in
   <xref target="transfer.codings"/>), and/or the keyword "trailers".
   A client &MUST-NOT; send the chunked transfer coding name in TE;
   chunked is always acceptable for HTTP/1.1 recipients.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="TE"/><iref primary="true" item="Grammar" subitem="t-codings"/><iref primary="true" item="Grammar" subitem="t-ranking"/><iref primary="true" item="Grammar" subitem="rank"/>
  <x:ref>TE</x:ref>        = #<x:ref>t-codings</x:ref>
  <x:ref>t-codings</x:ref> = "trailers" / ( <x:ref>transfer-coding</x:ref> [ <x:ref>t-ranking</x:ref> ] )
  <x:ref>t-ranking</x:ref> = <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> "q=" <x:ref>rank</x:ref>
  <x:ref>rank</x:ref>      = ( "0" [ "." 0*3<x:ref>DIGIT</x:ref> ] )
             / ( "1" [ "." 0*3("0") ] )
</artwork></figure>
<t>
   Three examples of TE use are below.
</t>
<figure><artwork type="example">
  TE: deflate
  TE:
  TE: trailers, deflate;q=0.5
</artwork></figure>
<t>
   The presence of the keyword "trailers" indicates that the client is willing
   to accept trailer fields in a chunked transfer coding, as defined in
   <xref target="chunked.trailer.part"/>, on behalf of itself and any downstream
   clients. For requests from an intermediary, this implies that either:
   (a) all downstream clients are willing to accept trailer fields in the
   forwarded response; or,
   (b) the intermediary will attempt to buffer the response on behalf of
   downstream recipients.
   Note that HTTP/1.1 does not define any means to limit the size of a
   chunked response such that an intermediary can be assured of buffering the
   entire response.
</t>
<t>
   When multiple transfer codings are acceptable, the client &MAY; rank the
   codings by preference using a case-insensitive "q" parameter (similar to
   the qvalues used in content negotiation fields, &qvalue;). The rank value
   is a real number in the range 0 through 1, where 0.001 is the least
   preferred and 1 is the most preferred; a value of 0 means "not acceptable".
</t>
<t>
   If the TE field-value is empty or if no TE field is present, the only
   acceptable transfer coding is chunked. A message with no transfer coding
   is always acceptable.
</t>
<t>
   Since the TE header field only applies to the immediate connection,
   a sender of TE &MUST; also send a "TE" connection option within the
   <x:ref>Connection</x:ref> header field (<xref target="header.connection"/>)
   in order to prevent the TE field from being forwarded by intermediaries
   that do not support its semantics.
</t>
</section>

<section title="Trailer" anchor="header.trailer">
  <iref primary="true" item="Trailer header field" x:for-anchor=""/>
  <x:anchor-alias value="Trailer"/>
<t>
   When a message includes a message body encoded with the chunked
   transfer coding and the sender desires to send metadata in the form of
   trailer fields at the end of the message, the sender &SHOULD; generate a
   <x:ref>Trailer</x:ref> header field before the message body to indicate
   which fields will be present in the trailers. This allows the recipient
   to prepare for receipt of that metadata before it starts processing the body,
   which is useful if the message is being streamed and the recipient wishes
   to confirm an integrity check on the fly.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Trailer"/><iref primary="false" item="Grammar" subitem="field-name"/>
  <x:ref>Trailer</x:ref> = 1#<x:ref>field-name</x:ref>
</artwork></figure>
</section>
</section>

<section title="Message Routing" anchor="message.routing">
<t>
   HTTP request message routing is determined by each client based on the
   target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the client.
</t>

<section title="Identifying a Target Resource" anchor="target-resource">
  <iref primary="true" item="target resource"/>
  <iref primary="true" item="target URI"/>
  <x:anchor-alias value="target resource"/>
  <x:anchor-alias value="target URI"/>
<t>
   HTTP is used in a wide variety of applications, ranging from
   general-purpose computers to home appliances.  In some cases,
   communication options are hard-coded in a client's configuration.
   However, most HTTP clients rely on the same resource identification
   mechanism and configuration techniques as general-purpose Web browsers.
</t>
<t>
   HTTP communication is initiated by a user agent for some purpose.
   The purpose is a combination of request semantics, which are defined in
   <xref target="RFC7231"/>, and a target resource upon which to apply those
   semantics.  A URI reference (<xref target="uri"/>) is typically used as
   an identifier for the "<x:dfn>target resource</x:dfn>", which a user agent
   would resolve to its absolute form in order to obtain the
   "<x:dfn>target URI</x:dfn>".  The target URI
   excludes the reference's fragment component, if any,
   since fragment identifiers are reserved for client-side processing
   (<xref target="RFC3986" x:fmt="," x:sec="3.5"/>).
</t>
</section>

<section title="Connecting Inbound" anchor="connecting.inbound">
<t>
   Once the target URI is determined, a client needs to decide whether
   a network request is necessary to accomplish the desired semantics and,
   if so, where that request is to be directed.
</t>
<t>
   If the client has a cache <xref target="RFC7234"/> and the request can be
   satisfied by it, then the request is
   usually directed there first.
</t>
<t>
   If the request is not satisfied by a cache, then a typical client will
   check its configuration to determine whether a proxy is to be used to
   satisfy the request.  Proxy configuration is implementation-dependent,
   but is often based on URI prefix matching, selective authority matching,
   or both, and the proxy itself is usually identified by an "http" or
   "https" URI.  If a proxy is applicable, the client connects inbound by 
   establishing (or reusing) a connection to that proxy.
</t>
<t>
   If no proxy is applicable, a typical client will invoke a handler routine,
   usually specific to the target URI's scheme, to connect directly
   to an authority for the target resource.  How that is accomplished is
   dependent on the target URI scheme and defined by its associated
   specification, similar to how this specification defines origin server
   access for resolution of the "http" (<xref target="http.uri"/>) and
   "https" (<xref target="https.uri"/>) schemes.
</t>
<t>
   HTTP requirements regarding connection management are defined in
   <xref target="connection.management"/>.
</t>
</section>

<section title="Request Target" anchor="request-target">
<t>
   Once an inbound connection is obtained,
   the client sends an HTTP request message (<xref target="http.message"/>)
   with a request-target derived from the target URI.
   There are four distinct formats for the request-target, depending on both
   the method being requested and whether the request is to a proxy.
</t>   
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="request-target"/><iref primary="false" item="Grammar" subitem="origin-form"/><iref primary="false" item="Grammar" subitem="absolute-form"/><iref primary="false" item="Grammar" subitem="authority-form"/><iref primary="false" item="Grammar" subitem="asterisk-form"/>
  <x:ref>request-target</x:ref> = <x:ref>origin-form</x:ref>
                 / <x:ref>absolute-form</x:ref>
                 / <x:ref>authority-form</x:ref>
                 / <x:ref>asterisk-form</x:ref>
</artwork></figure>

<section title="origin-form" anchor="origin-form">
   <iref item="origin-form (of request-target)"/>
<t>
   The most common form of request-target is the <x:dfn>origin-form</x:dfn>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="origin-form"/>
  <x:ref>origin-form</x:ref>    = <x:ref>absolute-path</x:ref> [ "?" <x:ref>query</x:ref> ]
</artwork></figure>
<t>
   When making a request directly to an origin server, other than a CONNECT
   or server-wide OPTIONS request (as detailed below),
   a client &MUST; send only the absolute path and query components of
   the target URI as the request-target.
   If the target URI's path component is empty, the client &MUST; send
   "/" as the path within the origin-form of request-target.
   A <x:ref>Host</x:ref> header field is also sent, as defined in
   <xref target="header.host"/>.
</t>
<t>
   For example, a client wishing to retrieve a representation of the resource
   identified as
</t>
<figure><artwork x:indent-with="  " type="example">
http://www.example.org/where?q=now
</artwork></figure>
<t>
   directly from the origin server would open (or reuse) a TCP connection
   to port 80 of the host "www.example.org" and send the lines:
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /where?q=now HTTP/1.1
Host: www.example.org
</artwork></figure>
<t>
   followed by the remainder of the request message.
</t>
</section>

<section title="absolute-form" anchor="absolute-form">
   <iref item="absolute-form (of request-target)"/>
<t>
   When making a request to a proxy, other than a CONNECT or server-wide
   OPTIONS request (as detailed below), a client &MUST; send the target URI
   in <x:dfn>absolute-form</x:dfn> as the request-target.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="absolute-form"/>
  <x:ref>absolute-form</x:ref>  = <x:ref>absolute-URI</x:ref>
</artwork></figure>
<t>
   The proxy is requested to either service that request from a valid cache,
   if possible, or make the same request on the client's behalf to either
   the next inbound proxy server or directly to the origin server indicated
   by the request-target.  Requirements on such "forwarding" of messages are
   defined in <xref target="message.forwarding"/>.
</t>
<t>
   An example absolute-form of request-line would be:
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
</artwork></figure>
<t>
   To allow for transition to the absolute-form for all requests in some
   future version of HTTP, a server &MUST; accept the absolute-form
   in requests, even though HTTP/1.1 clients will only send them in requests
   to proxies.
</t>
</section>

<section title="authority-form" anchor="authority-form">
   <iref item="authority-form (of request-target)"/>
<t>
   The <x:dfn>authority-form</x:dfn> of request-target is only used for
   CONNECT requests (&CONNECT;).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="authority-form"/>
  <x:ref>authority-form</x:ref> = <x:ref>authority</x:ref>
</artwork></figure>
<t>
   When making a CONNECT request to establish a
   tunnel through one or more proxies, a client &MUST; send only the target
   URI's authority component (excluding any userinfo and its "@" delimiter) as
   the request-target. For example,
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
CONNECT www.example.com:80 HTTP/1.1
</artwork></figure>
</section>

<section title="asterisk-form" anchor="asterisk-form">
   <iref item="asterisk-form (of request-target)"/>
<t>
   The <x:dfn>asterisk-form</x:dfn> of request-target is only used for a server-wide
   OPTIONS request (&OPTIONS;).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="asterisk-form"/>
  <x:ref>asterisk-form</x:ref>  = "*"
</artwork></figure>
<t>
   When a client wishes to request OPTIONS
   for the server as a whole, as opposed to a specific named resource of
   that server, the client &MUST; send only "*" (%x2A) as the request-target.
   For example,
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
OPTIONS * HTTP/1.1
</artwork></figure>
<t>
   If a proxy receives an OPTIONS request with an absolute-form of
   request-target in which the URI has an empty path and no query component,
   then the last proxy on the request chain &MUST; send a request-target
   of "*" when it forwards the request to the indicated origin server.
</t>
<figure><preamble>   
   For example, the request
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
OPTIONS http://www.example.org:8001 HTTP/1.1
</artwork></figure>
<figure><preamble>   
  would be forwarded by the final proxy as
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
OPTIONS * HTTP/1.1
Host: www.example.org:8001
</artwork>
<postamble>
   after connecting to port 8001 of host "www.example.org".
</postamble>
</figure>
</section>
</section>

<section title="Host" anchor="header.host">
  <iref primary="true" item="Host header field" x:for-anchor=""/>
  <x:anchor-alias value="Host"/>
<t>
   The "Host" header field in a request provides the host and port
   information from the target URI, enabling the origin
   server to distinguish among resources while servicing requests
   for multiple host names on a single IP address.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Host"/>
  <x:ref>Host</x:ref> = <x:ref>uri-host</x:ref> [ ":" <x:ref>port</x:ref> ] ; <xref target="http.uri"/>
</artwork></figure>
<t>
   A client &MUST; send a Host header field in all HTTP/1.1 request messages.
   If the target URI includes an authority component, then a client &MUST;
   send a field-value for Host that is identical to that authority
   component, excluding any userinfo subcomponent and its "@" delimiter
   (<xref target="http.uri"/>).
   If the authority component is missing or undefined for the target URI,
   then a client &MUST; send a Host header field with an empty field-value.
</t>
<t>
   Since the Host field-value is critical information for handling a request,
   a user agent &SHOULD; generate Host as the first header field following the
   request-line. 
</t>
<t>
   For example, a GET request to the origin server for
   &lt;http://www.example.org/pub/WWW/&gt; would begin with:
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
</artwork></figure>
<t>
   A client &MUST; send a Host header field in an HTTP/1.1 request even
   if the request-target is in the absolute-form, since this
   allows the Host information to be forwarded through ancient HTTP/1.0
   proxies that might not have implemented Host.
</t>
<t>
   When a proxy receives a request with an absolute-form of
   request-target, the proxy &MUST; ignore the received
   Host header field (if any) and instead replace it with the host
   information of the request-target.  A proxy that forwards such a request
   &MUST; generate a new Host field-value based on the received
   request-target rather than forward the received Host field-value.
</t>
<t>
   Since the Host header field acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison
   a shared cache or redirect a request to an unintended server.
   An interception proxy is particularly vulnerable if it relies on
   the Host field-value for redirecting requests to internal
   servers, or for use as a cache key in a shared cache, without
   first verifying that the intercepted connection is targeting a
   valid IP address for that host.
</t>
<t>
   A server &MUST; respond with a <x:ref>400 (Bad Request)</x:ref> status code
   to any HTTP/1.1 request message that lacks a Host header field and
   to any request message that contains more than one Host header field
   or a Host header field with an invalid field-value.
</t>
</section>

<section title="Effective Request URI" anchor="effective.request.uri">
  <iref primary="true" item="effective request URI"/>
  <x:anchor-alias value="effective request URI"/>
<t>
   Since the request-target often contains only part of the user agent's
   target URI, a server reconstructs the intended target as an
   "<x:dfn>effective request URI</x:dfn>" to properly service the request.
   This reconstruction involves both the server's local configuration and
   information communicated in the <x:ref>request-target</x:ref>,
   <x:ref>Host</x:ref> header field, and connection context.
</t>
<t>
   For a user agent, the effective request URI is the target URI.
</t>
<t>
   If the <x:ref>request-target</x:ref> is in <x:ref>absolute-form</x:ref>,
   the effective request URI is the same as the request-target. Otherwise, the
   effective request URI is constructed as follows:
<list style="empty">
<t>
   If the server's configuration (or outbound gateway) provides a fixed URI
   <x:ref>scheme</x:ref>, that scheme is used for the effective request URI.
   Otherwise, if the request is received over a TLS-secured TCP connection,
   the effective request URI's scheme is "https"; if not, the scheme is "http".
</t>
<t>
   If the server's configuration (or outbound gateway) provides a fixed URI
   <x:ref>authority</x:ref> component, that authority is used for the
   effective request URI. If not, then if the request-target is in
   <x:ref>authority-form</x:ref>, the effective request URI's authority
   component is the same as the request-target.
   If not, then if a <x:ref>Host</x:ref> header field is supplied with a
   non-empty field-value, the authority component is the same as the
   Host field-value. Otherwise, the authority component is assigned
   the default name configured for the server and, if the connection's
   incoming TCP port number differs from the default port for the effective
   request URI's scheme, then a colon (":") and the incoming port number (in
   decimal form) are appended to the authority component.
</t>
<t>
   If the request-target is in <x:ref>authority-form</x:ref> or
   <x:ref>asterisk-form</x:ref>, the effective request URI's combined
   <x:ref>path</x:ref> and <x:ref>query</x:ref> component is empty. Otherwise,
   the combined <x:ref>path</x:ref> and <x:ref>query</x:ref> component is the
   same as the request-target.
</t>
<t>
   The components of the effective request URI, once determined as above, can
   be combined into <x:ref>absolute-URI</x:ref> form by concatenating the
   scheme, "://", authority, and combined path and query component.
</t>
</list>
</t>
<figure>
<preamble>
   Example 1: the following message received over an insecure TCP connection
</preamble> 
<artwork type="example" x:indent-with="  ">
GET /pub/WWW/TheProject.html HTTP/1.1
Host: www.example.org:8080
</artwork>
</figure>
<figure>
<preamble>
  has an effective request URI of
</preamble>
<artwork type="example" x:indent-with="  ">
http://www.example.org:8080/pub/WWW/TheProject.html
</artwork>
</figure>
<figure>
<preamble>
   Example 2: the following message received over a TLS-secured TCP connection
</preamble> 
<artwork type="example" x:indent-with="  ">
OPTIONS * HTTP/1.1
Host: www.example.org
</artwork>
</figure>
<figure>
<preamble>
  has an effective request URI of
</preamble>
<artwork type="example" x:indent-with="  ">
https://www.example.org
</artwork>
</figure>
<t>
   Recipients of an HTTP/1.0 request that lacks a <x:ref>Host</x:ref> header
   field might need to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to guess the
   effective request URI's authority component.
</t>
<t>
   Once the effective request URI has been constructed, an origin server needs
   to decide whether or not to provide service for that URI via the connection
   in which the request was received. For example, the request might have been
   misdirected, deliberately or accidentally, such that the information within
   a received <x:ref>request-target</x:ref> or <x:ref>Host</x:ref> header
   field differs from the host or port upon which the connection has been
   made. If the connection is from a trusted gateway, that inconsistency might
   be expected; otherwise, it might indicate an attempt to bypass security
   filters, trick the server into delivering non-public content, or poison a
   cache. See <xref target="security.considerations"/> for security
   considerations regarding message routing.
</t>
</section>

<section title="Associating a Response to a Request" anchor="associating.response.to.request">
<t>
   HTTP does not include a request identifier for associating a given
   request message with its corresponding one or more response messages.
   Hence, it relies on the order of response arrival to correspond exactly
   to the order in which requests are made on the same connection.
   More than one response message per request only occurs when one or more
   informational responses (<x:ref>1xx</x:ref>, see &status-1xx;) precede a
   final response to the same request.
</t>
<t>
   A client that has more than one outstanding request on a connection &MUST;
   maintain a list of outstanding requests in the order sent and &MUST;
   associate each received response message on that connection to the highest
   ordered request that has not yet received a final (non-<x:ref>1xx</x:ref>)
   response.
</t>
</section>

<section title="Message Forwarding" anchor="message.forwarding">
<t>
   As described in <xref target="intermediaries"/>, intermediaries can serve
   a variety of roles in the processing of HTTP requests and responses.
   Some intermediaries are used to improve performance or availability.
   Others are used for access control or to filter content.
   Since an HTTP stream has characteristics similar to a pipe-and-filter
   architecture, there are no inherent limits to the extent an intermediary
   can enhance (or interfere) with either direction of the stream.
</t>
<t>
   An intermediary not acting as a tunnel &MUST; implement the
   <x:ref>Connection</x:ref> header field, as specified in
   <xref target="header.connection"/>, and exclude fields from being forwarded
   that are only intended for the incoming connection.
</t>
<t>
   An intermediary &MUST-NOT; forward a message to itself unless it is
   protected from an infinite request loop. In general, an intermediary ought
   to recognize its own server names, including any aliases, local variations,
   or literal IP addresses, and respond to such requests directly.
</t>

<section title="Via" anchor="header.via">
  <iref primary="true" item="Via header field" x:for-anchor=""/>
  <x:anchor-alias value="pseudonym"/>
  <x:anchor-alias value="received-by"/>
  <x:anchor-alias value="received-protocol"/>
  <x:anchor-alias value="Via"/>
<t>
   The "Via" header field indicates the presence of intermediate protocols and
   recipients between the user agent and the server (on requests) or between
   the origin server and the client (on responses), similar to the
   "Received" header field in email
   (<xref target="RFC5322" x:fmt="of" x:sec="3.6.7"/>).
   Via can be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   senders along the request/response chain.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Via"/><iref primary="true" item="Grammar" subitem="received-protocol"/><iref primary="true" item="Grammar" subitem="protocol-name"/><iref primary="true" item="Grammar" subitem="protocol-version"/><iref primary="true" item="Grammar" subitem="received-by"/><iref primary="true" item="Grammar" subitem="pseudonym"/>
  <x:ref>Via</x:ref> = 1#( <x:ref>received-protocol</x:ref> <x:ref>RWS</x:ref> <x:ref>received-by</x:ref> [ <x:ref>RWS</x:ref> <x:ref>comment</x:ref> ] )

  <x:ref>received-protocol</x:ref> = [ <x:ref>protocol-name</x:ref> "/" ] <x:ref>protocol-version</x:ref>
                      ; see <xref target="header.upgrade"/>
  <x:ref>received-by</x:ref>       = ( <x:ref>uri-host</x:ref> [ ":" <x:ref>port</x:ref> ] ) / <x:ref>pseudonym</x:ref>
  <x:ref>pseudonym</x:ref>         = <x:ref>token</x:ref>
</artwork></figure>
<t>
   Multiple Via field values represent each proxy or gateway that has
   forwarded the message. Each intermediary appends its own information
   about how the message was received, such that the end result is ordered
   according to the sequence of forwarding recipients.
</t>
<t>
   A proxy &MUST; send an appropriate Via header field, as described below, in
   each message that it forwards.
   An HTTP-to-HTTP gateway &MUST; send an appropriate Via header field in
   each inbound request message and &MAY; send a Via header field in
   forwarded response messages.
</t>
<t>
   For each intermediary, the received-protocol indicates the protocol and
   protocol version used by the upstream sender of the message. Hence, the
   Via field value records the advertised protocol capabilities of the
   request/response chain such that they remain visible to downstream
   recipients; this can be useful for determining what backwards-incompatible
   features might be safe to use in response, or within a later request, as
   described in <xref target="http.version"/>. For brevity, the protocol-name
   is omitted when the received protocol is HTTP.
</t>
<t>
   The received-by portion of the field value is normally the host and optional
   port number of a recipient server or client that subsequently forwarded the
   message.
   However, if the real host is considered to be sensitive information, a
   sender &MAY; replace it with a pseudonym. If a port is not provided,
   a recipient &MAY; interpret that as meaning it was received on the default
   TCP port, if any, for the received-protocol.
</t>
<t>
   A sender &MAY; generate comments in the Via header field to identify the
   software of each recipient, analogous to the <x:ref>User-Agent</x:ref> and
   <x:ref>Server</x:ref> header fields. However, all comments in the Via field
   are optional, and a recipient &MAY; remove them prior to forwarding the
   message.
</t>
<t>
   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named "fred", which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which completes
   the request by forwarding it to the origin server at www.example.com.
   The request received by www.example.com would then have the following
   Via header field:
</t>
<figure><artwork type="example">
  Via: 1.0 fred, 1.1 p.example.net
</artwork></figure>
<t>
   An intermediary used as a portal through a network firewall
   &SHOULD-NOT; forward the names and ports of hosts within the firewall
   region unless it is explicitly enabled to do so. If not enabled, such an
   intermediary &SHOULD; replace each received-by host of any host behind the
   firewall by an appropriate pseudonym for that host.
</t>
<t>
   An intermediary &MAY; combine an ordered subsequence of Via header
   field entries into a single such entry if the entries have identical
   received-protocol values. For example,
</t>
<figure><artwork type="example">
  Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
</artwork></figure>
<t>
  could be collapsed to
</t>
<figure><artwork type="example">
  Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</artwork></figure>
<t>
   A sender &SHOULD-NOT; combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. A sender &MUST-NOT; combine entries that
   have different received-protocol values.
</t>
</section>

<section title="Transformations" anchor="message.transformations">
   <iref primary="true" item="transforming proxy"/>
   <iref primary="true" item="non-transforming proxy"/>
<t>
   Some intermediaries include features for transforming messages and their
   payloads. A proxy might, for example, convert between image formats in
   order to save cache space or to reduce the amount of traffic on a slow
   link. However, operational problems might occur when these transformations
   are applied to payloads intended for critical applications, such as medical
   imaging or scientific data analysis, particularly when integrity checks or
   digital signatures are used to ensure that the payload received is
   identical to the original.
</t>
<t>
   An HTTP-to-HTTP proxy is called a "<x:dfn>transforming proxy</x:dfn>"
   if it is designed or configured to modify messages in a semantically
   meaningful way (i.e., modifications, beyond those required by normal
   HTTP processing, that change the message in a way that would be
   significant to the original sender or potentially significant to
   downstream recipients).  For example, a transforming proxy might be
   acting as a shared annotation server (modifying responses to include
   references to a local annotation database), a malware filter, a
   format transcoder, or a privacy filter. Such transformations are presumed
   to be desired by whichever client (or client organization) selected the
   proxy.
</t>
<t>
   If a proxy receives a request-target with a host name that is not a
   fully qualified domain name, it &MAY; add its own domain to the host name
   it received when forwarding the request.  A proxy &MUST-NOT; change the
   host name if the request-target contains a fully qualified domain name.
</t>
<t>
   A proxy &MUST-NOT; modify the "absolute-path" and "query" parts of the
   received request-target when forwarding it to the next inbound server,
   except as noted above to replace an empty path with "/" or "*".
</t>
<t>
   A proxy &MAY; modify the message body through application
   or removal of a transfer coding (<xref target="transfer.codings"/>).
</t>
<t>
   A proxy &MUST-NOT; transform the payload (&payload;) of a message that
   contains a no-transform cache-control directive (&header-cache-control;).
</t>
<t>
   A proxy &MAY; transform the payload of a message
   that does not contain a no-transform cache-control directive.
   A proxy that transforms a payload &MUST; add a <x:ref>Warning</x:ref>
   header field with the warn-code of 214 ("Transformation Applied")
   if one is not already in the message (see &header-warning;).
   A proxy that transforms the payload of a <x:ref>200 (OK)</x:ref> response
   can further inform downstream recipients that a transformation has been
   applied by changing the response status code to
   <x:ref>203 (Non-Authoritative Information)</x:ref> (&status-203;).
</t>
<t>
   A proxy &SHOULD-NOT; modify header fields that provide information about
   the endpoints of the communication chain, the resource state, or the
   selected representation (other than the payload) unless the field's
   definition specifically allows such modification or the modification is
   deemed necessary for privacy or security.
</t>
</section>
</section>
</section>

<section title="Connection Management" anchor="connection.management">
<t>
   HTTP messaging is independent of the underlying transport- or
   session-layer connection protocol(s).  HTTP only presumes a reliable
   transport with in-order delivery of requests and the corresponding
   in-order delivery of responses.  The mapping of HTTP request and
   response structures onto the data units of an underlying transport
   protocol is outside the scope of this specification.
</t>
<t>
   As described in <xref target="connecting.inbound"/>, the specific
   connection protocols to be used for an HTTP interaction are determined by
   client configuration and the <x:ref>target URI</x:ref>.
   For example, the "http" URI scheme
   (<xref target="http.uri"/>) indicates a default connection of TCP
   over IP, with a default TCP port of 80, but the client might be
   configured to use a proxy via some other connection, port, or protocol.
</t>
<t>
   HTTP implementations are expected to engage in connection management,
   which includes maintaining the state of current connections, 
   establishing a new connection or reusing an existing connection,
   processing messages received on a connection, detecting connection
   failures, and closing each connection.
   Most clients maintain multiple connections in parallel, including
   more than one connection per server endpoint.
   Most servers are designed to maintain thousands of concurrent connections,
   while controlling request queues to enable fair use and detect
   denial-of-service attacks.
</t>

<section title="Connection" anchor="header.connection">
  <iref primary="true" item="Connection header field" x:for-anchor=""/>
  <iref primary="true" item="close" x:for-anchor=""/>
  <x:anchor-alias value="Connection"/>
  <x:anchor-alias value="connection-option"/>
  <x:anchor-alias value="close"/>
<t>
   The "Connection" header field allows the sender to indicate desired
   control options for the current connection.  In order to avoid confusing
   downstream recipients, a proxy or gateway &MUST; remove or replace any
   received connection options before forwarding the message.
</t>
<t>
   When a header field aside from Connection is used to supply control
   information for or about the current connection, the sender &MUST; list
   the corresponding field-name within the Connection header field.
   A proxy or gateway &MUST; parse a received Connection
   header field before a message is forwarded and, for each
   connection-option in this field, remove any header field(s) from
   the message with the same name as the connection-option, and then
   remove the Connection header field itself (or replace it with the
   intermediary's own connection options for the forwarded message).
</t>
<t>
   Hence, the Connection header field provides a declarative way of
   distinguishing header fields that are only intended for the
   immediate recipient ("hop-by-hop") from those fields that are
   intended for all recipients on the chain ("end-to-end"), enabling the
   message to be self-descriptive and allowing future connection-specific
   extensions to be deployed without fear that they will be blindly
   forwarded by older intermediaries.
</t>
<t>
   The Connection header field's value has the following grammar:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Connection"/><iref primary="true" item="Grammar" subitem="connection-option"/>
  <x:ref>Connection</x:ref>        = 1#<x:ref>connection-option</x:ref>
  <x:ref>connection-option</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
   Connection options are case-insensitive.
</t>
<t>
   A sender &MUST-NOT; send a connection option corresponding to a header
   field that is intended for all recipients of the payload.
   For example, <x:ref>Cache-Control</x:ref> is never appropriate as a
   connection option (&header-cache-control;).
</t>
<t>
   The connection options do not always correspond to a header field
   present in the message, since a connection-specific header field
   might not be needed if there are no parameters associated with a
   connection option. In contrast, a connection-specific header field that
   is received without a corresponding connection option usually indicates
   that the field has been improperly forwarded by an intermediary and
   ought to be ignored by the recipient.
</t>
<t>
   When defining new connection options, specification authors ought to survey
   existing header field names and ensure that the new connection option does
   not share the same name as an already deployed header field.
   Defining a new connection option essentially reserves that potential
   field-name for carrying additional information related to the
   connection option, since it would be unwise for senders to use
   that field-name for anything else.
</t>
<t>
   The "<x:dfn>close</x:dfn>" connection option is defined for a
   sender to signal that this connection will be closed after completion of
   the response. For example,
</t>
<figure><artwork type="example">
  Connection: close
</artwork></figure>
<t>
   in either the request or the response header fields indicates that the
   sender is going to close the connection after the current request/response
   is complete (<xref target="persistent.tear-down"/>).
</t>
<t>
   A client that does not support <x:ref>persistent connections</x:ref> &MUST;
   send the "close" connection option in every request message.
</t>
<t>
   A server that does not support <x:ref>persistent connections</x:ref> &MUST;
   send the "close" connection option in every response message that
   does not have a <x:ref>1xx (Informational)</x:ref> status code.
</t>
</section>

<section title="Establishment" anchor="persistent.establishment">
<t>
   It is beyond the scope of this specification to describe how connections
   are established via various transport- or session-layer protocols.
   Each connection applies to only one transport link.
</t>
</section>

<section title="Persistence" anchor="persistent.connections">
   <x:anchor-alias value="persistent connections"/>
<t>
   HTTP/1.1 defaults to the use of "<x:dfn>persistent connections</x:dfn>",
   allowing multiple requests and responses to be carried over a single
   connection. The "<x:ref>close</x:ref>" connection option is used to signal
   that a connection will not persist after the current request/response.
   HTTP implementations &SHOULD; support persistent connections.
</t>
<t>
   A recipient determines whether a connection is persistent or not based on
   the most recently received message's protocol version and
   <x:ref>Connection</x:ref> header field (if any):
   <list style="symbols">
     <t>If the "<x:ref>close</x:ref>" connection option is present, the
        connection will not persist after the current response; else,</t>
     <t>If the received protocol is HTTP/1.1 (or later), the connection will
        persist after the current response; else,</t>
     <t>If the received protocol is HTTP/1.0, the "keep-alive"
        connection option is present, the recipient is not a proxy, and
        the recipient wishes to honor the HTTP/1.0 "keep-alive" mechanism,
        the connection will persist after the current response; otherwise,</t>
     <t>The connection will close after the current response.</t>
   </list>
</t>
<t>
   A client &MAY; send additional requests on a persistent connection until it
   sends or receives a "<x:ref>close</x:ref>" connection option or receives an
   HTTP/1.0 response without a "keep-alive" connection option.
</t>
<t>
   In order to remain persistent, all messages on a connection need to
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in <xref target="message.body"/>.
   A server &MUST; read the entire request message body or close
   the connection after sending its response, since otherwise the
   remaining data on a persistent connection would be misinterpreted
   as the next request.  Likewise,
   a client &MUST; read the entire response message body if it intends
   to reuse the same connection for a subsequent request.
</t>
<t>
   A proxy server &MUST-NOT; maintain a persistent connection with an
   HTTP/1.0 client (see <xref x:sec="19.7.1" x:fmt="of" target="RFC2068"/> for
   information and discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).
</t>
<t>
   See <xref target="compatibility.with.http.1.0.persistent.connections"/>
   for more information on backwards compatibility with HTTP/1.0 clients.
</t>

<section title="Retrying Requests" anchor="persistent.retrying.requests">
<t>
   Connections can be closed at any time, with or without intention.
   Implementations ought to anticipate the need to recover
   from asynchronous close events.
</t>
<t>
   When an inbound connection is closed prematurely, a client &MAY; open a new
   connection and automatically retransmit an aborted sequence of requests if
   all of those requests have idempotent methods (&idempotent-methods;).
   A proxy &MUST-NOT; automatically retry non-idempotent requests.
</t>
<t>
   A user agent &MUST-NOT; automatically retry a request with a non-idempotent
   method unless it has some means to know that the request semantics are
   actually idempotent, regardless of the method, or some means to detect that
   the original request was never applied. For example, a user agent that
   knows (through design or configuration) that a POST request to a given
   resource is safe can repeat that request automatically.
   Likewise, a user agent designed specifically to operate on a version
   control repository might be able to recover from partial failure conditions
   by checking the target resource revision(s) after a failed connection,
   reverting or fixing any changes that were partially applied, and then
   automatically retrying the requests that failed.
</t>
<t>
   A client &SHOULD-NOT; automatically retry a failed automatic retry.
</t>
</section>

<section title="Pipelining" anchor="pipelining">
   <x:anchor-alias value="pipeline"/>
<t>
   A client that supports persistent connections &MAY; "<x:dfn>pipeline</x:dfn>"
   its requests (i.e., send multiple requests without waiting for each
   response). A server &MAY; process a sequence of pipelined requests in
   parallel if they all have safe methods (&safe-methods;), but it &MUST; send
   the corresponding responses in the same order that the requests were
   received.
</t>
<t>
   A client that pipelines requests &SHOULD; retry unanswered requests if the
   connection closes before it receives all of the corresponding responses.
   When retrying pipelined requests after a failed connection (a connection
   not explicitly closed by the server in its last complete response), a
   client &MUST-NOT; pipeline immediately after connection establishment,
   since the first remaining request in the prior pipeline might have caused
   an error response that can be lost again if multiple requests are sent on a
   prematurely closed connection (see the TCP reset problem described in
   <xref target="persistent.tear-down"/>).
</t>
<t>
   Idempotent methods (&idempotent-methods;) are significant to pipelining
   because they can be automatically retried after a connection failure.
   A user agent &SHOULD-NOT; pipeline requests after a non-idempotent method,
   until the final response status code for that method has been received,
   unless the user agent has a means to detect and recover from partial
   failure conditions involving the pipelined sequence.
</t>
<t>
   An intermediary that receives pipelined requests &MAY; pipeline those
   requests when forwarding them inbound, since it can rely on the outbound
   user agent(s) to determine what requests can be safely pipelined. If the
   inbound connection fails before receiving a response, the pipelining
   intermediary &MAY; attempt to retry a sequence of requests that have yet
   to receive a response if the requests all have idempotent methods;
   otherwise, the pipelining intermediary &SHOULD; forward any received
   responses and then close the corresponding outbound connection(s) so that
   the outbound user agent(s) can recover accordingly.
</t>
</section>
</section>
   
<section title="Concurrency" anchor="persistent.concurrency">
<t>
   A client ought to limit the number of simultaneous open
   connections that it maintains to a given server.
</t>
<t>
   Previous revisions of HTTP gave a specific number of connections as a
   ceiling, but this was found to be impractical for many applications. As a
   result, this specification does not mandate a particular maximum number of
   connections but, instead, encourages clients to be conservative when opening
   multiple connections.
</t>
<t>
   Multiple connections are typically used to avoid the "head-of-line
   blocking" problem, wherein a request that takes significant server-side
   processing and/or has a large payload blocks subsequent requests on the
   same connection. However, each connection consumes server resources.
   Furthermore, using multiple connections can cause undesirable side effects
   in congested networks. 
</t>
<t>
   Note that a server might reject traffic that it deems abusive or
   characteristic of a denial-of-service attack, such as an excessive number
   of open connections from a single client.
</t>
</section>

<section title="Failures and Timeouts" anchor="persistent.failures">
<t>
   Servers will usually have some timeout value beyond which they will
   no longer maintain an inactive connection. Proxy servers might make
   this a higher value since it is likely that the client will be making
   more connections through the same proxy server. The use of persistent
   connections places no requirements on the length (or existence) of
   this timeout for either the client or the server.
</t>
<t>
   A client or server that wishes to time out &SHOULD; issue a graceful close
   on the connection. Implementations &SHOULD; constantly monitor open
   connections for a received closure signal and respond to it as appropriate,
   since prompt closure of both sides of a connection enables allocated system
   resources to be reclaimed.
</t>
<t>
   A client, server, or proxy &MAY; close the transport connection at any
   time. For example, a client might have started to send a new request
   at the same time that the server has decided to close the "idle"
   connection. From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.
</t>
<t>
   A server &SHOULD; sustain persistent connections, when possible, and allow
   the underlying transport's flow-control mechanisms to resolve temporary overloads, rather
   than terminate connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.
</t>
<t>
   A client sending a message body &SHOULD; monitor
   the network connection for an error response while it is transmitting
   the request. If the client sees a response that indicates the server does
   not wish to receive the message body and is closing the connection, the
   client &SHOULD; immediately cease transmitting the body and close its side
   of the connection.
</t>
</section>
   
<section title="Tear-down" anchor="persistent.tear-down">
  <iref primary="false" item="Connection header field" x:for-anchor=""/>
  <iref primary="false" item="close" x:for-anchor=""/>
<t>
   The <x:ref>Connection</x:ref> header field
   (<xref target="header.connection"/>) provides a "<x:ref>close</x:ref>"
   connection option that a sender &SHOULD; send when it wishes to close
   the connection after the current request/response pair.
</t>
<t>
   A client that sends a "<x:ref>close</x:ref>" connection option &MUST-NOT;
   send further requests on that connection (after the one containing
   "close") and &MUST; close the connection after reading the
   final response message corresponding to this request.
</t>
<t>
   A server that receives a "<x:ref>close</x:ref>" connection option &MUST;
   initiate a close of the connection (see below) after it sends the
   final response to the request that contained "close".
   The server &SHOULD; send a "close" connection option
   in its final response on that connection. The server &MUST-NOT; process
   any further requests received on that connection.
</t>
<t>
   A server that sends a "<x:ref>close</x:ref>" connection option &MUST;
   initiate a close of the connection (see below) after it sends the
   response containing "close". The server &MUST-NOT; process
   any further requests received on that connection.
</t>
<t>
   A client that receives a "<x:ref>close</x:ref>" connection option &MUST;
   cease sending requests on that connection and close the connection
   after reading the response message containing the "close"; if additional
   pipelined requests had been sent on the connection, the client &SHOULD-NOT;
   assume that they will be processed by the server.
</t>
<t>
   If a server performs an immediate close of a TCP connection, there is a
   significant risk that the client will not be able to read the last HTTP
   response.  If the server receives additional data from the client on a
   fully closed connection, such as another request that was sent by the
   client before receiving the server's response, the server's TCP stack will
   send a reset packet to the client; unfortunately, the reset packet might
   erase the client's unacknowledged input buffers before they can be read
   and interpreted by the client's HTTP parser.
</t>
<t>
   To avoid the TCP reset problem, servers typically close a connection in
   stages. First, the server performs a half-close by closing only the write
   side of the read/write connection. The server then continues to read from
   the connection until it receives a corresponding close by the client, or
   until the server is reasonably certain that its own TCP stack has received
   the client's acknowledgement of the packet(s) containing the server's last
   response. Finally, the server fully closes the connection.
</t>
<t>
   It is unknown whether the reset problem is exclusive to TCP or might also
   be found in other transport connection protocols.
</t>
</section>

<section title="Upgrade" anchor="header.upgrade">
  <iref primary="true" item="Upgrade header field" x:for-anchor=""/>
  <x:anchor-alias value="Upgrade"/>
  <x:anchor-alias value="protocol"/>
  <x:anchor-alias value="protocol-name"/>
  <x:anchor-alias value="protocol-version"/>
<t>
   The "Upgrade" header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.  A client &MAY; send a list of protocols in the Upgrade
   header field of a request to invite the server to switch to one or
   more of those protocols, in order of descending preference, before sending
   the final response. A server &MAY; ignore a received Upgrade header field
   if it wishes to continue using the current protocol on that connection.
   Upgrade cannot be used to insist on a protocol change.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Upgrade"/>
  <x:ref>Upgrade</x:ref>          = 1#<x:ref>protocol</x:ref>

  <x:ref>protocol</x:ref>         = <x:ref>protocol-name</x:ref> ["/" <x:ref>protocol-version</x:ref>]
  <x:ref>protocol-name</x:ref>    = <x:ref>token</x:ref>
  <x:ref>protocol-version</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
   A server that sends a <x:ref>101 (Switching Protocols)</x:ref> response
   &MUST; send an Upgrade header field to indicate the new protocol(s) to
   which the connection is being switched; if multiple protocol layers are
   being switched, the sender &MUST; list the protocols in layer-ascending
   order. A server &MUST-NOT; switch to a protocol that was not indicated by
   the client in the corresponding request's Upgrade header field.
   A server &MAY; choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as the
   nature of the request or the current load on the server.
</t>
<t>
   A server that sends a <x:ref>426 (Upgrade Required)</x:ref> response
   &MUST; send an Upgrade header field to indicate the acceptable protocols,
   in order of descending preference.
</t>
<t>
   A server &MAY; send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed protocols,
   in order of descending preference, when appropriate for a future request.
</t>
<figure><preamble>
   The following is a hypothetical example sent by a client:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /hello.txt HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

</artwork></figure>
<t>
   The capabilities and nature of the
   application-level communication after the protocol change is entirely
   dependent upon the new protocol(s) chosen. However, immediately after
   sending the <x:ref>101 (Switching Protocols)</x:ref> response, the server is expected to continue responding to
   the original request as if it had received its equivalent within the new
   protocol (i.e., the server still has an outstanding request to satisfy
   after the protocol has been changed, and is expected to do so without
   requiring the request to be repeated).
</t>
<t>
   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds
   with a <x:ref>101 (Switching Protocols)</x:ref> message in HTTP/1.1 and
   then immediately follows that with the new protocol's equivalent of a
   response to a GET on the target resource.  This allows a connection to be
   upgraded to protocols with the same semantics as HTTP without the
   latency cost of an additional round trip.  A server &MUST-NOT; switch
   protocols unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol.
</t>
<figure><preamble>
   The following is an example response to the above hypothetical request:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: HTTP/2.0

[... data stream switches to HTTP/2.0 with an appropriate response
(as defined by new protocol) to the "GET /hello.txt" request ...]
</artwork></figure>
<t>
   When Upgrade is sent, the sender &MUST; also send a 
   <x:ref>Connection</x:ref> header field (<xref target="header.connection"/>)
   that contains an "upgrade" connection option, in order to prevent Upgrade
   from being accidentally forwarded by intermediaries that might not implement
   the listed protocols.  A server &MUST; ignore an Upgrade header field that
   is received in an HTTP/1.0 request.
</t>
<t>
   A client cannot begin using an upgraded protocol on the connection until
   it has completely sent the request message (i.e., the client can't change
   the protocol it is sending in the middle of a message).
   If a server receives both an Upgrade and an <x:ref>Expect</x:ref> header field
   with the "100-continue" expectation (&header-expect;), the
   server &MUST; send a <x:ref>100 (Continue)</x:ref> response before sending
   a <x:ref>101 (Switching Protocols)</x:ref> response.
</t>
<t>
   The Upgrade header field only applies to switching protocols on top of the
   existing connection; it cannot be used to switch the underlying connection
   (transport) protocol, nor to switch the existing communication to a
   different connection. For those purposes, it is more appropriate to use a
   <x:ref>3xx (Redirection)</x:ref> response (&status-3xx;).
</t>
<t>
   This specification only defines the protocol name "HTTP" for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of <xref target="http.version"/> and future updates to this
   specification. Additional tokens ought to be registered with IANA using the
   registration procedure defined in <xref target="upgrade.token.registry"/>.
</t>
</section>
</section>

<section title="ABNF List Extension: #rule" anchor="abnf.extension">
<t>
   A #rule extension to the ABNF rules of <xref target="RFC5234"/> is used to
   improve readability in the definitions of some header field values.
</t>
<t>
   A construct "#" is defined, similar to "*", for defining comma-delimited
   lists of elements. The full form is "&lt;n&gt;#&lt;m&gt;element" indicating
   at least &lt;n&gt; and at most &lt;m&gt; elements, each separated by a single
   comma (",") and optional whitespace (OWS).   
</t>
<figure><preamble>
   In any production that uses the list construct, a sender &MUST-NOT;
   generate empty list elements. In other words, a sender &MUST; generate
   lists that satisfy the following syntax:
</preamble><artwork type="example">
  1#element =&gt; element *( OWS "," OWS element )
</artwork></figure>
<figure><preamble>
   and:
</preamble><artwork type="example">
  #element =&gt; [ 1#element ]
</artwork></figure>
<figure><preamble>
   and for n &gt;= 1 and m &gt; 1:
</preamble><artwork type="example">
  &lt;n&gt;#&lt;m&gt;element =&gt; element &lt;n-1&gt;*&lt;m-1&gt;( OWS "," OWS element )
</artwork></figure>
<t>
   For compatibility with legacy list rules, a recipient &MUST; parse and ignore
   a reasonable number of empty list elements: enough to handle common mistakes
   by senders that merge values, but not so much that they could be used as a
   denial-of-service mechanism. In other words, a recipient &MUST; accept lists
   that satisfy the following syntax:
</t>
<figure><artwork type="example">
  #element =&gt; [ ( "," / element ) *( OWS "," [ OWS element ] ) ]
  
  1#element =&gt; *( "," OWS ) element *( OWS "," [ OWS element ] )
</artwork></figure>
<t>
   Empty elements do not contribute to the count of elements present.
   For example, given these ABNF productions: 
</t>
<figure><artwork type="example">
  example-list      = 1#example-list-elmt
  example-list-elmt = token ; see <xref target="field.components"/> 
</artwork></figure>
<t>
   Then the following are valid values for example-list (not including the
   double quotes, which are present for delimitation only):
</t>
<figure><artwork type="example">
  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie   "
</artwork></figure>
<t>
   In contrast, the following values would be invalid, since at least one
   non-empty element is required by the example-list production:
</t>
<figure><artwork type="example">
  ""
  ","
  ",   ,"
</artwork></figure>
<t>
   <xref target="collected.abnf"/> shows the collected ABNF for recipients
   after the list constructs have been expanded.
</t>
</section>

<section title="IANA Considerations" anchor="IANA.considerations">

<section title="Header Field Registration" anchor="header.field.registration">
<t>
   HTTP header fields are registered within the "Message Headers" registry
   maintained at
   <eref target="http://www.iana.org/assignments/message-headers/"/>.
</t>
<t>
   This document defines the following HTTP header fields, so the
   "Permanent Message Header Field Names" registry has been updated
   accordingly (see <xref target="BCP90"/>).
</t>
<?BEGININC p1-messaging.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Connection</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.connection"/>
   </c>
   <c>Content-Length</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-length"/>
   </c>
   <c>Host</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.host"/>
   </c>
   <c>TE</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.te"/>
   </c>
   <c>Trailer</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.trailer"/>
   </c>
   <c>Transfer-Encoding</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.transfer-encoding"/>
   </c>
   <c>Upgrade</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.upgrade"/>
   </c>
   <c>Via</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.via"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p1-messaging.iana-headers ?>
<t>
   Furthermore, the header field-name "Close" has been registered as
   "reserved", since using that name as an HTTP header field might
   conflict with the "close" connection option of the <x:ref>Connection</x:ref>
   header field (<xref target="header.connection"/>).
</t>
<texttable align="left" suppress-title="true">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Close</c>
   <c>http</c>
   <c>reserved</c>
   <c>
      <xref target="header.field.registration"/>
   </c>
</texttable>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>

<section title="URI Scheme Registration" anchor="uri.scheme.registration">
<t>
   IANA maintains the registry of URI Schemes <xref target="BCP115"/> at
   <eref target="http://www.iana.org/assignments/uri-schemes/"/>.
</t>
<t>
   This document defines the following URI schemes, so the "Permanent URI
   Schemes" registry has been updated accordingly.
</t>
<texttable align="left" suppress-title="true">
   <ttcol>URI Scheme</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>

   <c>http</c>
   <c>Hypertext Transfer Protocol</c>
   <c><xref target="http.uri"/></c>

   <c>https</c>
   <c>Hypertext Transfer Protocol Secure</c>
   <c><xref target="https.uri"/></c>
</texttable>
</section>

<section title="Internet Media Type Registration" anchor="internet.media.type.http">
<t>
   IANA maintains the registry of Internet media types <xref target="BCP13"/> at
   <eref target="http://www.iana.org/assignments/media-types"/>.
</t>
<t>
   This document serves as the specification for the Internet media types
   "message/http" and "application/http". The following has been registered with
   IANA.
</t>
<section title="Internet Media Type message/http" anchor="internet.media.type.message.http">
<iref item="Media Type" subitem="message/http" primary="true"/>
<iref item="message/http Media Type" primary="true"/>
<t>
   The message/http type can be used to enclose a single HTTP request or
   response message, provided that it obeys the MIME restrictions for all
   "message" types regarding line length and encodings.
</t>
<t>
  <list style="hanging" x:indent="12em">
    <t hangText="Type name:">
      message
    </t>
    <t hangText="Subtype name:">
      http
    </t>
    <t hangText="Required parameters:">
      N/A
    </t>
    <t hangText="Optional parameters:">
      version, msgtype
      <list style="hanging">
        <t hangText="version:">
          The HTTP-version number of the enclosed message
          (e.g., "1.1"). If not present, the version can be
          determined from the first line of the body.
        </t>
        <t hangText="msgtype:">
          The message type &mdash; "request" or "response". If not
          present, the type can be determined from the first
          line of the body.
        </t>
      </list>
    </t>
    <t hangText="Encoding considerations:">
      only "7bit", "8bit", or "binary" are permitted
    </t>
    <t hangText="Security considerations:">
      see <xref target="security.considerations"/>
    </t>
    <t hangText="Interoperability considerations:">
      N/A
    </t>
    <t hangText="Published specification:">
      This specification (see <xref target="internet.media.type.message.http"/>).
    </t>
    <t hangText="Applications that use this media type:">
      N/A
    </t>
    <t hangText="Fragment identifier considerations:">
      N/A
    </t>
    <t hangText="Additional information:">
      <list style="hanging">
        <t hangText="Magic number(s):">N/A</t>
        <t hangText="Deprecated alias names for this type:">N/A</t>
        <t hangText="File extension(s):">N/A</t>
        <t hangText="Macintosh file type code(s):">N/A</t>
      </list>
    </t>
    <t hangText="Person and email address to contact for further information:">
      See&nbsp;Authors'&nbsp;Addresses section.
    </t>
    <t hangText="Intended usage:">
      COMMON
    </t>
    <t hangText="Restrictions on usage:">
      N/A
    </t>
    <t hangText="Author:">
      See Authors' Addresses section.
    </t>
    <t hangText="Change controller:">
      IESG
    </t>
  </list>
</t>
</section>
<section title="Internet Media Type application/http" anchor="internet.media.type.application.http">
<iref item="Media Type" subitem="application/http" primary="true"/>
<iref item="application/http Media Type" primary="true"/>
<t>
   The application/http type can be used to enclose a pipeline of one or more
   HTTP request or response messages (not intermixed).
</t>
<t>
  <list style="hanging" x:indent="12em">
    <t hangText="Type name:">
      application
    </t>
    <t hangText="Subtype name:">
      http
    </t>
    <t hangText="Required parameters:">
      N/A
    </t>
    <t hangText="Optional parameters:">
      version, msgtype
      <list style="hanging">
        <t hangText="version:">
          The HTTP-version number of the enclosed messages
          (e.g., "1.1"). If not present, the version can be
          determined from the first line of the body.
        </t>
        <t hangText="msgtype:">
          The message type &mdash; "request" or "response". If not
          present, the type can be determined from the first
          line of the body.
        </t>
      </list>
    </t>
    <t hangText="Encoding considerations:">
      HTTP messages enclosed by this type
      are in "binary" format; use of an appropriate
      Content-Transfer-Encoding is required when
      transmitted via email.
    </t>
    <t hangText="Security considerations:">
      see <xref target="security.considerations"/>
    </t>
    <t hangText="Interoperability considerations:">
      N/A
    </t>
    <t hangText="Published specification:">
      This specification (see <xref target="internet.media.type.application.http"/>).
    </t>
    <t hangText="Applications that use this media type:">
      N/A
    </t>
    <t hangText="Fragment identifier considerations:">
      N/A
    </t>
    <t hangText="Additional information:">
      <list style="hanging">
        <t hangText="Deprecated alias names for this type:">N/A</t>
        <t hangText="Magic number(s):">N/A</t>
        <t hangText="File extension(s):">N/A</t>
        <t hangText="Macintosh file type code(s):">N/A</t>
      </list>
    </t>
    <t hangText="Person and email address to contact for further information:">
      See&nbsp;Authors'&nbsp;Addresses section.
    </t>
    <t hangText="Intended usage:">
      COMMON
    </t>
    <t hangText="Restrictions on usage:">
      N/A
    </t>
    <t hangText="Author:">
      See Authors' Addresses section.
    </t>
    <t hangText="Change controller:">
      IESG
    </t>
  </list>
</t>
</section>
</section>

<section title="Transfer Coding Registry" anchor="transfer.coding.registry">
<t>
   The "HTTP Transfer Coding Registry" defines the namespace for transfer
   coding names. It is maintained at <eref target="http://www.iana.org/assignments/http-parameters"/>.
</t>

<section title="Procedure" anchor="transfer.coding.registry.procedure">
<t>
   Registrations &MUST; include the following fields:
   <list style="symbols">
     <t>Name</t>
     <t>Description</t>
     <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Names of transfer codings &MUST-NOT; overlap with names of content codings
   (&content-codings;) unless the encoding transformation is identical, as
   is the case for the compression codings defined in
   <xref target="compression.codings"/>.
</t>
<t>
   Values to be added to this namespace require IETF Review (see
   <xref target="RFC5226" x:fmt="of" x:sec="4.1"/>), and &MUST;
   conform to the purpose of transfer coding defined in this specification.
</t>
<t>
   Use of program names for the identification of encoding formats
   is not desirable and is discouraged for future encodings.
</t>
</section>

<section title="Registration" anchor="transfer.coding.registration">
<t>
   The "HTTP Transfer Coding Registry" has been updated with the registrations
   below:
</t>
<texttable align="left" suppress-title="true" anchor="iana.transfer.coding.registration.table">
   <ttcol>Name</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>chunked</c>
   <c>Transfer in a series of chunks</c>
   <c>
      <xref target="chunked.encoding"/>
   </c>
   <c>compress</c>
   <c>UNIX "compress" data format <xref target="Welch"/></c>
   <c>
      <xref target="compress.coding"/>
   </c>
   <c>deflate</c>
   <c>"deflate" compressed data (<xref target="RFC1951"/>) inside
   the "zlib" data format (<xref target="RFC1950"/>)
   </c>
   <c>
      <xref target="deflate.coding"/>
   </c>
   <c>gzip</c>
   <c>GZIP file format <xref target="RFC1952"/></c>
   <c>
      <xref target="gzip.coding"/>
   </c>
   <c>x-compress</c>
   <c>Deprecated (alias for compress)</c>
   <c>
      <xref target="compress.coding"/>
   </c>
   <c>x-gzip</c>
   <c>Deprecated (alias for gzip)</c>
   <c>
      <xref target="gzip.coding"/>
   </c>
</texttable>
</section>
</section>

<section title="Content Coding Registration" anchor="content.coding.registration">
<t>
   IANA maintains the "HTTP Content Coding Registry" at
   <eref target="http://www.iana.org/assignments/http-parameters"/>.
</t>
<t>
   The "HTTP Content Coding Registry" has been updated with the registrations
   below:
</t>
<texttable align="left" suppress-title="true" anchor="iana.content.coding.registration.table">
   <ttcol>Name</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>compress</c>
   <c>UNIX "compress" data format <xref target="Welch"/></c>
   <c>
      <xref target="compress.coding"/>
   </c>
   <c>deflate</c>
   <c>"deflate" compressed data (<xref target="RFC1951"/>) inside
   the "zlib" data format (<xref target="RFC1950"/>)</c>
   <c>
      <xref target="deflate.coding"/>
   </c>
   <c>gzip</c>
   <c>GZIP file format <xref target="RFC1952"/></c>
   <c>
      <xref target="gzip.coding"/>
   </c>
   <c>x-compress</c>
   <c>Deprecated (alias for compress)</c>
   <c>
      <xref target="compress.coding"/>
   </c>
   <c>x-gzip</c>
   <c>Deprecated (alias for gzip)</c>
   <c>
      <xref target="gzip.coding"/>
   </c>
</texttable>
</section>

<section title="Upgrade Token Registry" anchor="upgrade.token.registry">
<t>
   The "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" defines the namespace for protocol-name
   tokens used to identify protocols in the <x:ref>Upgrade</x:ref> header
   field. The registry is maintained at <eref target="http://www.iana.org/assignments/http-upgrade-tokens"/>.
</t>

<section title="Procedure" anchor="upgrade.token.registry.procedure">   
<t>
   Each registered protocol name is associated with contact information
   and an optional set of specifications that details how the connection
   will be processed after it has been upgraded.
</t>
<t>
   Registrations happen on a "First Come First Served" basis (see
   <xref target="RFC5226" x:sec="4.1" x:fmt="of"/>) and are subject to the
   following rules:
  <list style="numbers">
    <t>A protocol-name token, once registered, stays registered forever.</t>
    <t>The registration &MUST; name a responsible party for the
       registration.</t>
    <t>The registration &MUST; name a point of contact.</t>
    <t>The registration &MAY; name a set of specifications associated with
       that token. Such specifications need not be publicly available.</t>
    <t>The registration &SHOULD; name a set of expected "protocol-version"
       tokens associated with that token at the time of registration.</t>
    <t>The responsible party &MAY; change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.</t>
    <t>The IESG &MAY; reassign responsibility for a protocol token.
       This will normally only be used in the case when a
       responsible party cannot be contacted.</t>
  </list>
</t>
<t>
   This registration procedure for HTTP Upgrade Tokens replaces that
   previously defined in <xref target="RFC2817" x:fmt="of" x:sec="7.2"/>.
</t>
</section>

<section title="Upgrade Token Registration" anchor="upgrade.token.registration">
<t>
   The "HTTP" entry in the upgrade token registry has been updated with
   the registration below:
</t>
<texttable align="left" suppress-title="true">
   <ttcol>Value</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Expected Version Tokens</ttcol>
   <ttcol>Reference</ttcol>

   <c>HTTP</c>
   <c>Hypertext Transfer Protocol</c>
   <c>any DIGIT.DIGIT (e.g, "2.0")</c>
   <c><xref target="http.version"/></c>
</texttable>
<t>
   The responsible party is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>
</section>

</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   This section is meant to inform developers, information providers, and
   users of known security considerations relevant to HTTP message syntax,
   parsing, and routing. Security considerations about HTTP semantics and
   payloads are addressed in &semantics;.
</t>

<section title="Establishing Authority" anchor="establishing.authority">
  <iref item="authoritative response" primary="true"/>
  <iref item="phishing" primary="true"/>
<t>
   HTTP relies on the notion of an <x:dfn>authoritative response</x:dfn>: a
   response that has been determined by (or at the direction of) the authority
   identified within the target URI to be the most appropriate response for
   that request given the state of the target resource at the time of
   response message origination. Providing a response from a non-authoritative
   source, such as a shared cache, is often useful to improve performance and
   availability, but only to the extent that the source can be trusted or
   the distrusted response can be safely used.
</t>
<t>
   Unfortunately, establishing authority can be difficult.
   For example, <x:dfn>phishing</x:dfn> is an attack on the user's perception
   of authority, where that perception can be misled by presenting similar
   branding in hypertext, possibly aided by userinfo obfuscating the authority
   component (see <xref target="http.uri"/>).
   User agents can reduce the impact of phishing attacks by enabling users to
   easily inspect a target URI prior to making an action, by prominently
   distinguishing (or rejecting) userinfo when present, and by not sending
   stored credentials and cookies when the referring document is from an
   unknown or untrusted source.
</t>
<t>
   When a registered name is used in the authority component, the "http" URI
   scheme (<xref target="http.uri"/>) relies on the user's local name
   resolution service to determine where it can find authoritative responses.
   This means that any attack on a user's network host table, cached names, or
   name resolution libraries becomes an avenue for attack on establishing
   authority. Likewise, the user's choice of server for Domain Name Service
   (DNS), and the hierarchy of servers from which it obtains resolution
   results, could impact the authenticity of address mappings;
   DNS Security Extensions (DNSSEC, <xref target="RFC4033"/>) are one way to
   improve authenticity.
</t>
<t>
   Furthermore, after an IP address is obtained, establishing authority for
   an "http" URI is vulnerable to attacks on Internet Protocol routing.
</t>
<t>
   The "https" scheme (<xref target="https.uri"/>) is intended to prevent
   (or at least reveal) many of these potential attacks on establishing
   authority, provided that the negotiated TLS connection is secured and
   the client properly verifies that the communicating server's identity
   matches the target URI's authority component
   (see <xref target="RFC2818"/>). Correctly implementing such verification
   can be difficult (see <xref target="Georgiev"/>).
</t>
</section>

<section title="Risks of Intermediaries" anchor="risks.intermediaries">
<t>
   By their very nature, HTTP intermediaries are men-in-the-middle and, thus,
   represent an opportunity for man-in-the-middle attacks. Compromise of
   the systems on which the intermediaries run can result in serious security
   and privacy problems. Intermediaries might have access to security-related
   information, personal information about individual users and
   organizations, and proprietary information belonging to users and
   content providers. A compromised intermediary, or an intermediary
   implemented or configured without regard to security and privacy
   considerations, might be used in the commission of a wide range of
   potential attacks.
</t>
<t>
   Intermediaries that contain a shared cache are especially vulnerable
   to cache poisoning attacks, as described in &cache-poisoning;.
</t>
<t>
   Implementers need to consider the privacy and security
   implications of their design and coding decisions, and of the
   configuration options they provide to operators (especially the
   default configuration).
</t>
<t>
   Users need to be aware that intermediaries are no more trustworthy than
   the people who run them; HTTP itself cannot solve this problem.
</t>
</section>

<section title="Attacks via Protocol Element Length" anchor="attack.protocol.element.length">
<t>
   Because HTTP uses mostly textual, character-delimited fields, parsers are
   often vulnerable to attacks based on sending very long (or very slow)
   streams of data, particularly where an implementation is expecting a
   protocol element with no predefined length.
</t>
<t>
   To promote interoperability, specific recommendations are made for minimum
   size limits on request-line (<xref target="request.line"/>)
   and header fields (<xref target="header.fields"/>). These are
   minimum recommendations, chosen to be supportable even by implementations
   with limited resources; it is expected that most implementations will
   choose substantially higher limits.
</t>
<t>
   A server can reject a message that
   has a request-target that is too long (&status-414;) or a request payload
   that is too large (&status-413;). Additional status codes related to
   capacity limits have been defined by extensions to HTTP
   <xref target="RFC6585"/>.
</t>
<t>
   Recipients ought to carefully limit the extent to which they process other
   protocol elements, including (but not limited to) request methods, response
   status phrases, header field-names, numeric values, and body chunks.
   Failure to limit such processing can result in buffer overflows, arithmetic
   overflows, or increased vulnerability to denial-of-service attacks.
</t>
</section>

<section title="Response Splitting" anchor="response.splitting">
<t>
   Response splitting (a.k.a, CRLF injection) is a common technique, used in
   various attacks on Web usage, that exploits the line-based nature of HTTP
   message framing and the ordered association of requests to responses on
   persistent connections <xref target="Klein"/>. This technique can be
   particularly damaging when the requests pass through a shared cache.
</t>
<t>
   Response splitting exploits a vulnerability in servers (usually within an
   application server) where an attacker can send encoded data within some
   parameter of the request that is later decoded and echoed within any of the
   response header fields of the response. If the decoded data is crafted to
   look like the response has ended and a subsequent response has begun, the
   response has been split and the content within the apparent second response
   is controlled by the attacker. The attacker can then make any other request
   on the same persistent connection and trick the recipients (including
   intermediaries) into believing that the second half of the split is an
   authoritative answer to the second request.
</t>
<t>
   For example, a parameter within the request-target might be read by an
   application server and reused within a redirect, resulting in the same
   parameter being echoed in the <x:ref>Location</x:ref> header field of the
   response. If the parameter is decoded by the application and not properly
   encoded when placed in the response field, the attacker can send encoded
   CRLF octets and other content that will make the application's single
   response look like two or more responses. 
</t>
<t>
   A common defense against response splitting is to filter requests for data
   that looks like encoded CR and LF (e.g., "%0D" and "%0A"). However, that
   assumes the application server is only performing URI decoding, rather
   than more obscure data transformations like charset transcoding, XML entity
   translation, base64 decoding, sprintf reformatting, etc.  A more effective
   mitigation is to prevent anything other than the server's core protocol
   libraries from sending a CR or LF within the header section, which means
   restricting the output of header fields to APIs that filter for bad octets
   and not allowing application servers to write directly to the protocol
   stream.
</t>
</section>

<section title="Request Smuggling" anchor="request.smuggling">
<t>
   Request smuggling (<xref target="Linhart"/>) is a technique that exploits
   differences in protocol parsing among various recipients to hide additional
   requests (which might otherwise be blocked or disabled by policy) within an
   apparently harmless request.  Like response splitting, request smuggling
   can lead to a variety of attacks on HTTP usage.
</t>
<t>
   This specification has introduced new requirements on request parsing,
   particularly with regard to message framing in
   <xref target="message.body.length"/>, to reduce the effectiveness of
   request smuggling.
</t>
</section>

<section title="Message Integrity" anchor="message.integrity">
<t>
   HTTP does not define a specific mechanism for ensuring message integrity,
   instead relying on the error-detection ability of underlying transport
   protocols and the use of length or chunk-delimited framing to detect
   completeness. Additional integrity mechanisms, such as hash functions or
   digital signatures applied to the content, can be selectively added to
   messages via extensible metadata header fields. Historically, the lack of
   a single integrity mechanism has been justified by the informal nature of
   most HTTP communication.  However, the prevalence of HTTP as an information
   access mechanism has resulted in its increasing use within environments
   where verification of message integrity is crucial.
</t>
<t>
   User agents are encouraged to implement configurable means for detecting
   and reporting failures of message integrity such that those means can be
   enabled within environments for which integrity is necessary. For example,
   a browser being used to view medical history or drug interaction
   information needs to indicate to the user when such information is detected
   by the protocol to be incomplete, expired, or corrupted during transfer.
   Such mechanisms might be selectively enabled via user agent extensions or
   the presence of message integrity metadata in a response.
   At a minimum, user agents ought to provide some indication that allows a
   user to distinguish between a complete and incomplete response message
   (<xref target="incomplete.messages"/>) when such verification is desired.
</t>
</section>

<section title="Message Confidentiality" anchor="message.confidentiality">
<t>
   HTTP relies on underlying transport protocols to provide message
   confidentiality when that is desired. HTTP has been specifically designed
   to be independent of the transport protocol, such that it can be used
   over many different forms of encrypted connection, with the selection of
   such transports being identified by the choice of URI scheme or within
   user agent configuration.
</t>
<t>
   The "https" scheme can be used to identify resources that require a
   confidential connection, as described in <xref target="https.uri"/>.
</t>
</section>

<section title="Privacy of Server Log Information" anchor="privacy.of.server.log.information">
<t>
   A server is in the position to save personal data about a user's requests
   over time, which might identify their reading patterns or subjects of
   interest.  In particular, log information gathered at an intermediary
   often contains a history of user agent interaction, across a multitude
   of sites, that can be traced to individual users.
</t>
<t>
   HTTP log information is confidential in nature; its handling is often
   constrained by laws and regulations.  Log information needs to be securely
   stored and appropriate guidelines followed for its analysis.
   Anonymization of personal information within individual entries helps,
   but it is generally not sufficient to prevent real log traces from being
   re-identified based on correlation with other access characteristics.
   As such, access traces that are keyed to a specific client are unsafe to
   publish even if the key is pseudonymous.
</t>
<t>
   To minimize the risk of theft or accidental publication, log information
   ought to be purged of personally identifiable information, including
   user identifiers, IP addresses, and user-provided query parameters,
   as soon as that information is no longer necessary to support operational
   needs for security, auditing, or fraud control.
</t>
</section>
</section>

<section title="Acknowledgments" anchor="acks">
<t>
   This edition of HTTP/1.1 builds on the many contributions that went into
   <xref target="RFC1945" format="none">RFC 1945</xref>,
   <xref target="RFC2068" format="none">RFC 2068</xref>,
   <xref target="RFC2145" format="none">RFC 2145</xref>, and
   <xref target="RFC2616" format="none">RFC 2616</xref>, including 
   substantial contributions made by the previous authors, editors, and
   Working Group Chairs: Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,
   Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter,
   and Paul J. Leach. Mark Nottingham oversaw this effort as Working Group Chair. 
</t>
<t>
   Since 1999, the following contributors have helped improve the HTTP
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating open issues:
</t>
<?BEGININC acks ?>
<t>Adam Barth,
Adam Roach,
Addison Phillips,
Adrian Chadd,
Adrian Cole,
Adrien W. de Croy,
Alan Ford,
Alan Ruttenberg,
Albert Lunde,
Alek Storm,
Alex Rousskov,
Alexandre Morgaut,
Alexey Melnikov,
Alisha Smith,
Amichai Rothman,
Amit Klein,
Amos Jeffries,
Andreas Maier,
Andreas Petersson,
Andrei Popov,
Anil Sharma,
Anne van Kesteren,
Anthony Bryan,
Asbjorn Ulsberg,
Ashok Kumar,
Balachander Krishnamurthy,
Barry Leiba,
Ben Laurie,
Benjamin Carlyle,
Benjamin Niven-Jenkins,
Benoit Claise,
Bil Corry,
Bill Burke,
Bjoern Hoehrmann,
Bob Scheifler,
Boris Zbarsky,
Brett Slatkin,
Brian Kell,
Brian McBarron,
Brian Pane,
Brian Raymor,
Brian Smith,
Bruce Perens,
Bryce Nesbitt,
Cameron Heavon-Jones,
Carl Kugler,
Carsten Bormann,
Charles Fry,
Chris Burdess,
Chris Newman,
Christian Huitema,
Cyrus Daboo,
Dale Robert Anderson,
Dan Wing,
Dan Winship,
Daniel Stenberg,
Darrel Miller,
Dave Cridland,
Dave Crocker,
Dave Kristol,
Dave Thaler,
David Booth,
David Singer,
David W. Morris,
Diwakar Shetty,
Dmitry Kurochkin,
Drummond Reed,
Duane Wessels,
Edward Lee,
Eitan Adler,
Eliot Lear,
Emile Stephan,
Eran Hammer-Lahav,
Eric D. Williams,
Eric J. Bowman,
Eric Lawrence,
Eric Rescorla,
Erik Aronesty,
EungJun Yi,
Evan Prodromou,
Felix Geisendoerfer,
Florian Weimer,
Frank Ellermann,
Fred Akalin,
Fred Bohle,
Frederic Kayser,
Gabor Molnar,
Gabriel Montenegro,
Geoffrey Sneddon,
Gervase Markham,
Gili Tzabari,
Grahame Grieve,
Greg Slepak,
Greg Wilkins,
Grzegorz Calkowski,
Harald Tveit Alvestrand,
Harry Halpin,
Helge Hess,
Henrik Nordstrom,
Henry S. Thompson,
Henry Story,
Herbert van de Sompel,
Herve Ruellan,
Howard Melman,
Hugo Haas,
Ian Fette,
Ian Hickson,
Ido Safruti,
Ilari Liusvaara,
Ilya Grigorik,
Ingo Struck,
J. Ross Nicoll,
James Cloos,
James H. Manger,
James Lacey,
James M. Snell,
Jamie Lokier,
Jan Algermissen,
Jari Arkko,
Jeff Hodges (who came up with the term 'effective Request-URI'),
Jeff Pinner,
Jeff Walden,
Jim Luther,
Jitu Padhye,
Joe D. Williams,
Joe Gregorio,
Joe Orton,
Joel Jaeggli,
John C. Klensin,
John C. Mallery,
John Cowan,
John Kemp,
John Panzer,
John Schneider,
John Stracke,
John Sullivan,
Jonas Sicking,
Jonathan A. Rees,
Jonathan Billington,
Jonathan Moore,
Jonathan Silvera,
Jordi Ros,
Joris Dobbelsteen,
Josh Cohen,
Julien Pierre,
Jungshik Shin,
Justin Chapweske,
Justin Erenkrantz,
Justin James,
Kalvinder Singh,
Karl Dubost,
Kathleen Moriarty,
Keith Hoffman,
Keith Moore,
Ken Murchison,
Koen Holtman,
Konstantin Voronkov,
Kris Zyp,
Leif Hedstrom,
Lionel Morand,
Lisa Dusseault,
Maciej Stachowiak,
Manu Sporny,
Marc Schneider,
Marc Slemko,
Mark Baker,
Mark Pauley,
Mark Watson,
Markus Isomaki,
Markus Lanthaler,
Martin J. Duerst,
Martin Musatov,
Martin Nilsson,
Martin Thomson,
Matt Lynch,
Matthew Cox,
Matthew Kerwin,
Max Clark,
Menachem Dodge,
Meral Shirazipour,
Michael Burrows,
Michael Hausenblas,
Michael Scharf,
Michael Sweet,
Michael Tuexen,
Michael Welzl,
Mike Amundsen,
Mike Belshe,
Mike Bishop,
Mike Kelly,
Mike Schinkel,
Miles Sabin,
Murray S. Kucherawy,
Mykyta Yevstifeyev,
Nathan Rixham,
Nicholas Shanks,
Nico Williams,
Nicolas Alvarez,
Nicolas Mailhot,
Noah Slater,
Osama Mazahir,
Pablo Castro,
Pat Hayes,
Patrick R. McManus,
Paul E. Jones,
Paul Hoffman,
Paul Marquess,
Pete Resnick,
Peter Lepeska,
Peter Occil,
Peter Saint-Andre,
Peter Watkins,
Phil Archer,
Phil Hunt,
Philippe Mougin,
Phillip Hallam-Baker,
Piotr Dobrogost,
Poul-Henning Kamp,
Preethi Natarajan,
Rajeev Bector,
Ray Polk,
Reto Bachmann-Gmuer,
Richard Barnes,
Richard Cyganiak,
Rob Trace,
Robby Simpson,
Robert Brewer,
Robert Collins,
Robert Mattson,
Robert O'Callahan,
Robert Olofsson,
Robert Sayre,
Robert Siemer,
Robert de Wilde,
Roberto Javier Godoy,
Roberto Peon,
Roland Zink,
Ronny Widjaja,
Ryan Hamilton,
S. Mike Dierken,
Salvatore Loreto,
Sam Johnston,
Sam Pullara,
Sam Ruby,
Saurabh Kulkarni,
Scott Lawrence (who maintained the original issues list),
Sean B. Palmer,
Sean Turner,
Sebastien Barnoud,
Shane McCarron,
Shigeki Ohtsu,
Simon Yarde,
Stefan Eissing,
Stefan Tilkov,
Stefanos Harhalakis,
Stephane Bortzmeyer,
Stephen Farrell,
Stephen Kent,
Stephen Ludin,
Stuart Williams,
Subbu Allamaraju,
Subramanian Moonesamy,
Susan Hares,
Sylvain Hellegouarch,
Tapan Divekar,
Tatsuhiro Tsujikawa,
Tatsuya Hayashi,
Ted Hardie,
Ted Lemon,
Thomas Broyer,
Thomas Fossati,
Thomas Maslen,
Thomas Nadeau,
Thomas Nordin,
Thomas Roessler,
Tim Bray,
Tim Morgan,
Tim Olsen,
Tom Zhou,
Travis Snoozy,
Tyler Close,
Vincent Murphy,
Wenbo Zhu,
Werner Baumann,
Wilbur Streett,
Wilfredo Sanchez Vega,
William A. Rowe Jr.,
William Chan,
Willy Tarreau,
Xiaoshu Wang,
Yaron Goland,
Yngve Nysaeter Pettersen,
Yoav Nir,
Yogesh Bang,
Yuchung Cheng,
Yutaka Oiwa,
Yves Lafon (long-time member of the editor team),
Zed A. Shaw, and 
Zhong Yu.
</t>
<?ENDINC acks ?>
<t>
   See <xref target="RFC2616" x:fmt="of" x:sec="16"/> for additional
   acknowledgements from prior revisions.
</t>
</section>

</middle>
<back>

<references title="Normative References">

<reference anchor="RFC7231">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7231"/>
  <x:source href="rfc7231.xml" basename="rfc7231">
    <x:defines>1xx (Informational)</x:defines>
    <x:defines>1xx</x:defines>
    <x:defines>100 (Continue)</x:defines>
    <x:defines>101 (Switching Protocols)</x:defines>
    <x:defines>2xx (Successful)</x:defines>
    <x:defines>2xx</x:defines>
    <x:defines>200 (OK)</x:defines>
    <x:defines>203 (Non-Authoritative Information)</x:defines>
    <x:defines>204 (No Content)</x:defines>
    <x:defines>3xx (Redirection)</x:defines>
    <x:defines>3xx</x:defines>
    <x:defines>301 (Moved Permanently)</x:defines>
    <x:defines>4xx (Client Error)</x:defines>
    <x:defines>4xx</x:defines>
    <x:defines>400 (Bad Request)</x:defines>
    <x:defines>411 (Length Required)</x:defines>
    <x:defines>414 (URI Too Long)</x:defines>
    <x:defines>417 (Expectation Failed)</x:defines>
    <x:defines>426 (Upgrade Required)</x:defines>
    <x:defines>501 (Not Implemented)</x:defines>
    <x:defines>502 (Bad Gateway)</x:defines>
    <x:defines>505 (HTTP Version Not Supported)</x:defines>
    <x:defines>Accept-Encoding</x:defines>
    <x:defines>Allow</x:defines>
    <x:defines>Content-Encoding</x:defines>
    <x:defines>Content-Location</x:defines>
    <x:defines>Content-Type</x:defines>
    <x:defines>Date</x:defines>
    <x:defines>Expect</x:defines>
    <x:defines>Location</x:defines>
    <x:defines>Server</x:defines>
    <x:defines>User-Agent</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7232">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
    <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014" />
  </front>
  <seriesInfo name="RFC" value="7232"/>
  <x:source href="rfc7232.xml" basename="rfc7232">
    <x:defines>304 (Not Modified)</x:defines>
    <x:defines>ETag</x:defines>
    <x:defines>Last-Modified</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7233">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7233"/>
  <x:source href="rfc7233.xml" basename="rfc7233">
    <x:defines>Content-Range</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7234">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
      <organization>Akamai</organization>
      <address><email>mnot@mnot.net</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7234"/>
  <x:source href="rfc7234.xml" basename="rfc7234">
    <x:defines>Cache-Control</x:defines>
    <x:defines>Expires</x:defines>
    <x:defines>Warning</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7235">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7235"/>
  <x:source href="rfc7235.xml" basename="rfc7235">
    <x:defines>Proxy-Authenticate</x:defines>
    <x:defines>Proxy-Authorization</x:defines>
  </x:source>
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
        <email>dcrocker@bbiw.net</email>
      </address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
        <email>paul.overell@thus.net</email>
      </address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC3986">
 <front>
  <title abbrev='URI Generic Syntax'>Uniform Resource Identifier (URI): Generic Syntax</title>
  <author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
       <email>timbl@w3.org</email>
       <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>
  <author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
    <organization abbrev="Day Software">Day Software</organization>
    <address>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>
  <author initials='L.' surname='Masinter' fullname='Larry Masinter'>
    <organization abbrev="Adobe Systems">Adobe Systems Incorporated</organization>
    <address>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>
  <date month='January' year='2005'></date>
 </front>
 <seriesInfo name="STD" value="66"/>
 <seriesInfo name="RFC" value="3986"/>
</reference>

<reference anchor="RFC0793">
  <front>
    <title>Transmission Control Protocol</title>
    <author initials='J.' surname='Postel' fullname='Jon Postel'>
      <organization>University of Southern California (USC)/Information Sciences Institute</organization>
    </author>
    <date year='1981' month='September' />
  </front>
  <seriesInfo name='STD' value='7' />
  <seriesInfo name='RFC' value='793' />
</reference>

<reference anchor="USASCII">
  <front>
    <title>Coded Character Set -- 7-bit American Standard Code for Information Interchange</title>
    <author>
      <organization>American National Standards Institute</organization>
    </author>
    <date year="1986"/>
  </front>
  <seriesInfo name="ANSI" value="X3.4"/>
</reference>

<reference anchor="RFC1950">
  <front>
    <title>ZLIB Compressed Data Format Specification version 3.3</title>
    <author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly"/>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1950"/>
  <!--<annotation>
    RFC 1950 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of <xref target="RFC2068" x:fmt="none">RFC 2068</xref> in 1997,
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>-->
</reference>

<reference anchor="RFC1951">
  <front>
    <title>DEFLATE Compressed Data Format Specification version 1.3</title>
    <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1951"/>
  <!--<annotation>
    RFC 1951 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of <xref target="RFC2068" x:fmt="none">RFC 2068</xref> in 1997,
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>-->
</reference>

<reference anchor="RFC1952">
  <front>
    <title>GZIP file format specification version 4.3</title>
    <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly">
      <address><email>gzip@prep.ai.mit.edu</email></address>
    </author>
    <author initials="M." surname="Adler" fullname="Mark Adler">
      <address><email>madler@alumni.caltech.edu</email></address>
    </author>
    <author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="G." surname="Randers-Pehrson" fullname="Glenn Randers-Pehrson">
      <address><email>randeg@alumni.rpi.edu</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1952"/>
  <!--<annotation>
    RFC 1952 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of <xref target="RFC2068" x:fmt="none">RFC 2068</xref> in 1997,
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>-->
</reference>

<reference anchor="Welch">
  <front>
    <title>A Technique for High-Performance Data Compression</title>
    <author initials="T. A." surname="Welch" fullname="Terry A. Welch"/>
    <date month="June" year="1984"/>
  </front>
  <seriesInfo name="IEEE Computer" value="17(6)"/>
</reference>

</references>

<references title="Informative References">

<reference anchor="ISO-8859-1">
  <front>
    <title>
     Information technology -- 8-bit single-byte coded graphic character sets -- Part 1: Latin alphabet No. 1
    </title>
    <author>
      <organization>International Organization for Standardization</organization>
    </author>
    <date year="1998"/>
  </front>
  <seriesInfo name="ISO/IEC" value="8859-1:1998"/>
</reference>

<reference anchor='RFC1919'>
  <front>
    <title>Classical versus Transparent IP Proxies</title>
    <author initials='M.' surname='Chatel' fullname='Marc Chatel'>
      <address><email>mchatel@pax.eunet.ch</email></address>
    </author>
    <date year='1996' month='March' />
  </front>
  <seriesInfo name='RFC' value='1919' />
</reference>

<reference anchor="RFC1945">
  <front>
    <title abbrev="HTTP/1.0">Hypertext Transfer Protocol -- HTTP/1.0</title>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization>MIT, Laboratory for Computer Science</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
      <organization>University of California, Irvine, Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="H.F." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>W3 Consortium, MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1945"/>
</reference>

<reference anchor="RFC2045">
  <front>
    <title abbrev="Internet Message Bodies">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2045"/>
</reference>

<reference anchor="RFC2047">
  <front>
    <title abbrev="Message Header Extensions">MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text</title>
    <author initials="K." surname="Moore" fullname="Keith Moore">
      <organization>University of Tennessee</organization>
      <address><email>moore@cs.utk.edu</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2047"/>
</reference>

<reference anchor="RFC2068">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding">
      <organization>University of California, Irvine, Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization>Digital Equipment Corporation, Western Research Laboratory</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="January" year="1997"/>
  </front>
  <seriesInfo name="RFC" value="2068"/>
</reference>

<reference anchor="RFC2145">
  <front>
    <title abbrev="HTTP Version Numbers">Use and Interpretation of HTTP Version Numbers</title>
    <author initials="J.C." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization>Western Research Laboratory</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
      <organization>Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="H.F." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>W3 Consortium</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <date month="May" year="1997"/>
  </front>
  <seriesInfo name="RFC" value="2145"/>
</reference>

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor='RFC2817'>
  <front>
    <title>Upgrading to TLS Within HTTP/1.1</title>
    <author initials='R.' surname='Khare' fullname='R. Khare'>
      <organization>4K Associates / UC Irvine</organization>
      <address><email>rohit@4K-associates.com</email></address>
    </author>
    <author initials='S.' surname='Lawrence' fullname='S. Lawrence'>
      <organization>Agranat Systems, Inc.</organization>
      <address><email>lawrence@agranat.com</email></address>
    </author>
    <date year='2000' month='May' />
  </front>
  <seriesInfo name='RFC' value='2817' />
</reference>

<reference anchor='RFC2818'>
  <front>
    <title>HTTP Over TLS</title>
    <author initials='E.' surname='Rescorla' fullname='Eric Rescorla'>
      <organization>RTFM, Inc.</organization>
      <address><email>ekr@rtfm.com</email></address>
    </author>
    <date year='2000' month='May' />
  </front>
  <seriesInfo name='RFC' value='2818' />
</reference>

<reference anchor='RFC3040'>
  <front>
    <title>Internet Web Replication and Caching Taxonomy</title>
    <author initials='I.' surname='Cooper' fullname='I. Cooper'>
      <organization>Equinix, Inc.</organization>
    </author>
    <author initials='I.' surname='Melve' fullname='I. Melve'>
      <organization>UNINETT</organization>
    </author>
    <author initials='G.' surname='Tomlinson' fullname='G. Tomlinson'>
      <organization>CacheFlow Inc.</organization>
    </author>
    <date year='2001' month='January' />
  </front>
  <seriesInfo name='RFC' value='3040' />
</reference>

<reference anchor='BCP90'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

<reference anchor='RFC4033'>
  <front>
    <title>DNS Security Introduction and Requirements</title>
    <author initials='R.' surname='Arends' fullname='R. Arends'/>
    <author initials='R.' surname='Austein' fullname='R. Austein'/>
    <author initials='M.' surname='Larson' fullname='M. Larson'/>
    <author initials='D.' surname='Massey' fullname='D. Massey'/>
    <author initials='S.' surname='Rose' fullname='S. Rose'/>
    <date year='2005' month='March' />
  </front>
  <seriesInfo name='RFC' value='4033' />
</reference>

<reference anchor="BCP13">
  <front>
    <title>Media Type Specifications and Registration Procedures</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Oracle</organization>
      <address>
        <email>ned+ietf@mrochek.com</email>
      </address>
    </author>
    <author initials="J." surname="Klensin" fullname="John C. Klensin">
      <address>
        <email>john+ietf@jck.com</email>
      </address>
    </author>
    <author initials="T." surname="Hansen" fullname="Tony Hansen">
      <organization>AT&amp;T Laboratories</organization>
      <address>
        <email>tony+mtsuffix@maillennium.att.com</email>
      </address>
    </author>
    <date year="2013" month="January"/>
  </front>
  <seriesInfo name="BCP" value="13"/>
  <seriesInfo name="RFC" value="6838"/>
</reference>

<reference anchor='BCP115'>
  <front>
    <title>Guidelines and Registration Procedures for New URI Schemes</title>
    <author initials='T.' surname='Hansen' fullname='T. Hansen'>
      <organization>AT&amp;T Laboratories</organization>
      <address>
        <email>tony+urireg@maillennium.att.com</email>
      </address>
    </author>
    <author initials='T.' surname='Hardie' fullname='T. Hardie'>
      <organization>Qualcomm, Inc.</organization>
      <address>
        <email>hardie@qualcomm.com</email>
      </address>
    </author>
    <author initials='L.' surname='Masinter' fullname='L. Masinter'>
      <organization>Adobe Systems</organization>
      <address>
        <email>LMM@acm.org</email>
      </address>
    </author>
    <date year='2006' month='February' />
  </front>
  <seriesInfo name='BCP' value='115' />
  <seriesInfo name='RFC' value='4395' />
</reference>

<reference anchor='RFC4559'>
  <front>
    <title>SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows</title>
    <author initials='K.' surname='Jaganathan' fullname='K. Jaganathan'/>
    <author initials='L.' surname='Zhu' fullname='L. Zhu'/>
    <author initials='J.' surname='Brezak' fullname='J. Brezak'/>
    <date year='2006' month='June' />
  </front>
  <seriesInfo name='RFC' value='4559' />
</reference>

<reference anchor='RFC5226'>
  <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author initials='T.' surname='Narten' fullname='T. Narten'>
      <organization>IBM</organization>
      <address><email>narten@us.ibm.com</email></address>
    </author>
    <author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
      <organization>Google</organization>
      <address><email>Harald@Alvestrand.no</email></address>
    </author>
    <date year='2008' month='May' />
  </front>
  <seriesInfo name='BCP' value='26' />
  <seriesInfo name='RFC' value='5226' />
</reference>

<reference anchor='RFC5246'>
   <front>
      <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
      <author initials='T.' surname='Dierks' fullname='T. Dierks'/>
      <author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
         <organization>RTFM, Inc.</organization>
      </author>
      <date year='2008' month='August' />
   </front>
   <seriesInfo name='RFC' value='5246' />
</reference>

<reference anchor="RFC5322">
  <front>
    <title>Internet Message Format</title>
    <author initials="P." surname="Resnick" fullname="P. Resnick">
      <organization>Qualcomm Incorporated</organization>
    </author>
    <date year="2008" month="October"/>
  </front> 
  <seriesInfo name="RFC" value="5322"/>
</reference>

<reference anchor="RFC6265">
  <front>
    <title>HTTP State Management Mechanism</title>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization abbrev="U.C. Berkeley">
        University of California, Berkeley
      </organization>
      <address><email>abarth@eecs.berkeley.edu</email></address>
    </author>
    <date year="2011" month="April" />
  </front>
  <seriesInfo name="RFC" value="6265"/>
</reference>

<reference anchor='RFC6585'>
  <front>
    <title>Additional HTTP Status Codes</title>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>Rackspace</organization>
    </author>
    <author initials='R.' surname='Fielding' fullname='R. Fielding'>
      <organization>Adobe</organization>
    </author>
    <date year='2012' month='April' />
   </front>
   <seriesInfo name='RFC' value='6585' />
</reference>

<!--<reference anchor='BCP97'>
  <front>
    <title>Handling Normative References to Standards-Track Documents</title>
    <author initials='J.' surname='Klensin' fullname='J. Klensin'>
      <address>
        <email>klensin+ietf@jck.com</email>
      </address>
    </author>
    <author initials='S.' surname='Hartman' fullname='S. Hartman'>
      <organization>MIT</organization>
      <address>
        <email>hartmans-ietf@mit.edu</email>
      </address>
    </author>
    <date year='2007' month='June' />
  </front>
  <seriesInfo name='BCP' value='97' />
  <seriesInfo name='RFC' value='4897' />
</reference>-->

<reference anchor="Kri2001" target="http://arxiv.org/abs/cs.SE/0105018">
  <front>
    <title>HTTP Cookies: Standards, Privacy, and Politics</title>
    <author initials="D." surname="Kristol" fullname="David M. Kristol"/>
    <date year="2001" month="November"/>
  </front>
  <seriesInfo name="ACM Transactions on Internet Technology" value="1(2)"/>
</reference>

<reference anchor="Klein" target="http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf">
  <front>
    <title>Divide and Conquer - HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</title>
    <author initials="A." surname="Klein" fullname="Amit Klein">
      <organization>Sanctum, Inc.</organization>
    </author>
    <date year="2004" month="March"/>
  </front>
</reference>

<reference anchor="Georgiev" target="http://doi.acm.org/10.1145/2382196.2382204">
  <front>
    <title>The Most Dangerous Code in the World: Validating SSL Certificates in Non-browser Software</title>
    <author initials="M." surname="Georgiev" fullname="Martin Georgiev"/>
    <author initials="S." surname="Iyengar" fullname="Subodh Iyengar"/>
    <author initials="S." surname="Jana" fullname="Suman Jana"/>
    <author initials="R." surname="Anubhai" fullname="Rishita Anubhai"/>
    <author initials="D." surname="Boneh" fullname="Dan Boneh"/>
    <author initials="V." surname="Shmatikov" fullname="Vitaly Shmatikov"/>
    <date year="2012" month="October"/>
  </front>
  <x:prose>In Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS '12), pp. 38-49</x:prose>
</reference>

<reference anchor="Linhart" target="http://www.watchfire.com/news/whitepapers.aspx">
  <front>
    <title>HTTP Request Smuggling</title>
    <author initials="C." surname="Linhart" fullname="Chaim Linhart"/>
    <author initials="A." surname="Klein" fullname="Amit Klein"/>
    <author initials="R." surname="Heled" fullname="Ronen Heled"/>
    <author initials="S." surname="Orrin" fullname="Steve Orrin"/>
    <date year="2005" month="June"/>
  </front>
</reference>

</references>


<section title="HTTP Version History" anchor="compatibility">
<t>
   HTTP has been in use since 1990. The first version, later referred to as
   HTTP/0.9, was a simple protocol for hypertext data transfer across the
   Internet, using only a single request method (GET) and no metadata.
   HTTP/1.0, as defined by <xref target="RFC1945"/>, added a range of request
   methods and MIME-like messaging, allowing for metadata to be transferred
   and modifiers placed on the request/response semantics. However,
   HTTP/1.0 did not sufficiently take into consideration the effects of
   hierarchical proxies, caching, the need for persistent connections, or
   name-based virtual hosts. The proliferation of incompletely implemented
   applications calling themselves "HTTP/1.0" further necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.
</t>
<t>
   HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent
   requirements that enable reliable implementations, adding only
   those features that can either be safely ignored by an HTTP/1.0
   recipient or only be sent when communicating with a party advertising
   conformance with HTTP/1.1.
</t>
<t>
   HTTP/1.1 has been designed to make supporting previous versions easy.
   A general-purpose HTTP/1.1 server ought to be able to understand any valid
   request in the format of HTTP/1.0, responding appropriately with an
   HTTP/1.1 message that only uses features understood (or safely ignored) by
   HTTP/1.0 clients. Likewise, an HTTP/1.1 client can be expected to
   understand any valid HTTP/1.0 response.
</t>
<t>
   Since HTTP/0.9 did not support header fields in a request, there is no
   mechanism for it to support name-based virtual hosts (selection of resource
   by inspection of the <x:ref>Host</x:ref> header field).
   Any server that implements name-based virtual hosts ought to disable
   support for HTTP/0.9. Most requests that appear to be HTTP/0.9 are, in
   fact, badly constructed HTTP/1.x requests caused by a client failing to
   properly encode the request-target.
</t>

<section title="Changes from HTTP/1.0" anchor="changes.from.1.0">
<t>
   This section summarizes major differences between versions HTTP/1.0
   and HTTP/1.1.
</t>

<section title="Multihomed Web Servers" anchor="changes.to.simplify.multihomed.web.servers.and.conserve.ip.addresses">
<t>
   The requirements that clients and servers support the <x:ref>Host</x:ref>
   header field (<xref target="header.host"/>), report an error if it is
   missing from an HTTP/1.1 request, and accept absolute URIs (<xref target="request-target"/>)
   are among the most important changes defined by HTTP/1.1.
</t>
<t>
   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed. The <x:ref>Host</x:ref> header field was
   introduced during the development of HTTP/1.1 and, though it was
   quickly implemented by most HTTP/1.0 browsers, additional requirements
   were placed on all HTTP/1.1 requests in order to ensure complete
   adoption.  At the time of this writing, most HTTP-based services
   are dependent upon the Host header field for targeting requests.
</t>
</section>

<section title="Keep-Alive Connections" anchor="compatibility.with.http.1.0.persistent.connections">
<t>
   In HTTP/1.0, each connection is established by the client prior to the
   request and closed by the server after sending the response. However, some
   implementations implement the explicitly negotiated ("Keep-Alive") version
   of persistent connections described in <xref x:sec="19.7.1" x:fmt="of"
   target="RFC2068"/>.
</t>
<t>
   Some clients and servers might wish to be compatible with these previous
   approaches to persistent connections, by explicitly negotiating for them
   with a "Connection: keep-alive" request header field. However, some
   experimental implementations of HTTP/1.0 persistent connections are faulty;
   for example, if an HTTP/1.0 proxy server doesn't understand
   <x:ref>Connection</x:ref>, it will erroneously forward that header field
   to the next inbound server, which would result in a hung connection.
</t>
<t>
   One attempted solution was the introduction of a Proxy-Connection header
   field, targeted specifically at proxies. In practice, this was also
   unworkable, because proxies are often deployed in multiple layers, bringing
   about the same problem discussed above.
</t>
<t>
   As a result, clients are encouraged not to send the Proxy-Connection header 
   field in any requests.
</t>
<t>
   Clients are also encouraged to consider the use of Connection: keep-alive
   in requests carefully; while they can enable persistent connections with
   HTTP/1.0 servers, clients using them will need to monitor the
   connection for "hung" requests (which indicate that the client ought stop
   sending the header field), and this mechanism ought not be used by clients
   at all when a proxy is being used.
</t>
</section>

<section title="Introduction of Transfer-Encoding" anchor="introduction.of.transfer-encoding">
<t>
   HTTP/1.1 introduces the <x:ref>Transfer-Encoding</x:ref> header field
   (<xref target="header.transfer-encoding"/>).
   Transfer codings need to be decoded prior to forwarding an HTTP message
   over a MIME-compliant protocol.
</t>
</section>

</section>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
  HTTP's approach to error handling has been explained.
  (<xref target="conformance" />)
</t>
<t>
  The HTTP-version ABNF production has been clarified to be case-sensitive.
  Additionally, version numbers have been restricted to single digits, due
  to the fact that implementations are known to handle multi-digit version
  numbers incorrectly.
  (<xref target="http.version"/>)
</t>
<t>
  Userinfo (i.e., username and password) are now disallowed in HTTP and
  HTTPS URIs, because of security issues related to their transmission on the
  wire.
  (<xref target="http.uri" />)
</t>
<t>
  The HTTPS URI scheme is now defined by this specification; previously,
  it was done in  <xref target="RFC2818" x:fmt="of" x:sec="2.4"/>.
  Furthermore, it implies end-to-end security.
  (<xref target="https.uri"/>)
</t>
<t>
  HTTP messages can be (and often are) buffered by implementations; despite
  it sometimes being available as a stream, HTTP is fundamentally a
  message-oriented protocol.
  Minimum supported sizes for various protocol elements have been 
  suggested, to improve interoperability.
  (<xref target="http.message" />)
</t>
<t>
  Invalid whitespace around field-names is now required to be rejected, 
  because accepting it represents a security vulnerability.
  The ABNF productions defining header fields now only list the field value.
  (<xref target="header.fields"/>)
</t>
<t>
  Rules about implicit linear whitespace between certain grammar productions
  have been removed; now whitespace is only allowed where specifically
  defined in the ABNF.
  (<xref target="whitespace"/>)
</t>
<t>
  Header fields that span multiple lines ("line folding") are deprecated.
  (<xref target="field.parsing" />)
</t>
<t>  
  The NUL octet is no longer allowed in comment and quoted-string text, and
  handling of backslash-escaping in them has been clarified.
  The quoted-pair rule no longer allows escaping control characters other than
  HTAB.
  Non-US-ASCII content in header fields and the reason phrase has been obsoleted
  and made opaque (the TEXT rule was removed). 
  (<xref target="field.components"/>)
</t>  
<t>
  Bogus <x:ref>Content-Length</x:ref> header fields are now required to be
  handled as errors by recipients.
  (<xref target="header.content-length"/>)
</t>
<t>
  The algorithm for determining the message body length has been clarified
  to indicate all of the special cases (e.g., driven by methods or status
  codes) that affect it, and that new protocol elements cannot define such
  special cases.
  CONNECT is a new, special case in determining message body length.
  "multipart/byteranges" is no longer a way of determining message body length
  detection.
  (<xref target="message.body.length"/>)
</t>
<t>
  The "identity" transfer coding token has been removed.
  (Sections <xref format="counter" target="message.body"/> and
  <xref format="counter" target="transfer.codings"/>)
</t>
<t>
  Chunk length does not include the count of the octets in the
  chunk header and trailer.
  Line folding in chunk extensions is  disallowed.
  (<xref target="chunked.encoding"/>)
</t>
<t>
  The meaning of the "deflate" content coding has been clarified.
  (<xref target="deflate.coding" />)
</t>
<t>
  The segment + query components of RFC 3986 have been used to define the
  request-target, instead of abs_path from RFC 1808.
  The asterisk-form of the request-target is only allowed with the OPTIONS
  method.
  (<xref target="request-target"/>)
</t>
<t>
  The term "Effective Request URI" has been introduced.
  (<xref target="effective.request.uri" />)
</t>
<t>
  Gateways do not need to generate <x:ref>Via</x:ref> header fields anymore.
  (<xref target="header.via"/>)
</t>
<t>
  Exactly when "close" connection options have to be sent has been clarified.
  Also, "hop-by-hop" header fields are required to appear in the Connection header
  field; just because they're defined as hop-by-hop in this specification
  doesn't exempt them.
  (<xref target="header.connection"/>)
</t>
<t>
  The limit of two connections per server has been removed.
  An idempotent sequence of requests is no longer required to be retried.
  The requirement to retry requests under certain circumstances when the
  server prematurely closes the connection has been removed.
  Also, some extraneous requirements about when servers are allowed to close
  connections prematurely have been removed.
  (<xref target="persistent.connections"/>)
</t>
<t>
  The semantics of the <x:ref>Upgrade</x:ref> header field is now defined in
  responses other than 101 (this was incorporated from <xref
  target="RFC2817"/>). Furthermore, the ordering in the field value is now
  significant.
  (<xref target="header.upgrade"/>)
</t>
<t>
  Empty list elements in list productions (e.g., a list header field containing 
  ", ,") have been deprecated.
  (<xref target="abnf.extension"/>)
</t>
<t>
  Registration of Transfer Codings now requires IETF Review
  (<xref target="transfer.coding.registry"/>)
</t>
<t>
  This specification now defines the Upgrade Token Registry, previously
  defined in <xref target="RFC2817" x:fmt="of" x:sec="7.2"/>.
  (<xref target="upgrade.token.registry"/>)
</t>
<t>
  The expectation to support HTTP/0.9 requests has been removed.
  (<xref target="compatibility"/>)
</t>
<t>
  Issues with the Keep-Alive and Proxy-Connection header fields in requests
  are pointed out, with use of the latter being discouraged altogether.
  (<xref target="compatibility.with.http.1.0.persistent.connections" />)
</t>
</section>
</section>

<?BEGININC p1-messaging.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p1-messaging.parsed-abnf">
<x:ref>BWS</x:ref> = OWS

<x:ref>Connection</x:ref> = *( "," OWS ) connection-option *( OWS "," [ OWS
 connection-option ] )
<x:ref>Content-Length</x:ref> = 1*DIGIT

<x:ref>HTTP-message</x:ref> = start-line *( header-field CRLF ) CRLF [ message-body
 ]
<x:ref>HTTP-name</x:ref> = %x48.54.54.50 ; HTTP
<x:ref>HTTP-version</x:ref> = HTTP-name "/" DIGIT "." DIGIT
<x:ref>Host</x:ref> = uri-host [ ":" port ]

<x:ref>OWS</x:ref> = *( SP / HTAB )

<x:ref>RWS</x:ref> = 1*( SP / HTAB )

<x:ref>TE</x:ref> = [ ( "," / t-codings ) *( OWS "," [ OWS t-codings ] ) ]
<x:ref>Trailer</x:ref> = *( "," OWS ) field-name *( OWS "," [ OWS field-name ] )
<x:ref>Transfer-Encoding</x:ref> = *( "," OWS ) transfer-coding *( OWS "," [ OWS
 transfer-coding ] )

<x:ref>URI-reference</x:ref> = &lt;URI-reference, see [RFC3986], Section 4.1&gt;
<x:ref>Upgrade</x:ref> = *( "," OWS ) protocol *( OWS "," [ OWS protocol ] )

<x:ref>Via</x:ref> = *( "," OWS ) ( received-protocol RWS received-by [ RWS comment
 ] ) *( OWS "," [ OWS ( received-protocol RWS received-by [ RWS
 comment ] ) ] )

<x:ref>absolute-URI</x:ref> = &lt;absolute-URI, see [RFC3986], Section 4.3&gt;
<x:ref>absolute-form</x:ref> = absolute-URI
<x:ref>absolute-path</x:ref> = 1*( "/" segment )
<x:ref>asterisk-form</x:ref> = "*"
<x:ref>authority</x:ref> = &lt;authority, see [RFC3986], Section 3.2&gt;
<x:ref>authority-form</x:ref> = authority

<x:ref>chunk</x:ref> = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
<x:ref>chunk-data</x:ref> = 1*OCTET
<x:ref>chunk-ext</x:ref> = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
<x:ref>chunk-ext-name</x:ref> = token
<x:ref>chunk-ext-val</x:ref> = token / quoted-string
<x:ref>chunk-size</x:ref> = 1*HEXDIG
<x:ref>chunked-body</x:ref> = *chunk last-chunk trailer-part CRLF
<x:ref>comment</x:ref> = "(" *( ctext / quoted-pair / comment ) ")"
<x:ref>connection-option</x:ref> = token
<x:ref>ctext</x:ref> = HTAB / SP / %x21-27 ; '!'-'''
 / %x2A-5B ; '*'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text

<x:ref>field-content</x:ref> = field-vchar [ 1*( SP / HTAB ) field-vchar ]
<x:ref>field-name</x:ref> = token
<x:ref>field-value</x:ref> = *( field-content / obs-fold )
<x:ref>field-vchar</x:ref> = VCHAR / obs-text
<x:ref>fragment</x:ref> = &lt;fragment, see [RFC3986], Section 3.5&gt;

<x:ref>header-field</x:ref> = field-name ":" OWS field-value OWS
<x:ref>http-URI</x:ref> = "http://" authority path-abempty [ "?" query ] [ "#"
 fragment ]
<x:ref>https-URI</x:ref> = "https://" authority path-abempty [ "?" query ] [ "#"
 fragment ]

<x:ref>last-chunk</x:ref> = 1*"0" [ chunk-ext ] CRLF

<x:ref>message-body</x:ref> = *OCTET
<x:ref>method</x:ref> = token

<x:ref>obs-fold</x:ref> = CRLF 1*( SP / HTAB )
<x:ref>obs-text</x:ref> = %x80-FF
<x:ref>origin-form</x:ref> = absolute-path [ "?" query ]

<x:ref>partial-URI</x:ref> = relative-part [ "?" query ]
<x:ref>path-abempty</x:ref> = &lt;path-abempty, see [RFC3986], Section 3.3&gt;
<x:ref>port</x:ref> = &lt;port, see [RFC3986], Section 3.2.3&gt;
<x:ref>protocol</x:ref> = protocol-name [ "/" protocol-version ]
<x:ref>protocol-name</x:ref> = token
<x:ref>protocol-version</x:ref> = token
<x:ref>pseudonym</x:ref> = token

<x:ref>qdtext</x:ref> = HTAB / SP / "!" / %x23-5B ; '#'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text
<x:ref>query</x:ref> = &lt;query, see [RFC3986], Section 3.4&gt;
<x:ref>quoted-pair</x:ref> = "\" ( HTAB / SP / VCHAR / obs-text )
<x:ref>quoted-string</x:ref> = DQUOTE *( qdtext / quoted-pair ) DQUOTE

<x:ref>rank</x:ref> = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )
<x:ref>reason-phrase</x:ref> = *( HTAB / SP / VCHAR / obs-text )
<x:ref>received-by</x:ref> = ( uri-host [ ":" port ] ) / pseudonym
<x:ref>received-protocol</x:ref> = [ protocol-name "/" ] protocol-version
<x:ref>relative-part</x:ref> = &lt;relative-part, see [RFC3986], Section 4.2&gt;
<x:ref>request-line</x:ref> = method SP request-target SP HTTP-version CRLF
<x:ref>request-target</x:ref> = origin-form / absolute-form / authority-form /
 asterisk-form

<x:ref>scheme</x:ref> = &lt;scheme, see [RFC3986], Section 3.1&gt;
<x:ref>segment</x:ref> = &lt;segment, see [RFC3986], Section 3.3&gt;
<x:ref>start-line</x:ref> = request-line / status-line
<x:ref>status-code</x:ref> = 3DIGIT
<x:ref>status-line</x:ref> = HTTP-version SP status-code SP reason-phrase CRLF

<x:ref>t-codings</x:ref> = "trailers" / ( transfer-coding [ t-ranking ] )
<x:ref>t-ranking</x:ref> = OWS ";" OWS "q=" rank
<x:ref>tchar</x:ref> = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*" / "+" / "-" / "." /
 "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
<x:ref>token</x:ref> = 1*tchar
<x:ref>trailer-part</x:ref> = *( header-field CRLF )
<x:ref>transfer-coding</x:ref> = "chunked" / "compress" / "deflate" / "gzip" /
 transfer-extension
<x:ref>transfer-extension</x:ref> = token *( OWS ";" OWS transfer-parameter )
<x:ref>transfer-parameter</x:ref> = token BWS "=" BWS ( token / quoted-string )

<x:ref>uri-host</x:ref> = &lt;host, see [RFC3986], Section 3.2.2&gt;
</artwork>
</figure>
</section>
<?ENDINC p1-messaging.abnf-appendix ?>
</back>
</rfc>
