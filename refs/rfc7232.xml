<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY mdash "&#8212;">
  <!ENTITY Note "<x:h xmlns:x='http://purl.org/net/xml2rfc/ext'>Note:</x:h>">
  <!ENTITY architecture               "<xref target='RFC7230' x:rel='#architecture' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY conformance                "<xref target='RFC7230' x:rel='#conformance' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation                   "<xref target='RFC7230' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY abnf-extension             "<xref target='RFC7230' x:rel='#abnf.extension' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY acks                       "<xref target='RFC7230' x:rel='#acks' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY whitespace                 "<xref target='RFC7230' x:rel='#whitespace' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY field-components           "<xref target='RFC7230' x:rel='#field.components' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-date                "<xref target='RFC7231' x:rel='#header.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY safe-methods               "<xref target='RFC7231' x:rel='#safe.methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY representation             "<xref target='RFC7231' x:rel='#representations' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY messaging                  "<xref target='RFC7230' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY semantics                  "<xref target='RFC7231' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY caching                    "<xref target='RFC7234' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY cache-key                  "<xref target='RFC7234' x:rel='#constructing.responses.from.caches' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY cache-validation-received  "<xref target='RFC7234' x:rel='#validation.received' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY freshening-responses       "<xref target='RFC7234' x:rel='#freshening.responses' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-accept-encoding     "<xref target='RFC7231' x:rel='#header.accept-encoding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-if-range            "<xref target='RFC7233' x:rel='#header.if-range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-range               "<xref target='RFC7233' x:rel='#header.range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-vary                "<xref target='RFC7231' x:rel='#header.vary' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY http-date                  "<xref target='RFC7231' x:rel='#http.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY transfer-codings           "<xref target='RFC7230' x:rel='#transfer.codings' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY content-negotiation        "<xref target='RFC7231' x:rel='#content.negotiation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2616" category="std" x:maturity-level="proposed"
     ipr="pre5378Trust200902" number="7232" consensus="yes"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
<x:link rel="prev" basename="rfc7231"/>
<x:link rel="next" basename="rfc7233"/>
<!--<x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>-->
<front>

  <title abbrev="HTTP/1.1 Conditional Requests">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="June" year="2014"/>

  <area>Applications</area>
  <workgroup>HTTPbis</workgroup>

  <keyword>Hypertext Transfer Protocol</keyword>
  <keyword>HTTP</keyword>
  <keyword>HTTP conditional requests</keyword>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for
   distributed, collaborative, hypertext information systems. This document
   defines HTTP/1.1 conditional requests, including metadata header fields
   for indicating state changes, request header fields for making
   preconditions on such state, and rules for constructing the responses to a
   conditional request when one or more preconditions evaluate to false.
</t>
</abstract>
</front>

<middle>
<section title="Introduction" anchor="introduction">
<t>
   Conditional requests are HTTP requests <xref target="RFC7231"/> that include
   one or more header fields indicating a precondition to be tested before
   applying the method semantics to the target resource.
   This document defines the HTTP/1.1 conditional request mechanisms in terms
   of the architecture, syntax notation, and conformance criteria defined in
   <xref target="RFC7230"/>.
</t>
<t>
   Conditional GET requests are the most efficient mechanism for HTTP
   cache updates &caching;.  Conditionals can also be
   applied to state-changing methods, such as PUT and DELETE, to prevent
   the "lost update" problem: one client accidentally overwriting
   the work of another client that has been acting in parallel.
</t>
<t><iref primary="true" item="selected representation"/>
   Conditional request preconditions are based on the state of the target
   resource as a whole (its current value set) or the state as observed
   in a previously obtained representation (one value in that set).
   A resource might have multiple current representations, each with its
   own observable state.  The conditional request mechanisms assume that
   the mapping of requests to a "selected representation" (&representation;)
   will be consistent over time if the server intends to take advantage of
   conditionals. Regardless, if the mapping is inconsistent and the server is
   unable to select the appropriate representation, then no harm will result
   when the precondition evaluates to false.
</t>
<t>
   The conditional request preconditions defined by this specification
   (<xref target="preconditions"/>) are evaluated when applicable to the
   recipient (<xref target="evaluation"/>) according to their order of
   precedence (<xref target="precedence"/>).
</t>

<section title="Conformance and Error Handling" anchor="conformance">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   Conformance criteria and considerations regarding error handling
   are defined in &conformance;.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
<t>
   This specification uses the Augmented Backus-Naur Form (ABNF) notation of
   <xref target="RFC5234"/> with a list extension, defined in
   &abnf-extension;, that allows for compact definition of
   comma-separated lists using a '#' operator (similar to how the '*' operator
   indicates repetition).
   <xref target="imported.abnf"/> describes rules imported from
   other documents. 
   <xref target="collected.abnf"/> shows the collected grammar with all list
   operators expanded to standard ABNF notation.
</t>
</section>
</section>

<section title="Validators" anchor="validators">
   <iref primary="true" item="metadata"/>
   <iref primary="true" item="validator"/>
<t>
   This specification defines two forms of metadata that are commonly used
   to observe resource state and test for preconditions: modification dates
   (<xref target="header.last-modified"/>) and opaque entity tags
   (<xref target="header.etag"/>).  Additional metadata that reflects resource state
   has been defined by various extensions of HTTP, such as Web Distributed
   Authoring and Versioning (WebDAV, <xref target="RFC4918"/>), that are beyond the scope of this specification.
   A resource metadata value is referred to as a "<x:dfn>validator</x:dfn>"
   when it is used within a precondition.
</t>

<section title="Weak versus Strong" anchor="weak.and.strong.validators">
   <iref primary="true" item="validator" subitem="weak"/>
   <iref primary="true" item="validator" subitem="strong"/>
<t>
   Validators come in two flavors: strong or weak.  Weak validators are easy
   to generate but are far less useful for comparisons.  Strong validators
   are ideal for comparisons but can be very difficult (and occasionally
   impossible) to generate efficiently.  Rather than impose that all forms
   of resource adhere to the same strength of validator, HTTP exposes the
   type of validator in use and imposes restrictions on when weak validators
   can be used as preconditions.
</t>
<t>
   A "strong validator" is representation metadata that changes value whenever
   a change occurs to the representation data that would be observable in the
   payload body of a <x:ref>200 (OK)</x:ref> response to GET.
</t>
<t>   
   A strong validator might change for reasons other than a change to the
   representation data, such as when a
   semantically significant part of the representation metadata is changed
   (e.g., <x:ref>Content-Type</x:ref>), but it is in the best interests of the
   origin server to only change the value when it is necessary to invalidate
   the stored responses held by remote caches and authoring tools.
</t>
<t>
   Cache entries might persist for arbitrarily long periods, regardless
   of expiration times.  Thus, a cache might attempt to validate an
   entry using a validator that it obtained in the distant past.
   A strong validator is unique across all versions of all
   representations associated with a particular resource over time.
   However, there is no implication of uniqueness across representations
   of different resources (i.e., the same strong validator might be
   in use for representations of multiple resources at the same time
   and does not imply that those representations are equivalent).
</t>
<t>
   There are a variety of strong validators used in practice.  The best are
   based on strict revision control, wherein each change to a representation
   always results in a unique node name and revision identifier being assigned
   before the representation is made accessible to GET.  A collision-resistant hash
   function applied to the representation data is also sufficient if the data
   is available prior to the response header fields being sent and the digest
   does not need to be recalculated every time a validation request is
   received.  However, if a resource has distinct representations that differ
   only in their metadata, such as might occur with content negotiation over
   media types that happen to share the same data format, then the origin
   server needs to incorporate additional information in the validator to
   distinguish those representations.
</t>
<t>
   In contrast, a "weak validator" is representation metadata that
   might not change for every change to the representation data.  This
   weakness might be due to limitations in how the value is calculated, such
   as clock resolution, an inability to ensure uniqueness for all possible
   representations of the resource, or a desire of the resource owner
   to group representations by some self-determined set of equivalency
   rather than unique sequences of data.  An origin server &SHOULD; change a
   weak entity-tag whenever it considers prior representations to be
   unacceptable as a substitute for the current representation. In other words,
   a weak entity-tag ought to change whenever the origin server wants caches to
   invalidate old responses.
</t>
<t>
   For example, the representation of a weather report that changes in
   content every second, based on dynamic measurements, might be grouped
   into sets of equivalent representations (from the origin server's
   perspective) with the same weak validator in order to allow cached
   representations to be valid for a reasonable period of time (perhaps
   adjusted dynamically based on server load or weather quality).
   Likewise, a representation's modification time, if defined with only
   one-second resolution, might be a weak validator if it is possible
   for the representation to be modified twice during a single second and
   retrieved between those modifications.
</t>
<t>
   Likewise, a validator is weak if it is shared by two or more
   representations of a given resource at the same time, unless those
   representations have identical representation data. For example, if the
   origin server sends the same validator for a representation with a gzip
   content coding applied as it does for a representation with no content
   coding, then that validator is weak. However, two simultaneous
   representations might share the same strong validator if they differ only
   in the representation metadata, such as when two different media types are
   available for the same representation data.
</t>
<t>
   Strong validators are usable for all conditional requests, including cache
   validation, partial content ranges, and "lost update" avoidance.
   Weak validators are only usable when the client does not require exact
   equality with previously obtained representation data, such as when
   validating a cache entry or limiting a web traversal to recent changes.
</t>
</section>

<section title="Last-Modified" anchor="header.last-modified">
  <iref primary="true" item="Last-Modified header field" x:for-anchor=""/>
  <x:anchor-alias value="Last-Modified"/>
<t>
   The "Last-Modified" header field in a response provides a timestamp
   indicating the date and time at which the origin server believes the
   selected representation was last modified, as determined at the conclusion
   of handling the request.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Last-Modified"/>
  <x:ref>Last-Modified</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example of its use is
</t>
<figure><artwork type="example">
  Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</artwork></figure>

<section title="Generation" anchor="lastmod.generation">
<t>
   An origin server &SHOULD; send Last-Modified for any selected
   representation for which a last modification date can be reasonably
   and consistently determined, since its use in conditional requests
   and evaluating cache freshness (&caching;) results in a substantial
   reduction of HTTP traffic on the Internet and can be a significant
   factor in improving service scalability and reliability.
</t>
<t>
   A representation is typically the sum of many parts behind the
   resource interface.  The last-modified time would usually be
   the most recent time that any of those parts were changed.
   How that value is determined for any given resource is an
   implementation detail beyond the scope of this specification.
   What matters to HTTP is how recipients of the Last-Modified
   header field can use its value to make conditional requests
   and test the validity of locally cached responses.
</t>
<t>
   An origin server &SHOULD; obtain the Last-Modified value of the
   representation as close as possible to the time that it generates the
   <x:ref>Date</x:ref> field value for its response. This allows a recipient to
   make an accurate assessment of the representation's modification time,
   especially if the representation changes near the time that the
   response is generated.
</t>
<t>
   An origin server with a clock &MUST-NOT; send a Last-Modified date
   that is later than the server's time of message origination (<x:ref>Date</x:ref>).
   If the last modification time is derived from implementation-specific
   metadata that evaluates to some time in the future, according to the
   origin server's clock, then the origin server &MUST; replace that
   value with the message origination date. This prevents a future
   modification date from having an adverse impact on cache validation.
</t>
<t>
   An origin server without a clock &MUST-NOT; assign Last-Modified
   values to a response unless these values were associated
   with the resource by some other system or user with a reliable clock.
</t>
</section>

<section title="Comparison" anchor="lastmod.comparison">
<t>
   A Last-Modified time, when used as a validator in a request, is
   implicitly weak unless it is possible to deduce that it is strong,
   using the following rules:
  <list style="symbols">
     <t>The validator is being compared by an origin server to the
        actual current validator for the representation and,</t>
     <t>That origin server reliably knows that the associated representation did
        not change twice during the second covered by the presented
        validator.</t>
  </list>
</t>
<t>
   or
  <list style="symbols">
     <t>The validator is about to be used by a client in an <x:ref>If-Modified-Since</x:ref>,
        <x:ref>If-Unmodified-Since</x:ref>, or <x:ref>If-Range</x:ref> header
        field, because the client has a cache entry for the associated
        representation, and</t>
     <t>That cache entry includes a <x:ref>Date</x:ref> value, which gives the
        time when the origin server sent the original response, and</t>
     <t>The presented Last-Modified time is at least 60 seconds before
        the Date value.</t>
  </list>
</t>
<t>
   or
  <list style="symbols">
     <t>The validator is being compared by an intermediate cache to the
        validator stored in its cache entry for the representation, and</t>
     <t>That cache entry includes a <x:ref>Date</x:ref> value, which gives the
        time when the origin server sent the original response, and</t>
     <t>The presented Last-Modified time is at least 60 seconds before
        the Date value.</t>
  </list>
</t>
<t>
   This method relies on the fact that if two different responses were
   sent by the origin server during the same second, but both had the
   same Last-Modified time, then at least one of those responses would
   have a <x:ref>Date</x:ref> value equal to its Last-Modified time. The
   arbitrary 60-second limit guards against the possibility that the Date and
   Last-Modified values are generated from different clocks or at somewhat
   different times during the preparation of the response. An
   implementation &MAY; use a value larger than 60 seconds, if it is
   believed that 60 seconds is too short.
</t>
</section>
</section>

<section title="ETag" anchor="header.etag">
  <iref primary="true" item="ETag header field" x:for-anchor=""/>
  <x:anchor-alias value="ETag"/>
  <x:anchor-alias value="entity-tag"/>
  <x:anchor-alias value="opaque-tag"/>
  <x:anchor-alias value="weak"/>
  <x:anchor-alias value="etagc"/>
<t>
   The "ETag" header field in a response provides the current entity-tag for
   the selected representation, as determined at the conclusion of handling
   the request.
   An entity-tag is an opaque validator for differentiating between
   multiple representations of the same resource, regardless of whether
   those multiple representations are due to resource state changes over
   time, content negotiation resulting in multiple representations being
   valid at the same time, or both. An entity-tag consists of an opaque
   quoted string, possibly prefixed by a weakness indicator.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="ETag"/><iref primary="true" item="Grammar" subitem="entity-tag"/><iref primary="true" item="Grammar" subitem="weak"/><iref primary="true" item="Grammar" subitem="opaque-tag"/><iref primary="true" item="Grammar" subitem="etagc"/>
  <x:ref>ETag</x:ref>       = <x:ref>entity-tag</x:ref>

  <x:ref>entity-tag</x:ref> = [ <x:ref>weak</x:ref> ] <x:ref>opaque-tag</x:ref>
  <x:ref>weak</x:ref>       = <x:abnf-char-sequence>"W/"</x:abnf-char-sequence> ; "W/", case-sensitive
  <x:ref>opaque-tag</x:ref> = <x:ref>DQUOTE</x:ref> *<x:ref>etagc</x:ref> <x:ref>DQUOTE</x:ref>
  <x:ref>etagc</x:ref>      = %x21 / %x23-7E / <x:ref>obs-text</x:ref>
             ; <x:ref>VCHAR</x:ref> except double quotes, plus obs-text
</artwork></figure>
<x:note>
  <t>
    &Note; Previously, opaque-tag was defined to be a quoted-string
    (<xref target="RFC2616" x:fmt="," x:sec="3.11"/>); thus, some recipients
    might perform backslash unescaping. Servers therefore ought to avoid
    backslash characters in entity tags.
  </t>
</x:note>
<t>
   An entity-tag can be more reliable for validation than a modification
   date in situations where it is inconvenient to store modification
   dates, where the one-second resolution of HTTP date values is not
   sufficient, or where modification dates are not consistently maintained.
</t>
<figure><preamble>
  Examples:
</preamble>
<artwork type="example">
  ETag: "xyzzy"
  ETag: W/"xyzzy"
  ETag: ""
</artwork></figure>
<t>
   An entity-tag can be either a weak or strong validator, with
   strong being the default.  If an origin server provides an entity-tag
   for a representation and the generation of that entity-tag does not satisfy
   all of the characteristics of a strong validator
   (<xref target="weak.and.strong.validators"/>), then the origin server
   &MUST; mark the entity-tag as weak by prefixing its opaque value
   with "W/" (case-sensitive).
</t>

<section title="Generation" anchor="entity.tag.generation">
<t>
   The principle behind entity-tags is that only the service author
   knows the implementation of a resource well enough to select the
   most accurate and efficient validation mechanism for that resource,
   and that any such mechanism can be mapped to a simple sequence of
   octets for easy comparison.  Since the value is opaque, there is no
   need for the client to be aware of how each entity-tag is constructed.
</t>
<t>
   For example, a resource that has implementation-specific versioning
   applied to all changes might use an internal revision number, perhaps
   combined with a variance identifier for content negotiation, to
   accurately differentiate between representations.
   Other implementations might use a collision-resistant hash of
   representation content, a combination of various file attributes, or
   a modification timestamp that has sub-second resolution.
</t>
<t>
   An origin server &SHOULD; send an ETag for any selected representation
   for which detection of changes can be reasonably and consistently
   determined, since the entity-tag's use in conditional requests and
   evaluating cache freshness (&caching;) can result in a substantial
   reduction of HTTP network traffic and can be a significant factor in
   improving service scalability and reliability.
</t>
</section>

<section title="Comparison" anchor="entity.tag.comparison">
  <x:anchor-alias value="validator.comparison"/>
  <x:anchor-alias value="strong comparison"/>
  <x:anchor-alias value="weak comparison"/>
<t>
   There are two entity-tag comparison functions, depending on whether or not
   the comparison context allows the use of weak validators:
  <list style="symbols">
     <t><x:dfn>Strong comparison</x:dfn>: two entity-tags are equivalent if both
        are not weak and their opaque-tags match character-by-character.</t>
     <t><x:dfn>Weak comparison</x:dfn>: two entity-tags are equivalent if their opaque-tags
        match character-by-character, regardless of either or both
        being tagged as "weak".</t>
  </list>
</t>
<t>
   The example below shows the results for a set of entity-tag pairs and both
   the weak and strong comparison function results:
</t>
<texttable align="left">
  <ttcol>ETag 1</ttcol>
  <ttcol>ETag 2</ttcol>
  <ttcol>Strong Comparison</ttcol>
  <ttcol>Weak Comparison</ttcol>

  <c>W/"1"</c>
  <c>W/"1"</c>
  <c>no match</c>
  <c>match</c>
  
  <c>W/"1"</c>
  <c>W/"2"</c>
  <c>no match</c>
  <c>no match</c>

  <c>W/"1"</c>
  <c>"1"</c>
  <c>no match</c>
  <c>match</c>

  <c>"1"</c>
  <c>"1"</c>
  <c>match</c>
  <c>match</c>
</texttable>
</section>

<section title="Example: Entity-Tags Varying on Content-Negotiated Resources" anchor="example.entity.tag.vs.conneg">
<t>
   Consider a resource that is subject to content negotiation
   (&content-negotiation;), and where the representations sent in response to
   a GET request vary based on the <x:ref>Accept-Encoding</x:ref> request
   header field (&header-accept-encoding;):
</t>
<figure><preamble>>> Request:</preamble><artwork type="message/http; msgtype=&#34;request&#34;"  x:indent-with="  ">
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip

</artwork></figure>
<t>
   In this case, the response might or might not use the gzip content coding.
   If it does not, the response might look like:
</t>
<figure><preamble>>> Response:</preamble><artwork type="message/http; msgtype=&#34;response&#34;"  x:indent-with="  ">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: <x:length-of target="exbody"/>
Vary: Accept-Encoding
Content-Type: text/plain

<x:span anchor="exbody">Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
</x:span></artwork></figure>
<t>
   An alternative representation that does use gzip content coding would be:
</t>
<figure><preamble>>> Response:</preamble><artwork type="message/http; msgtype=&#34;response&#34;"  x:indent-with="  ">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

<spanx>...binary data...</spanx></artwork></figure>
<x:note>
  <t>
    &Note; Content codings are a property of the representation data,
    so a strong entity-tag for a content-encoded representation has to be
    distinct from the entity tag of an unencoded representation to prevent
    potential conflicts during cache updates and range requests. In contrast,
    transfer codings (&transfer-codings;) apply only during message transfer
    and do not result in distinct entity-tags.
  </t>
</x:note>
</section>
</section>

<section title="When to Use Entity-Tags and Last-Modified Dates" anchor="when.to.use.entity.tags.and.last-modified.dates">
<t>
   In <x:ref>200 (OK)</x:ref> responses to GET or HEAD, an origin server:
  <list style="symbols">
     <t>&SHOULD; send an entity-tag validator unless it is not feasible to
        generate one.</t>

     <t>&MAY; send a weak entity-tag instead of a strong entity-tag, if
        performance considerations support the use of weak entity-tags,
        or if it is unfeasible to send a strong entity-tag.</t>

     <t>&SHOULD; send a <x:ref>Last-Modified</x:ref> value if it is feasible to
        send one.</t>
  </list>
</t>
<t>
   In other words, the preferred behavior for an origin server
   is to send both a strong entity-tag and a <x:ref>Last-Modified</x:ref>
   value in successful responses to a retrieval request.
</t>
<t>
   A client:
  <list style="symbols">
     <t>&MUST; send that entity-tag in any cache validation request (using
        <x:ref>If-Match</x:ref> or <x:ref>If-None-Match</x:ref>) if an
        entity-tag has been provided by the origin server.</t>

     <t>&SHOULD; send the <x:ref>Last-Modified</x:ref> value in non-subrange
        cache validation requests (using <x:ref>If-Modified-Since</x:ref>)
        if only a Last-Modified value has been provided by the origin server.</t>

     <t>&MAY; send the <x:ref>Last-Modified</x:ref> value in subrange
        cache validation requests (using <x:ref>If-Unmodified-Since</x:ref>)
        if only a Last-Modified value has been provided by an HTTP/1.0 origin
        server. The user agent &SHOULD; provide a way to disable this, in case
        of difficulty.</t>

     <t>&SHOULD; send both validators in cache validation requests if both an
        entity-tag and a <x:ref>Last-Modified</x:ref> value have been provided
        by the origin server. This allows both HTTP/1.0 and HTTP/1.1 caches to
        respond appropriately.</t>
  </list>
</t>
</section>
</section>

<section title="Precondition Header Fields" anchor="preconditions">
<t>
   This section defines the syntax and semantics of HTTP/1.1 header fields
   for applying preconditions on requests.
   <xref target="evaluation"/> defines when the preconditions are applied.
   <xref target="precedence"/> defines the order of evaluation when more than
   one precondition is present.
</t>

<section title="If-Match" anchor="header.if-match">
  <iref primary="true" item="If-Match header field" x:for-anchor=""/>
  <x:anchor-alias value="If-Match"/>
<t>
   The "If-Match" header field makes the request method conditional on the
   recipient origin server either having at least one current
   representation of the target resource, when the field-value is "*", or
   having a current representation of the target resource that has an
   entity-tag matching a member of the list of entity-tags provided in the
   field-value.
</t>
<t>
   An origin server &MUST; use the strong comparison function when comparing
   entity-tags for If-Match (<xref target="entity.tag.comparison"/>), since
   the client intends this precondition to prevent the method from being
   applied if there have been any changes to the representation data.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Match"/>
  <x:ref>If-Match</x:ref> = "*" / 1#<x:ref>entity-tag</x:ref>
</artwork></figure>
<t>
   Examples:
</t>
<figure><artwork type="example">
  If-Match: "xyzzy"
  If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
  If-Match: *
</artwork></figure>
<t>
   If-Match is most often used with state-changing methods (e.g., POST, PUT,
   DELETE) to prevent accidental overwrites when multiple user agents might be
   acting in parallel on the same resource (i.e., to prevent the "lost update"
   problem). It can also be used with safe methods to abort a request if the
   <x:ref>selected representation</x:ref> does not match one already stored
   (or partially stored) from a prior request.
</t>
<t>
   An origin server that receives an If-Match header field &MUST; evaluate the
   condition prior to performing the method (<xref target="evaluation"/>).
   If the field-value is "*", the condition is false if the origin server
   does not have a current representation for the target resource.
   If the field-value is a list of entity-tags, the condition is false if
   none of the listed tags match the entity-tag of the selected representation.
</t>
<t>
   An origin server &MUST-NOT; perform the requested method if a received
   If-Match condition evaluates to false; instead, the origin server &MUST;
   respond with either
   a) the <x:ref>412 (Precondition Failed)</x:ref> status code or
   b) one of the <x:ref>2xx (Successful)</x:ref> status codes if the origin
   server has verified that a state change is being requested and the final
   state is already reflected in the current state of the target resource
   (i.e., the change requested by the user agent has already succeeded, but
   the user agent might not be aware of it, perhaps because the prior response
   was lost or a compatible change was made by some other user agent).
   In the latter case, the origin server &MUST-NOT; send a validator header
   field in the response unless it can verify that the request is a duplicate
   of an immediately prior change made by the same user agent.
</t>
<t>
   The If-Match header field can be ignored by caches and intermediaries
   because it is not applicable to a stored response.
</t>
</section>

<section title="If-None-Match" anchor="header.if-none-match">
  <iref primary="true" item="If-None-Match header field" x:for-anchor=""/>
  <x:anchor-alias value="If-None-Match"/>
<t>
   The "If-None-Match" header field makes the request method conditional on
   a recipient cache or origin server either not having any current
   representation of the target resource, when the field-value is "*", or
   having a selected representation with an entity-tag that does not match any
   of those listed in the field-value.
</t>
<t>
   A recipient &MUST; use the weak comparison function when comparing
   entity-tags for If-None-Match (<xref target="entity.tag.comparison"/>),
   since weak entity-tags can be used for cache validation even if there have
   been changes to the representation data.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-None-Match"/>
  <x:ref>If-None-Match</x:ref> = "*" / 1#<x:ref>entity-tag</x:ref>
</artwork></figure>
<t>
   Examples:
</t>
<figure><artwork type="example">
  If-None-Match: "xyzzy"
  If-None-Match: W/"xyzzy"
  If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
  If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
  If-None-Match: *
</artwork></figure>
<t>
   If-None-Match is primarily used in conditional GET requests to enable
   efficient updates of cached information with a minimum amount of
   transaction overhead. When a client desires to update one or more stored
   responses that have entity-tags, the client &SHOULD; generate an
   If-None-Match header field containing a list of those entity-tags when
   making a GET request; this allows recipient servers to send a
   <x:ref>304 (Not Modified)</x:ref> response to indicate when one of those
   stored responses matches the selected representation.
</t>
<t>
   If-None-Match can also be used with a value of "*" to prevent an unsafe
   request method (e.g., PUT) from inadvertently modifying an existing
   representation of the target resource when the client believes that
   the resource does not have a current representation (&safe-methods;).
   This is a variation on the "lost update" problem that might arise if more
   than one client attempts to create an initial representation for the target
   resource.
</t>
<t>
   An origin server that receives an If-None-Match header field &MUST;
   evaluate the condition prior to performing the method
   (<xref target="evaluation"/>).
   If the field-value is "*", the condition is false if the origin server
   has a current representation for the target resource.
   If the field-value is a list of entity-tags, the condition is false if
   one of the listed tags match the entity-tag of the selected representation.
</t>
<t>
   An origin server &MUST-NOT; perform the requested method if the condition
   evaluates to false; instead, the origin server &MUST; respond with either
   a) the <x:ref>304 (Not Modified)</x:ref> status code if the request method
   is GET or HEAD or b) the <x:ref>412 (Precondition Failed)</x:ref> status
   code for all other request methods.
</t>
<t>
   Requirements on cache handling of a received If-None-Match header field
   are defined in &cache-validation-received;.
</t>
</section>

<section title="If-Modified-Since" anchor="header.if-modified-since">
  <iref primary="true" item="If-Modified-Since header field" x:for-anchor=""/>
  <x:anchor-alias value="If-Modified-Since"/>
<t>
   The "If-Modified-Since" header field makes a GET or HEAD request method
   conditional on the selected representation's modification date being more
   recent than the date provided in the field-value. Transfer of the selected
   representation's data is avoided if that data has not changed.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Modified-Since"/>
  <x:ref>If-Modified-Since</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example of the field is:
</t>
<figure><artwork type="example">
  If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</artwork></figure>
<t>
   A recipient &MUST; ignore If-Modified-Since if the request contains an
   <x:ref>If-None-Match</x:ref> header field; the condition in
   <x:ref>If-None-Match</x:ref> is considered to be a more accurate
   replacement for the condition in If-Modified-Since, and the two are only
   combined for the sake of interoperating with older intermediaries that
   might not implement <x:ref>If-None-Match</x:ref>.
</t>
<t>
   A recipient &MUST; ignore the If-Modified-Since header field if the
   received field-value is not a valid HTTP-date, or if the request method
   is neither GET nor HEAD.
</t>
<t>
   A recipient &MUST; interpret an If-Modified-Since field-value's timestamp
   in terms of the origin server's clock.
</t>
<t>
   If-Modified-Since is typically used for two distinct purposes:
   1) to allow efficient updates of a cached representation that does not
   have an entity-tag and 2) to limit the scope of a web traversal to resources 
   that have recently changed.
</t>
<t>
   When used for cache updates, a cache will typically use the value of the
   cached message's <x:ref>Last-Modified</x:ref> field to generate the field
   value of If-Modified-Since. This behavior is most interoperable for cases
   where clocks are poorly synchronized or when the server has chosen to only
   honor exact timestamp matches (due to a problem with Last-Modified dates
   that appear to go "back in time" when the origin server's clock is
   corrected or a representation is restored from an archived backup).
   However, caches occasionally generate the field value based on other data,
   such as the <x:ref>Date</x:ref> header field of the cached message or the
   local clock time that the message was received, particularly when the
   cached message does not contain a <x:ref>Last-Modified</x:ref> field.
</t>
<t>
   When used for limiting the scope of retrieval to a recent time window, a
   user agent will generate an If-Modified-Since field value based on either
   its own local clock or a <x:ref>Date</x:ref> header field received from the
   server in a prior response. Origin servers that choose an exact timestamp
   match based on the selected representation's <x:ref>Last-Modified</x:ref>
   field will not be able to help the user agent limit its data transfers to
   only those changed during the specified window.
</t>
<t>
   An origin server that receives an If-Modified-Since header field &SHOULD;
   evaluate the condition prior to performing the method
   (<xref target="evaluation"/>).
   The origin server &SHOULD-NOT; perform the requested method if the selected
   representation's last modification date is earlier than or equal to the
   date provided in the field-value; instead, the origin server &SHOULD;
   generate a <x:ref>304 (Not Modified)</x:ref> response, including only those
   metadata that are useful for identifying or updating a previously cached
   response.
</t>
<t>
   Requirements on cache handling of a received If-Modified-Since header field
   are defined in &cache-validation-received;.
</t>
</section>

<section title="If-Unmodified-Since" anchor="header.if-unmodified-since">
  <iref primary="true" item="If-Unmodified-Since header field" x:for-anchor=""/>
  <x:anchor-alias value="If-Unmodified-Since"/>
<t>
   The "If-Unmodified-Since" header field makes the request method conditional
   on the selected representation's last modification date being earlier than or
   equal to the date provided in the field-value. This field accomplishes the
   same purpose as <x:ref>If-Match</x:ref> for cases where the user agent does
   not have an entity-tag for the representation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Unmodified-Since"/>
  <x:ref>If-Unmodified-Since</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example of the field is:
</t>
<figure><artwork type="example">
  If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</artwork></figure>
<t>
   A recipient &MUST; ignore If-Unmodified-Since if the request contains an
   <x:ref>If-Match</x:ref> header field; the condition in
   <x:ref>If-Match</x:ref> is considered to be a more accurate replacement for
   the condition in If-Unmodified-Since, and the two are only combined for the
   sake of interoperating with older intermediaries that might not implement
   <x:ref>If-Match</x:ref>.
</t>
<t>
   A recipient &MUST; ignore the If-Unmodified-Since header field if the
   received field-value is not a valid HTTP-date.
</t>
<t>
   A recipient &MUST; interpret an If-Unmodified-Since field-value's timestamp
   in terms of the origin server's clock.
</t>
<t>
   If-Unmodified-Since is most often used with state-changing methods
   (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple
   user agents might be acting in parallel on a resource that does
   not supply entity-tags with its representations (i.e., to prevent the
   "lost update" problem). It can also be used with safe methods to abort a
   request if the <x:ref>selected representation</x:ref> does not match one
   already stored (or partially stored) from a prior request.
</t>
<t>
   An origin server that receives an If-Unmodified-Since header field &MUST;
   evaluate the condition prior to performing the method
   (<xref target="evaluation"/>).
   The origin server &MUST-NOT; perform the requested method if the selected
   representation's last modification date is more recent than the date
   provided in the field-value; instead the origin server &MUST; respond with either
   a) the <x:ref>412 (Precondition Failed)</x:ref> status code or
   b) one of the <x:ref>2xx (Successful)</x:ref> status codes if the origin
   server has verified that a state change is being requested and the final
   state is already reflected in the current state of the target resource
   (i.e., the change requested by the user agent has already succeeded, but
   the user agent might not be aware of that because the prior response message
   was lost or a compatible change was made by some other user agent).
   In the latter case, the origin server &MUST-NOT; send a validator header
   field in the response unless it can verify that the request is a duplicate
   of an immediately prior change made by the same user agent.
</t>
<t>
   The If-Unmodified-Since header field can be ignored by caches and
   intermediaries because it is not applicable to a stored response.
</t>
</section>

<section title="If-Range" anchor="header.if-range">
<t>
   The "If-Range" header field provides a special conditional request
   mechanism that is similar to the <x:ref>If-Match</x:ref> and
   <x:ref>If-Unmodified-Since</x:ref> header fields but that instructs the
   recipient to ignore the <x:ref>Range</x:ref> header field if the validator
   doesn't match, resulting in transfer of the new selected representation
   instead of a <x:ref>412 (Precondition Failed)</x:ref> response. If-Range is
   defined in &header-if-range;.
</t>
</section>
</section>

<section title="Status Code Definitions" anchor="status.code.definitions">
<section title="304 Not Modified" anchor="status.304">
  <iref primary="true" item="304 Not Modified (status code)" x:for-anchor=""/>
  <x:anchor-alias value="304"/>
  <x:anchor-alias value="304 (Not Modified)"/>
<t>
   The <x:dfn>304 (Not Modified)</x:dfn> status code indicates that a
   conditional GET or HEAD request has been
   received and would have resulted in a <x:ref>200 (OK)</x:ref> response
   if it were not for the fact that the condition evaluated to false.
   In other words, there is no need for the server to transfer a
   representation of the target resource because the request indicates that
   the client, which made the request conditional, already has a valid
   representation; the server is therefore redirecting the client to make
   use of that stored representation as if it were the payload of a
   <x:ref>200 (OK)</x:ref> response.
</t>
<t>
   The server generating a 304 response &MUST; generate any of the following
   header fields that would have been sent in a <x:ref>200 (OK)</x:ref>
   response to the same request:
   <x:ref>Cache-Control</x:ref>,
   <x:ref>Content-Location</x:ref>,
   <x:ref>Date</x:ref>,
   <x:ref>ETag</x:ref>,
   <x:ref>Expires</x:ref>, and
   <x:ref>Vary</x:ref>.
</t>
<t>
   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations,
   a sender &SHOULD-NOT; generate representation metadata other
   than the above listed fields unless said metadata exists for the
   purpose of guiding cache updates (e.g., <x:ref>Last-Modified</x:ref> might
   be useful if the response does not have an <x:ref>ETag</x:ref> field).
</t>
<t>
   Requirements on a cache that receives a 304 response are defined in
   &freshening-responses;. If the conditional request originated with an
   outbound client, such as a user agent with its own cache sending a
   conditional GET to a shared proxy, then the proxy &SHOULD; forward the
   304 response to that client.
</t>
<t>
   A 304 response cannot contain a message-body; it is always
   terminated by the first empty line after the header fields.
</t>
</section>

<section title="412 Precondition Failed" anchor="status.412">
  <iref primary="true" item="412 Precondition Failed (status code)" x:for-anchor=""/>
  <x:anchor-alias value="412 (Precondition Failed)"/>
<t>
   The <x:dfn>412 (Precondition Failed)</x:dfn> status code indicates that one
   or more conditions given in the request header fields evaluated to false
   when tested on the server. This response code allows the client to place
   preconditions on the current resource state (its current representations
   and metadata) and, thus, prevent the request method from being applied if the
   target resource is in an unexpected state.
</t>
</section>
</section>

<section title="Evaluation" anchor="evaluation">
<t>
   Except when excluded below, a recipient cache or origin server &MUST;
   evaluate received request preconditions after it has successfully performed
   its normal request checks and just before it would perform the action
   associated with the request method.
   A server &MUST; ignore all received preconditions if its response to the
   same request without those conditions would have been a status code other
   than a <x:ref>2xx (Successful)</x:ref> or <x:ref>412 (Precondition Failed)</x:ref>.
   In other words, redirects and failures take precedence over the evaluation
   of preconditions in conditional requests.
</t>
<t>
   A server that is not the origin server for the target resource and cannot
   act as a cache for requests on the target resource &MUST-NOT; evaluate the
   conditional request header fields defined by this specification, and it
   &MUST; forward them if the request is forwarded, since the generating
   client intends that they be evaluated by a server that can provide a
   current representation.
   Likewise, a server &MUST; ignore the conditional request header fields
   defined by this specification when received with a request method that does
   not involve the selection or modification of a
   <x:ref>selected representation</x:ref>, such as CONNECT, OPTIONS, or TRACE.
</t>
<t>
   Conditional request header fields that are defined by extensions to HTTP
   might place conditions on all recipients, on the state of the target
   resource in general, or on a group of resources. For instance, the "If"
   header field in WebDAV can make a request conditional on various aspects
   of multiple resources, such as locks, if the recipient understands and
   implements that field (<xref target="RFC4918" x:fmt="," x:sec="10.4"/>).
</t>
<t>
   Although conditional request header fields are defined as being usable with
   the HEAD method (to keep HEAD's semantics consistent with those of GET),
   there is no point in sending a conditional HEAD because a successful
   response is around the same size as a <x:ref>304 (Not Modified)</x:ref>
   response and more useful than a <x:ref>412 (Precondition Failed)</x:ref>
   response.
</t>
</section>

<section title="Precedence" anchor="precedence">
<t>
   When more than one conditional request header field is present in a request,
   the order in which the fields are evaluated becomes important. In practice,
   the fields defined in this document are consistently implemented in a
   single, logical order, since "lost update" preconditions have more strict
   requirements than cache validation, a validated cache is more efficient
   than a partial response, and entity tags are presumed to be more accurate
   than date validators.
</t>
<t>
   A recipient cache or origin server &MUST; evaluate the request
   preconditions defined by this specification in the following order:
   <list style="numbers">
     <t anchor="precedence1">When recipient is the origin server and
       <x:ref>If-Match</x:ref> is present,
       evaluate the <x:ref>If-Match</x:ref> precondition:
       <list style="symbols">
         <t>if true, continue to step <xref target="precedence3" format="counter"/></t>
         <t>if false, respond <x:ref>412 (Precondition Failed)</x:ref> unless
            it can be determined that the state-changing request has already
            succeeded (see <xref target="header.if-match"/>)</t>
       </list>
     </t>
     <t anchor="precedence2">When recipient is the origin server,
       <x:ref>If-Match</x:ref> is not present, and
       <x:ref>If-Unmodified-Since</x:ref> is present,
       evaluate the <x:ref>If-Unmodified-Since</x:ref> precondition:
       <list style="symbols">
         <t>if true, continue to step <xref target="precedence3" format="counter"/></t>
         <t>if false, respond <x:ref>412 (Precondition Failed)</x:ref> unless
            it can be determined that the state-changing request has already
            succeeded (see <xref target="header.if-unmodified-since"/>)</t>
       </list>
     </t>
     <t anchor="precedence3">When <x:ref>If-None-Match</x:ref> is present,
       evaluate the <x:ref>If-None-Match</x:ref> precondition:
       <list style="symbols">
         <t>if true, continue to step <xref target="precedence5" format="counter"/></t>
         <t>if false for GET/HEAD, respond <x:ref>304 (Not Modified)</x:ref></t>
         <t>if false for other methods, respond <x:ref>412 (Precondition Failed)</x:ref></t>
       </list>
     </t>
     <t anchor="precedence4">When the method is GET or HEAD,
       <x:ref>If-None-Match</x:ref> is not present, and
       <x:ref>If-Modified-Since</x:ref> is present,
       evaluate the <x:ref>If-Modified-Since</x:ref> precondition:
       <list style="symbols">
         <t>if true, continue to step <xref target="precedence5" format="counter"/></t>
         <t>if false, respond <x:ref>304 (Not Modified)</x:ref></t>
       </list>
     </t>
     <t anchor="precedence5">When the method is GET and both
       <x:ref>Range</x:ref> and <x:ref>If-Range</x:ref> are present,
       evaluate the <x:ref>If-Range</x:ref> precondition:
       <list style="symbols">
         <t>if the validator matches and the Range specification is
            applicable to the selected representation, respond
            <x:ref>206 (Partial Content)</x:ref> <xref target="RFC7233"/></t>
       </list>
     </t>
     <t anchor="precedencelast">Otherwise,
       <list style="symbols">
         <t>all conditions are met, so perform the requested action and
            respond according to its success or failure.</t>
       </list>
     </t>
   </list>
</t>
<t>
   Any extension to HTTP/1.1 that defines additional conditional request
   header fields ought to define its own expectations regarding the order
   for evaluating such fields in relation to those defined in this document
   and other conditionals that might be found in practice.
</t>
</section>

<section title="IANA Considerations" anchor="IANA.considerations">

<section title="Status Code Registration" anchor="status.code.registration">
<t>
   The "Hypertext Transfer Protocol (HTTP) Status Code Registry" located at <eref target="http://www.iana.org/assignments/http-status-codes"/>
   has been updated with the registrations below:
</t>
<?BEGININC p4-conditional.iana-status-codes ?>
<!--AUTOGENERATED FROM extract-status-code-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.status.code.registration.table">
   <ttcol>Value</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>304</c>
   <c>Not Modified</c>
   <c>
      <xref target="status.304"/>
   </c>
   <c>412</c>
   <c>Precondition Failed</c>
   <c>
      <xref target="status.412"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p4-conditional.iana-status-codes ?>
</section>

<section title="Header Field Registration" anchor="header.field.registration">
<t>
   HTTP header fields are registered within the "Message Headers" registry
   maintained at
   <eref target="http://www.iana.org/assignments/message-headers/"/>.
</t>
<t>
   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the 
   permanent registrations below (see <xref target="BCP90"/>):
</t>
<?BEGININC p4-conditional.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>ETag</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.etag"/>
   </c>
   <c>If-Match</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-match"/>
   </c>
   <c>If-Modified-Since</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-modified-since"/>
   </c>
   <c>If-None-Match</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-none-match"/>
   </c>
   <c>If-Unmodified-Since</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-unmodified-since"/>
   </c>
   <c>Last-Modified</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.last-modified"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p4-conditional.iana-headers ?>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>
</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   This section is meant to inform developers, information providers, and
   users of known security concerns specific to the HTTP conditional
   request mechanisms. More general security considerations are addressed
   in HTTP "Message Syntax and Routing" &messaging; and "Semantics and Content"
   &semantics;.
</t>
<t>
   The validators defined by this specification are not intended to ensure
   the validity of a representation, guard against malicious changes, or
   detect man-in-the-middle attacks. At best, they enable more efficient cache
   updates and optimistic concurrent writes when all participants are behaving
   nicely. At worst, the conditions will fail and the client will receive a
   response that is no more harmful than an HTTP exchange without conditional
   requests.
</t>
<t>
   An entity-tag can be abused in ways that create privacy risks. For example,
   a site might deliberately construct a semantically invalid entity-tag that
   is unique to the user or user agent, send it in a cacheable response with a
   long freshness time, and then read that entity-tag in later conditional
   requests as a means of re-identifying that user or user agent. Such an
   identifying tag would become a persistent identifier for as long as the
   user agent retained the original cache entry. User agents that cache
   representations ought to ensure that the cache is cleared or replaced
   whenever the user performs privacy-maintaining actions, such as clearing
   stored cookies or changing to a private browsing mode.
</t>
</section>

<section title="Acknowledgments" anchor="acks">
<t>
  See &acks;.
</t>
</section>
</middle>
<back>

<references title="Normative References">

<reference anchor="RFC7230">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7230"/>
  <x:source href="rfc7230.xml" basename="rfc7230"/>
</reference>

<reference anchor="RFC7231">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7231"/>
  <x:source href="rfc7231.xml" basename="rfc7231">
    <x:defines>2xx</x:defines>
    <x:defines>2xx (Successful)</x:defines>
    <x:defines>200 (OK)</x:defines>
    <x:defines>204 (No Content)</x:defines>
    <x:defines>Accept-Encoding</x:defines>
    <x:defines>Content-Location</x:defines>
    <x:defines>Content-Type</x:defines>
    <x:defines>Date</x:defines>
    <x:defines>Location</x:defines>
    <x:defines>Vary</x:defines>
    <x:defines>selected representation</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7233">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7233"/>
  <x:source href="rfc7233.xml" basename="rfc7233">
    <x:defines>If-Range</x:defines>
    <x:defines>Range</x:defines>
    <x:defines>206 (Partial Content)</x:defines>
  </x:source>
</reference>

<reference anchor="RFC7234">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
      <organization>Akamai</organization>
      <address><email>mnot@mnot.net</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="June" year="2014"/>
  </front>
  <seriesInfo name="RFC" value="7234"/>
  <x:source href="rfc7234.xml" basename="rfc7234">
    <x:defines>Cache-Control</x:defines>
    <x:defines>Expires</x:defines>
  </x:source>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
        <email>dcrocker@bbiw.net</email>
      </address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
        <email>paul.overell@thus.net</email>
      </address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

</references>

<references title="Informative References">

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor='BCP90'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

<reference anchor='RFC4918'>
  <front>
    <title>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</title>
    <author initials="L.M." surname="Dusseault" fullname="Lisa Dusseault" role="editor" >
      <organization abbrev="CommerceNet">CommerceNet</organization>
      <address><email>ldusseault@commerce.net</email></address>
    </author>
    <date month="June" year="2007" />
  </front>
  <seriesInfo name='RFC' value='4918' />
</reference>
</references>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
  The definition of validator weakness has been expanded and clarified.
  (<xref target="weak.and.strong.validators" />)
</t>
<t>
  Weak entity-tags are now allowed in all requests except range requests.
  (Sections <xref target="weak.and.strong.validators" format="counter"/> and
  <xref target="header.if-none-match" format="counter"/>)
</t>
<t>
  The <x:ref>ETag</x:ref> header field ABNF has been changed to not use
  quoted-string, thus avoiding escaping issues.
  (<xref target="header.etag" />)
</t>
<t>
  ETag is defined to provide an entity tag for the selected representation,
  thereby clarifying what it applies to in various situations (such as a 
  PUT response).
  (<xref target="header.etag" />)
</t>
<t>
  The precedence for evaluation of conditional requests has been defined.
  (<xref target="precedence" />)
</t>
</section>

<section title="Imported ABNF" anchor="imported.abnf">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="DQUOTE"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="VCHAR"/>
  <x:anchor-alias value="core.rules"/>
  <x:anchor-alias value="obs-text"/>
  <x:anchor-alias value="OWS"/>
  <x:anchor-alias value="HTTP-date"/>
<t>
  The following core rules are included by
  reference, as defined in <xref target="RFC5234" x:fmt="of" x:sec="B.1"/>:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space), and
  VCHAR (any visible US-ASCII character).
</t>
<t>
  The rules below are defined in <xref target="RFC7230"/>:
</t>
<figure><artwork type="abnf2616">
  <x:ref>OWS</x:ref>           = &lt;OWS, see &whitespace;&gt;
  <x:ref>obs-text</x:ref>      = &lt;obs-text, see &field-components;&gt;
</artwork></figure>
<t>
  The rules below are defined in other parts: 
</t>
<figure><artwork type="abnf2616">
  <x:ref>HTTP-date</x:ref>     = &lt;HTTP-date, see &http-date;&gt;
</artwork></figure>
</section> 

<?BEGININC p4-conditional.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<t>
  In the collected ABNF below, list rules are expanded as per <xref target="RFC7230" x:rel="#notation"/>.
</t><figure>
<artwork type="abnf" name="p4-conditional.parsed-abnf">
<x:ref>ETag</x:ref> = entity-tag

<x:ref>HTTP-date</x:ref> = &lt;HTTP-date, see [RFC7231], Section 7.1.1.1&gt;

<x:ref>If-Match</x:ref> = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS
 entity-tag ] ) )
<x:ref>If-Modified-Since</x:ref> = HTTP-date
<x:ref>If-None-Match</x:ref> = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS
 entity-tag ] ) )
<x:ref>If-Unmodified-Since</x:ref> = HTTP-date

<x:ref>Last-Modified</x:ref> = HTTP-date

<x:ref>OWS</x:ref> = &lt;OWS, see [RFC7230], Section 3.2.3&gt;

<x:ref>entity-tag</x:ref> = [ weak ] opaque-tag
<x:ref>etagc</x:ref> = "!" / %x23-7E ; '#'-'~'
 / obs-text

<x:ref>obs-text</x:ref> = &lt;obs-text, see [RFC7230], Section 3.2.6&gt;
<x:ref>opaque-tag</x:ref> = DQUOTE *etagc DQUOTE

<x:ref>weak</x:ref> = %x57.2F ; W/
</artwork>
</figure>
</section>
<?ENDINC p4-conditional.abnf-appendix ?>
</back>
</rfc>
